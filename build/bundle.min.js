(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * @author dmarcos / https://github.com/dmarcos
 * @author mrdoob / http://mrdoob.com
 */

THREE.VRControls = function ( object, onError ) {

	var scope = this;

	var vrDisplay, vrDisplays;

	var standingMatrix = new THREE.Matrix4();

	var frameData = null;

	if ( 'VRFrameData' in window ) {

		frameData = new VRFrameData();

	}

	function gotVRDisplays( displays ) {

		vrDisplays = displays;

		if ( displays.length > 0 ) {

			vrDisplay = displays[ 0 ];

		} else {

			if ( onError ) onError( 'VR input not available.' );

		}

	}

	if ( navigator.getVRDisplays ) {

		navigator.getVRDisplays().then( gotVRDisplays ).catch ( function () {

			console.warn( 'THREE.VRControls: Unable to get VR Displays' );

		} );

	}

	// the Rift SDK returns the position in meters
	// this scale factor allows the user to define how meters
	// are converted to scene units.

	this.scale = 1;

	// If true will use "standing space" coordinate system where y=0 is the
	// floor and x=0, z=0 is the center of the room.
	this.standing = false;

	// Distance from the users eyes to the floor in meters. Used when
	// standing=true but the VRDisplay doesn't provide stageParameters.
	this.userHeight = 1.6;

	this.getVRDisplay = function () {

		return vrDisplay;

	};

	this.setVRDisplay = function ( value ) {

		vrDisplay = value;

	};

	this.getVRDisplays = function () {

		console.warn( 'THREE.VRControls: getVRDisplays() is being deprecated.' );
		return vrDisplays;

	};

	this.getStandingMatrix = function () {

		return standingMatrix;

	};

	this.update = function () {

		if ( vrDisplay ) {

			var pose;

			if ( vrDisplay.getFrameData ) {

				vrDisplay.getFrameData( frameData );
				pose = frameData.pose;

			} else if ( vrDisplay.getPose ) {

				pose = vrDisplay.getPose();

			}

			if ( pose.orientation !== null ) {

				object.quaternion.fromArray( pose.orientation );

			}

			if ( pose.position !== null ) {

				object.position.fromArray( pose.position );

			} else {

				object.position.set( 0, 0, 0 );

			}

			if ( this.standing ) {

				if ( vrDisplay.stageParameters ) {

					object.updateMatrix();

					standingMatrix.fromArray( vrDisplay.stageParameters.sittingToStandingTransform );
					object.applyMatrix( standingMatrix );

				} else {

					object.position.setY( object.position.y + this.userHeight );

				}

			}

			object.position.multiplyScalar( scope.scale );

		}

	};

	this.resetPose = function () {

		if ( vrDisplay ) {

			vrDisplay.resetPose();

		}

	};

	this.resetSensor = function () {

		console.warn( 'THREE.VRControls: .resetSensor() is now .resetPose().' );
		this.resetPose();

	};

	this.zeroSensor = function () {

		console.warn( 'THREE.VRControls: .zeroSensor() is now .resetPose().' );
		this.resetPose();

	};

	this.dispose = function () {

		vrDisplay = null;

	};

};

},{}],2:[function(require,module,exports){
/**
 * @author dmarcos / https://github.com/dmarcos
 * @author mrdoob / http://mrdoob.com
 *
 * WebVR Spec: http://mozvr.github.io/webvr-spec/webvr.html
 *
 * Firefox: http://mozvr.com/downloads/
 * Chromium: https://webvr.info/get-chrome
 *
 */

THREE.VREffect = function( renderer, onError ) {

	var vrDisplay, vrDisplays;
	var eyeTranslationL = new THREE.Vector3();
	var eyeTranslationR = new THREE.Vector3();
	var renderRectL, renderRectR;

	var frameData = null;

	if ( 'VRFrameData' in window ) {

		frameData = new window.VRFrameData();

	}

	function gotVRDisplays( displays ) {

		vrDisplays = displays;

		if ( displays.length > 0 ) {

			vrDisplay = displays[ 0 ];

		} else {

			if ( onError ) onError( 'HMD not available' );

		}

	}

	if ( navigator.getVRDisplays ) {

		navigator.getVRDisplays().then( gotVRDisplays ).catch( function() {

			console.warn( 'THREE.VREffect: Unable to get VR Displays' );

		} );

	}

	//

	this.isPresenting = false;
	this.scale = 1;

	var scope = this;

	var rendererSize = renderer.getSize();
	var rendererUpdateStyle = false;
	var rendererPixelRatio = renderer.getPixelRatio();

	this.getVRDisplay = function() {

		return vrDisplay;

	};

	this.setVRDisplay = function( value ) {

		vrDisplay = value;

	};

	this.getVRDisplays = function() {

		console.warn( 'THREE.VREffect: getVRDisplays() is being deprecated.' );
		return vrDisplays;

	};

	this.setSize = function( width, height, updateStyle ) {

		rendererSize = { width: width, height: height };
		rendererUpdateStyle = updateStyle;

		if ( scope.isPresenting ) {

			var eyeParamsL = vrDisplay.getEyeParameters( 'left' );
			renderer.setPixelRatio( 1 );
			renderer.setSize( eyeParamsL.renderWidth * 2, eyeParamsL.renderHeight, false );

		} else {

			renderer.setPixelRatio( rendererPixelRatio );
			renderer.setSize( width, height, updateStyle );

		}

	};

	// VR presentation

	var canvas = renderer.domElement;
	var defaultLeftBounds = [ 0.0, 0.0, 0.5, 1.0 ];
	var defaultRightBounds = [ 0.5, 0.0, 0.5, 1.0 ];

	function onVRDisplayPresentChange() {

		var wasPresenting = scope.isPresenting;
		scope.isPresenting = vrDisplay !== undefined && vrDisplay.isPresenting;

		if ( scope.isPresenting ) {

			var eyeParamsL = vrDisplay.getEyeParameters( 'left' );
			var eyeWidth = eyeParamsL.renderWidth;
			var eyeHeight = eyeParamsL.renderHeight;

			if ( ! wasPresenting ) {

				rendererPixelRatio = renderer.getPixelRatio();
				rendererSize = renderer.getSize();

				renderer.setPixelRatio( 1 );
				renderer.setSize( eyeWidth * 2, eyeHeight, false );

			}

		} else if ( wasPresenting ) {

			renderer.setPixelRatio( rendererPixelRatio );
			renderer.setSize( rendererSize.width, rendererSize.height, rendererUpdateStyle );

		}

	}

	window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );

	this.setFullScreen = function( boolean ) {

		return new Promise( function( resolve, reject ) {

			if ( vrDisplay === undefined ) {

				reject( new Error( 'No VR hardware found.' ) );
				return;

			}

			if ( scope.isPresenting === boolean ) {

				resolve();
				return;

			}

			if ( boolean ) {

				resolve( vrDisplay.requestPresent( [ { source: canvas } ] ) );

			} else {

				resolve( vrDisplay.exitPresent() );

			}

		} );

	};

	this.requestPresent = function() {

		return this.setFullScreen( true );

	};

	this.exitPresent = function() {

		return this.setFullScreen( false );

	};

	this.requestAnimationFrame = function( f ) {

		if ( vrDisplay !== undefined ) {

			return vrDisplay.requestAnimationFrame( f );

		} else {

			return window.requestAnimationFrame( f );

		}

	};

	this.cancelAnimationFrame = function( h ) {

		if ( vrDisplay !== undefined ) {

			vrDisplay.cancelAnimationFrame( h );

		} else {

			window.cancelAnimationFrame( h );

		}

	};

	this.submitFrame = function() {

		if ( vrDisplay !== undefined && scope.isPresenting ) {

			vrDisplay.submitFrame();

		}

	};

	this.autoSubmitFrame = true;

	// render

	var cameraL = new THREE.PerspectiveCamera();
	cameraL.layers.enable( 1 );

	var cameraR = new THREE.PerspectiveCamera();
	cameraR.layers.enable( 2 );

	this.render = function( scene, camera, renderTarget, forceClear ) {

		if ( vrDisplay && scope.isPresenting ) {

			var autoUpdate = scene.autoUpdate;

			if ( autoUpdate ) {

				scene.updateMatrixWorld();
				scene.autoUpdate = false;

			}

			var eyeParamsL = vrDisplay.getEyeParameters( 'left' );
			var eyeParamsR = vrDisplay.getEyeParameters( 'right' );

			eyeTranslationL.fromArray( eyeParamsL.offset );
			eyeTranslationR.fromArray( eyeParamsR.offset );

			if ( Array.isArray( scene ) ) {

				console.warn( 'THREE.VREffect.render() no longer supports arrays. Use object.layers instead.' );
				scene = scene[ 0 ];

			}

			// When rendering we don't care what the recommended size is, only what the actual size
			// of the backbuffer is.
			var size = renderer.getSize();
			var layers = vrDisplay.getLayers();
			var leftBounds;
			var rightBounds;

			if ( layers.length ) {

				var layer = layers[ 0 ];

				leftBounds = layer.leftBounds !== null && layer.leftBounds.length === 4 ? layer.leftBounds : defaultLeftBounds;
				rightBounds = layer.rightBounds !== null && layer.rightBounds.length === 4 ? layer.rightBounds : defaultRightBounds;

			} else {

				leftBounds = defaultLeftBounds;
				rightBounds = defaultRightBounds;

			}

			renderRectL = {
				x: Math.round( size.width * leftBounds[ 0 ] ),
				y: Math.round( size.height * leftBounds[ 1 ] ),
				width: Math.round( size.width * leftBounds[ 2 ] ),
				height: Math.round( size.height * leftBounds[ 3 ] )
			};
			renderRectR = {
				x: Math.round( size.width * rightBounds[ 0 ] ),
				y: Math.round( size.height * rightBounds[ 1 ] ),
				width: Math.round( size.width * rightBounds[ 2 ] ),
				height: Math.round( size.height * rightBounds[ 3 ] )
			};

			if ( renderTarget ) {

				renderer.setRenderTarget( renderTarget );
				renderTarget.scissorTest = true;

			} else {

				renderer.setRenderTarget( null );
				renderer.setScissorTest( true );

			}

			if ( renderer.autoClear || forceClear ) renderer.clear();

			if ( camera.parent === null ) camera.updateMatrixWorld();

			camera.matrixWorld.decompose( cameraL.position, cameraL.quaternion, cameraL.scale );
			camera.matrixWorld.decompose( cameraR.position, cameraR.quaternion, cameraR.scale );

			var scale = this.scale;
			cameraL.translateOnAxis( eyeTranslationL, scale );
			cameraR.translateOnAxis( eyeTranslationR, scale );

			if ( vrDisplay.getFrameData ) {

				vrDisplay.depthNear = camera.near;
				vrDisplay.depthFar = camera.far;

				vrDisplay.getFrameData( frameData );

				cameraL.projectionMatrix.elements = frameData.leftProjectionMatrix;
				cameraR.projectionMatrix.elements = frameData.rightProjectionMatrix;

			} else {

				cameraL.projectionMatrix = fovToProjection( eyeParamsL.fieldOfView, true, camera.near, camera.far );
				cameraR.projectionMatrix = fovToProjection( eyeParamsR.fieldOfView, true, camera.near, camera.far );

			}

			// render left eye
			if ( renderTarget ) {

				renderTarget.viewport.set( renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height );
				renderTarget.scissor.set( renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height );

			} else {

				renderer.setViewport( renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height );
				renderer.setScissor( renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height );

			}
			renderer.render( scene, cameraL, renderTarget, forceClear );

			// render right eye
			if ( renderTarget ) {

				renderTarget.viewport.set( renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height );
				renderTarget.scissor.set( renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height );

			} else {

				renderer.setViewport( renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height );
				renderer.setScissor( renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height );

			}
			renderer.render( scene, cameraR, renderTarget, forceClear );

			if ( renderTarget ) {

				renderTarget.viewport.set( 0, 0, size.width, size.height );
				renderTarget.scissor.set( 0, 0, size.width, size.height );
				renderTarget.scissorTest = false;
				renderer.setRenderTarget( null );

			} else {

				renderer.setViewport( 0, 0, size.width, size.height );
				renderer.setScissorTest( false );

			}

			if ( autoUpdate ) {

				scene.autoUpdate = true;

			}

			if ( scope.autoSubmitFrame ) {

				scope.submitFrame();

			}

			return;

		}

		// Regular render mode if not HMD

		renderer.render( scene, camera, renderTarget, forceClear );

	};

	this.dispose = function() {

		window.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );

	};

	//

	function fovToNDCScaleOffset( fov ) {

		var pxscale = 2.0 / ( fov.leftTan + fov.rightTan );
		var pxoffset = ( fov.leftTan - fov.rightTan ) * pxscale * 0.5;
		var pyscale = 2.0 / ( fov.upTan + fov.downTan );
		var pyoffset = ( fov.upTan - fov.downTan ) * pyscale * 0.5;
		return { scale: [ pxscale, pyscale ], offset: [ pxoffset, pyoffset ] };

	}

	function fovPortToProjection( fov, rightHanded, zNear, zFar ) {

		rightHanded = rightHanded === undefined ? true : rightHanded;
		zNear = zNear === undefined ? 0.01 : zNear;
		zFar = zFar === undefined ? 10000.0 : zFar;

		var handednessScale = rightHanded ? - 1.0 : 1.0;

		// start with an identity matrix
		var mobj = new THREE.Matrix4();
		var m = mobj.elements;

		// and with scale/offset info for normalized device coords
		var scaleAndOffset = fovToNDCScaleOffset( fov );

		// X result, map clip edges to [-w,+w]
		m[ 0 * 4 + 0 ] = scaleAndOffset.scale[ 0 ];
		m[ 0 * 4 + 1 ] = 0.0;
		m[ 0 * 4 + 2 ] = scaleAndOffset.offset[ 0 ] * handednessScale;
		m[ 0 * 4 + 3 ] = 0.0;

		// Y result, map clip edges to [-w,+w]
		// Y offset is negated because this proj matrix transforms from world coords with Y=up,
		// but the NDC scaling has Y=down (thanks D3D?)
		m[ 1 * 4 + 0 ] = 0.0;
		m[ 1 * 4 + 1 ] = scaleAndOffset.scale[ 1 ];
		m[ 1 * 4 + 2 ] = - scaleAndOffset.offset[ 1 ] * handednessScale;
		m[ 1 * 4 + 3 ] = 0.0;

		// Z result (up to the app)
		m[ 2 * 4 + 0 ] = 0.0;
		m[ 2 * 4 + 1 ] = 0.0;
		m[ 2 * 4 + 2 ] = zFar / ( zNear - zFar ) * - handednessScale;
		m[ 2 * 4 + 3 ] = ( zFar * zNear ) / ( zNear - zFar );

		// W result (= Z in)
		m[ 3 * 4 + 0 ] = 0.0;
		m[ 3 * 4 + 1 ] = 0.0;
		m[ 3 * 4 + 2 ] = handednessScale;
		m[ 3 * 4 + 3 ] = 0.0;

		mobj.transpose();

		return mobj;

	}

	function fovToProjection( fov, rightHanded, zNear, zFar ) {

		var DEG2RAD = Math.PI / 180.0;

		var fovPort = {
			upTan: Math.tan( fov.upDegrees * DEG2RAD ),
			downTan: Math.tan( fov.downDegrees * DEG2RAD ),
			leftTan: Math.tan( fov.leftDegrees * DEG2RAD ),
			rightTan: Math.tan( fov.rightDegrees * DEG2RAD )
		};

		return fovPortToProjection( fovPort, rightHanded, zNear, zFar );

	}

};

},{}],3:[function(require,module,exports){
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.OBJLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	this.materials = null;

	this.regexp = {
		// v float float float
		vertex_pattern           : /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
		// vn float float float
		normal_pattern           : /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
		// vt float float
		uv_pattern               : /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
		// f vertex vertex vertex
		face_vertex              : /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
		// f vertex/uv vertex/uv vertex/uv
		face_vertex_uv           : /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
		// f vertex/uv/normal vertex/uv/normal vertex/uv/normal
		face_vertex_uv_normal    : /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
		// f vertex//normal vertex//normal vertex//normal
		face_vertex_normal       : /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
		// o object_name | g group_name
		object_pattern           : /^[og]\s*(.+)?/,
		// s boolean
		smoothing_pattern        : /^s\s+(\d+|on|off)/,
		// mtllib file_reference
		material_library_pattern : /^mtllib /,
		// usemtl material_name
		material_use_pattern     : /^usemtl /
	};

};

THREE.OBJLoader.prototype = {

	constructor: THREE.OBJLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.FileLoader( scope.manager );
		loader.setPath( this.path );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( text ) );

		}, onProgress, onError );

	},

	setPath: function ( value ) {

		this.path = value;

	},

	setMaterials: function ( materials ) {

		this.materials = materials;

	},

	_createParserState : function () {

		var state = {
			objects  : [],
			object   : {},

			vertices : [],
			normals  : [],
			uvs      : [],

			materialLibraries : [],

			startObject: function ( name, fromDeclaration ) {

				// If the current object (initial from reset) is not from a g/o declaration in the parsed
				// file. We need to use it for the first parsed g/o to keep things in sync.
				if ( this.object && this.object.fromDeclaration === false ) {

					this.object.name = name;
					this.object.fromDeclaration = ( fromDeclaration !== false );
					return;

				}

				var previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );

				if ( this.object && typeof this.object._finalize === 'function' ) {

					this.object._finalize( true );

				}

				this.object = {
					name : name || '',
					fromDeclaration : ( fromDeclaration !== false ),

					geometry : {
						vertices : [],
						normals  : [],
						uvs      : []
					},
					materials : [],
					smooth : true,

					startMaterial : function( name, libraries ) {

						var previous = this._finalize( false );

						// New usemtl declaration overwrites an inherited material, except if faces were declared
						// after the material, then it must be preserved for proper MultiMaterial continuation.
						if ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {

							this.materials.splice( previous.index, 1 );

						}

						var material = {
							index      : this.materials.length,
							name       : name || '',
							mtllib     : ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),
							smooth     : ( previous !== undefined ? previous.smooth : this.smooth ),
							groupStart : ( previous !== undefined ? previous.groupEnd : 0 ),
							groupEnd   : -1,
							groupCount : -1,
							inherited  : false,

							clone : function( index ) {
								var cloned = {
									index      : ( typeof index === 'number' ? index : this.index ),
									name       : this.name,
									mtllib     : this.mtllib,
									smooth     : this.smooth,
									groupStart : 0,
									groupEnd   : -1,
									groupCount : -1,
									inherited  : false
								};
								cloned.clone = this.clone.bind(cloned);
								return cloned;
							}
						};

						this.materials.push( material );

						return material;

					},

					currentMaterial : function() {

						if ( this.materials.length > 0 ) {
							return this.materials[ this.materials.length - 1 ];
						}

						return undefined;

					},

					_finalize : function( end ) {

						var lastMultiMaterial = this.currentMaterial();
						if ( lastMultiMaterial && lastMultiMaterial.groupEnd === -1 ) {

							lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
							lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
							lastMultiMaterial.inherited = false;

						}

						// Ignore objects tail materials if no face declarations followed them before a new o/g started.
						if ( end && this.materials.length > 1 ) {

							for ( var mi = this.materials.length - 1; mi >= 0; mi-- ) {
								if ( this.materials[mi].groupCount <= 0 ) {
									this.materials.splice( mi, 1 );
								}
							}

						}

						// Guarantee at least one empty material, this makes the creation later more straight forward.
						if ( end && this.materials.length === 0 ) {

							this.materials.push({
								name   : '',
								smooth : this.smooth
							});

						}

						return lastMultiMaterial;

					}
				};

				// Inherit previous objects material.
				// Spec tells us that a declared material must be set to all objects until a new material is declared.
				// If a usemtl declaration is encountered while this new object is being parsed, it will
				// overwrite the inherited material. Exception being that there was already face declarations
				// to the inherited material, then it will be preserved for proper MultiMaterial continuation.

				if ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function" ) {

					var declared = previousMaterial.clone( 0 );
					declared.inherited = true;
					this.object.materials.push( declared );

				}

				this.objects.push( this.object );

			},

			finalize : function() {

				if ( this.object && typeof this.object._finalize === 'function' ) {

					this.object._finalize( true );

				}

			},

			parseVertexIndex: function ( value, len ) {

				var index = parseInt( value, 10 );
				return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

			},

			parseNormalIndex: function ( value, len ) {

				var index = parseInt( value, 10 );
				return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;

			},

			parseUVIndex: function ( value, len ) {

				var index = parseInt( value, 10 );
				return ( index >= 0 ? index - 1 : index + len / 2 ) * 2;

			},

			addVertex: function ( a, b, c ) {

				var src = this.vertices;
				var dst = this.object.geometry.vertices;

				dst.push( src[ a + 0 ] );
				dst.push( src[ a + 1 ] );
				dst.push( src[ a + 2 ] );
				dst.push( src[ b + 0 ] );
				dst.push( src[ b + 1 ] );
				dst.push( src[ b + 2 ] );
				dst.push( src[ c + 0 ] );
				dst.push( src[ c + 1 ] );
				dst.push( src[ c + 2 ] );

			},

			addVertexLine: function ( a ) {

				var src = this.vertices;
				var dst = this.object.geometry.vertices;

				dst.push( src[ a + 0 ] );
				dst.push( src[ a + 1 ] );
				dst.push( src[ a + 2 ] );

			},

			addNormal : function ( a, b, c ) {

				var src = this.normals;
				var dst = this.object.geometry.normals;

				dst.push( src[ a + 0 ] );
				dst.push( src[ a + 1 ] );
				dst.push( src[ a + 2 ] );
				dst.push( src[ b + 0 ] );
				dst.push( src[ b + 1 ] );
				dst.push( src[ b + 2 ] );
				dst.push( src[ c + 0 ] );
				dst.push( src[ c + 1 ] );
				dst.push( src[ c + 2 ] );

			},

			addUV: function ( a, b, c ) {

				var src = this.uvs;
				var dst = this.object.geometry.uvs;

				dst.push( src[ a + 0 ] );
				dst.push( src[ a + 1 ] );
				dst.push( src[ b + 0 ] );
				dst.push( src[ b + 1 ] );
				dst.push( src[ c + 0 ] );
				dst.push( src[ c + 1 ] );

			},

			addUVLine: function ( a ) {

				var src = this.uvs;
				var dst = this.object.geometry.uvs;

				dst.push( src[ a + 0 ] );
				dst.push( src[ a + 1 ] );

			},

			addFace: function ( a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd ) {

				var vLen = this.vertices.length;

				var ia = this.parseVertexIndex( a, vLen );
				var ib = this.parseVertexIndex( b, vLen );
				var ic = this.parseVertexIndex( c, vLen );
				var id;

				if ( d === undefined ) {

					this.addVertex( ia, ib, ic );

				} else {

					id = this.parseVertexIndex( d, vLen );

					this.addVertex( ia, ib, id );
					this.addVertex( ib, ic, id );

				}

				if ( ua !== undefined ) {

					var uvLen = this.uvs.length;

					ia = this.parseUVIndex( ua, uvLen );
					ib = this.parseUVIndex( ub, uvLen );
					ic = this.parseUVIndex( uc, uvLen );

					if ( d === undefined ) {

						this.addUV( ia, ib, ic );

					} else {

						id = this.parseUVIndex( ud, uvLen );

						this.addUV( ia, ib, id );
						this.addUV( ib, ic, id );

					}

				}

				if ( na !== undefined ) {

					// Normals are many times the same. If so, skip function call and parseInt.
					var nLen = this.normals.length;
					ia = this.parseNormalIndex( na, nLen );

					ib = na === nb ? ia : this.parseNormalIndex( nb, nLen );
					ic = na === nc ? ia : this.parseNormalIndex( nc, nLen );

					if ( d === undefined ) {

						this.addNormal( ia, ib, ic );

					} else {

						id = this.parseNormalIndex( nd, nLen );

						this.addNormal( ia, ib, id );
						this.addNormal( ib, ic, id );

					}

				}

			},

			addLineGeometry: function ( vertices, uvs ) {

				this.object.geometry.type = 'Line';

				var vLen = this.vertices.length;
				var uvLen = this.uvs.length;

				for ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {

					this.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );

				}

				for ( var uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {

					this.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );

				}

			}

		};

		state.startObject( '', false );

		return state;

	},

	parse: function ( text ) {

		console.time( 'OBJLoader' );

		var state = this._createParserState();

		if ( text.indexOf( '\r\n' ) !== - 1 ) {

			// This is faster than String.split with regex that splits on both
			text = text.replace( /\r\n/g, '\n' );

		}

		if ( text.indexOf( '\\\n' ) !== - 1) {

			// join lines separated by a line continuation character (\)
			text = text.replace( /\\\n/g, '' );

		}

		var lines = text.split( '\n' );
		var line = '', lineFirstChar = '', lineSecondChar = '';
		var lineLength = 0;
		var result = [];

		// Faster to just trim left side of the line. Use if available.
		var trimLeft = ( typeof ''.trimLeft === 'function' );

		for ( var i = 0, l = lines.length; i < l; i ++ ) {

			line = lines[ i ];

			line = trimLeft ? line.trimLeft() : line.trim();

			lineLength = line.length;

			if ( lineLength === 0 ) continue;

			lineFirstChar = line.charAt( 0 );

			// @todo invoke passed in handler if any
			if ( lineFirstChar === '#' ) continue;

			if ( lineFirstChar === 'v' ) {

				lineSecondChar = line.charAt( 1 );

				if ( lineSecondChar === ' ' && ( result = this.regexp.vertex_pattern.exec( line ) ) !== null ) {

					// 0                  1      2      3
					// ["v 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

					state.vertices.push(
						parseFloat( result[ 1 ] ),
						parseFloat( result[ 2 ] ),
						parseFloat( result[ 3 ] )
					);

				} else if ( lineSecondChar === 'n' && ( result = this.regexp.normal_pattern.exec( line ) ) !== null ) {

					// 0                   1      2      3
					// ["vn 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

					state.normals.push(
						parseFloat( result[ 1 ] ),
						parseFloat( result[ 2 ] ),
						parseFloat( result[ 3 ] )
					);

				} else if ( lineSecondChar === 't' && ( result = this.regexp.uv_pattern.exec( line ) ) !== null ) {

					// 0               1      2
					// ["vt 0.1 0.2", "0.1", "0.2"]

					state.uvs.push(
						parseFloat( result[ 1 ] ),
						parseFloat( result[ 2 ] )
					);

				} else {

					throw new Error( "Unexpected vertex/normal/uv line: '" + line  + "'" );

				}

			} else if ( lineFirstChar === "f" ) {

				if ( ( result = this.regexp.face_vertex_uv_normal.exec( line ) ) !== null ) {

					// f vertex/uv/normal vertex/uv/normal vertex/uv/normal
					// 0                        1    2    3    4    5    6    7    8    9   10         11         12
					// ["f 1/1/1 2/2/2 3/3/3", "1", "1", "1", "2", "2", "2", "3", "3", "3", undefined, undefined, undefined]

					state.addFace(
						result[ 1 ], result[ 4 ], result[ 7 ], result[ 10 ],
						result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ],
						result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ]
					);

				} else if ( ( result = this.regexp.face_vertex_uv.exec( line ) ) !== null ) {

					// f vertex/uv vertex/uv vertex/uv
					// 0                  1    2    3    4    5    6   7          8
					// ["f 1/1 2/2 3/3", "1", "1", "2", "2", "3", "3", undefined, undefined]

					state.addFace(
						result[ 1 ], result[ 3 ], result[ 5 ], result[ 7 ],
						result[ 2 ], result[ 4 ], result[ 6 ], result[ 8 ]
					);

				} else if ( ( result = this.regexp.face_vertex_normal.exec( line ) ) !== null ) {

					// f vertex//normal vertex//normal vertex//normal
					// 0                     1    2    3    4    5    6   7          8
					// ["f 1//1 2//2 3//3", "1", "1", "2", "2", "3", "3", undefined, undefined]

					state.addFace(
						result[ 1 ], result[ 3 ], result[ 5 ], result[ 7 ],
						undefined, undefined, undefined, undefined,
						result[ 2 ], result[ 4 ], result[ 6 ], result[ 8 ]
					);

				} else if ( ( result = this.regexp.face_vertex.exec( line ) ) !== null ) {

					// f vertex vertex vertex
					// 0            1    2    3   4
					// ["f 1 2 3", "1", "2", "3", undefined]

					state.addFace(
						result[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ]
					);

				} else {

					throw new Error( "Unexpected face line: '" + line  + "'" );

				}

			} else if ( lineFirstChar === "l" ) {

				var lineParts = line.substring( 1 ).trim().split( " " );
				var lineVertices = [], lineUVs = [];

				if ( line.indexOf( "/" ) === - 1 ) {

					lineVertices = lineParts;

				} else {

					for ( var li = 0, llen = lineParts.length; li < llen; li ++ ) {

						var parts = lineParts[ li ].split( "/" );

						if ( parts[ 0 ] !== "" ) lineVertices.push( parts[ 0 ] );
						if ( parts[ 1 ] !== "" ) lineUVs.push( parts[ 1 ] );

					}

				}
				state.addLineGeometry( lineVertices, lineUVs );

			} else if ( ( result = this.regexp.object_pattern.exec( line ) ) !== null ) {

				// o object_name
				// or
				// g group_name

				// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
				// var name = result[ 0 ].substr( 1 ).trim();
				var name = ( " " + result[ 0 ].substr( 1 ).trim() ).substr( 1 );

				state.startObject( name );

			} else if ( this.regexp.material_use_pattern.test( line ) ) {

				// material

				state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );

			} else if ( this.regexp.material_library_pattern.test( line ) ) {

				// mtl file

				state.materialLibraries.push( line.substring( 7 ).trim() );

			} else if ( ( result = this.regexp.smoothing_pattern.exec( line ) ) !== null ) {

				// smooth shading

				// @todo Handle files that have varying smooth values for a set of faces inside one geometry,
				// but does not define a usemtl for each face set.
				// This should be detected and a dummy material created (later MultiMaterial and geometry groups).
				// This requires some care to not create extra material on each smooth value for "normal" obj files.
				// where explicit usemtl defines geometry groups.
				// Example asset: examples/models/obj/cerberus/Cerberus.obj

				var value = result[ 1 ].trim().toLowerCase();
				state.object.smooth = ( value === '1' || value === 'on' );

				var material = state.object.currentMaterial();
				if ( material ) {

					material.smooth = state.object.smooth;

				}

			} else {

				// Handle null terminated files without exception
				if ( line === '\0' ) continue;

				throw new Error( "Unexpected line: '" + line  + "'" );

			}

		}

		state.finalize();

		var container = new THREE.Group();
		container.materialLibraries = [].concat( state.materialLibraries );

		for ( var i = 0, l = state.objects.length; i < l; i ++ ) {

			var object = state.objects[ i ];
			var geometry = object.geometry;
			var materials = object.materials;
			var isLine = ( geometry.type === 'Line' );

			// Skip o/g line declarations that did not follow with any faces
			if ( geometry.vertices.length === 0 ) continue;

			var buffergeometry = new THREE.BufferGeometry();

			buffergeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) );

			if ( geometry.normals.length > 0 ) {

				buffergeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) );

			} else {

				buffergeometry.computeVertexNormals();

			}

			if ( geometry.uvs.length > 0 ) {

				buffergeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) );

			}

			// Create materials

			var createdMaterials = [];

			for ( var mi = 0, miLen = materials.length; mi < miLen ; mi++ ) {

				var sourceMaterial = materials[mi];
				var material = undefined;

				if ( this.materials !== null ) {

					material = this.materials.create( sourceMaterial.name );

					// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
					if ( isLine && material && ! ( material instanceof THREE.LineBasicMaterial ) ) {

						var materialLine = new THREE.LineBasicMaterial();
						materialLine.copy( material );
						material = materialLine;

					}

				}

				if ( ! material ) {

					material = ( ! isLine ? new THREE.MeshPhongMaterial() : new THREE.LineBasicMaterial() );
					material.name = sourceMaterial.name;

				}

				material.shading = sourceMaterial.smooth ? THREE.SmoothShading : THREE.FlatShading;

				createdMaterials.push(material);

			}

			// Create mesh

			var mesh;

			if ( createdMaterials.length > 1 ) {

				for ( var mi = 0, miLen = materials.length; mi < miLen ; mi++ ) {

					var sourceMaterial = materials[mi];
					buffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );

				}

				var multiMaterial = new THREE.MultiMaterial( createdMaterials );
				mesh = ( ! isLine ? new THREE.Mesh( buffergeometry, multiMaterial ) : new THREE.LineSegments( buffergeometry, multiMaterial ) );

			} else {

				mesh = ( ! isLine ? new THREE.Mesh( buffergeometry, createdMaterials[ 0 ] ) : new THREE.LineSegments( buffergeometry, createdMaterials[ 0 ] ) );
			}

			mesh.name = object.name;

			container.add( mesh );

		}

		console.timeEnd( 'OBJLoader' );

		return container;

	}

};

},{}],4:[function(require,module,exports){
/**
 * @author mrdoob / http://mrdoob.com
 * @author stewdio / http://stewd.io
 */

THREE.ViveController = function ( id ) {

	THREE.Object3D.call( this );

	var scope = this;
	var gamepad;

	var axes = [ 0, 0 ];
	var thumbpadIsPressed = false;
	var triggerIsPressed = false;
	var gripsArePressed = false;
	var menuIsPressed = false;

	function findGamepad( id ) {

		// Iterate across gamepads as Vive Controllers may not be
		// in position 0 and 1.

		var gamepads = navigator.getGamepads();

		for ( var i = 0, j = 0; i < 4; i ++ ) {

			var gamepad = gamepads[ i ];

			if ( gamepad && gamepad.id === 'OpenVR Gamepad' ) {

				if ( j === id ) return gamepad;

				j ++;

			}

		}

	}

	this.matrixAutoUpdate = false;
	this.standingMatrix = new THREE.Matrix4();

	this.getGamepad = function () {

		return gamepad;

	};

	this.getButtonState = function ( button ) {

		if ( button === 'thumbpad' ) return thumbpadIsPressed;
		if ( button === 'trigger' ) return triggerIsPressed;
		if ( button === 'grips' ) return gripsArePressed;
		if ( button === 'menu' ) return menuIsPressed;

	};

	this.update = function () {

		gamepad = findGamepad( id );

		if ( gamepad !== undefined && gamepad.pose !== undefined ) {

			if ( gamepad.pose === null ) return; // No user action yet

			//  Position and orientation.

			var pose = gamepad.pose;

			if ( pose.position !== null ) scope.position.fromArray( pose.position );
			if ( pose.orientation !== null ) scope.quaternion.fromArray( pose.orientation );
			scope.matrix.compose( scope.position, scope.quaternion, scope.scale );
			scope.matrix.multiplyMatrices( scope.standingMatrix, scope.matrix );
			scope.matrixWorldNeedsUpdate = true;
			scope.visible = true;

			//  Thumbpad and Buttons.

			if ( axes[ 0 ] !== gamepad.axes[ 0 ] || axes[ 1 ] !== gamepad.axes[ 1 ] ) {

				axes[ 0 ] = gamepad.axes[ 0 ]; //  X axis: -1 = Left, +1 = Right.
				axes[ 1 ] = gamepad.axes[ 1 ]; //  Y axis: -1 = Bottom, +1 = Top.
				scope.dispatchEvent( { type: 'axischanged', axes: axes } );

			}

			if ( thumbpadIsPressed !== gamepad.buttons[ 0 ].pressed ) {

				thumbpadIsPressed = gamepad.buttons[ 0 ].pressed;
				scope.dispatchEvent( { type: thumbpadIsPressed ? 'thumbpaddown' : 'thumbpadup' } );

			}

			if ( triggerIsPressed !== gamepad.buttons[ 1 ].pressed ) {

				triggerIsPressed = gamepad.buttons[ 1 ].pressed;
				scope.dispatchEvent( { type: triggerIsPressed ? 'triggerdown' : 'triggerup' } );

			}

			if ( gripsArePressed !== gamepad.buttons[ 2 ].pressed ) {

				gripsArePressed = gamepad.buttons[ 2 ].pressed;
				scope.dispatchEvent( { type: gripsArePressed ? 'gripsdown' : 'gripsup' } );

			}

			if ( menuIsPressed !== gamepad.buttons[ 3 ].pressed ) {

				menuIsPressed = gamepad.buttons[ 3 ].pressed;
				scope.dispatchEvent( { type: menuIsPressed ? 'menudown' : 'menuup' } );

			}

		} else {

			scope.visible = false;

		}

	};

};

THREE.ViveController.prototype = Object.create( THREE.Object3D.prototype );
THREE.ViveController.prototype.constructor = THREE.ViveController;

},{}],5:[function(require,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.WebVRManager = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Emitter = _dereq_('./emitter.js');
var Modes = _dereq_('./modes.js');
var Util = _dereq_('./util.js');

/**
 * Everything having to do with the WebVR button.
 * Emits a 'click' event when it's clicked.
 */
function ButtonManager(opt_root) {
  var root = opt_root || document.body;
  this.loadIcons_();

  // Make the fullscreen button.
  var fsButton = this.createButton();
  fsButton.src = this.ICONS.fullscreen;
  fsButton.title = 'Fullscreen mode';
  var s = fsButton.style;
  s.bottom = 0;
  s.right = 0;
  fsButton.addEventListener('click', this.createClickHandler_('fs'));
  root.appendChild(fsButton);
  this.fsButton = fsButton;

  // Make the VR button.
  var vrButton = this.createButton();
  vrButton.src = this.ICONS.cardboard;
  vrButton.title = 'Virtual reality mode';
  var s = vrButton.style;
  s.bottom = 0;
  s.right = '48px';
  vrButton.addEventListener('click', this.createClickHandler_('vr'));
  root.appendChild(vrButton);
  this.vrButton = vrButton;

  this.isVisible = true;

}
ButtonManager.prototype = new Emitter();

ButtonManager.prototype.createButton = function() {
  var button = document.createElement('img');
  button.className = 'webvr-button';
  var s = button.style;
  s.position = 'absolute';
  s.width = '24px'
  s.height = '24px';
  s.backgroundSize = 'cover';
  s.backgroundColor = 'transparent';
  s.border = 0;
  s.userSelect = 'none';
  s.webkitUserSelect = 'none';
  s.MozUserSelect = 'none';
  s.cursor = 'pointer';
  s.padding = '12px';
  s.zIndex = 1;
  s.display = 'none';
  s.boxSizing = 'content-box';

  // Prevent button from being selected and dragged.
  button.draggable = false;
  button.addEventListener('dragstart', function(e) {
    e.preventDefault();
  });

  // Style it on hover.
  button.addEventListener('mouseenter', function(e) {
    s.filter = s.webkitFilter = 'drop-shadow(0 0 5px rgba(255,255,255,1))';
  });
  button.addEventListener('mouseleave', function(e) {
    s.filter = s.webkitFilter = '';
  });
  return button;
};

ButtonManager.prototype.setMode = function(mode, isVRCompatible) {
  isVRCompatible = isVRCompatible || WebVRConfig.FORCE_ENABLE_VR;
  if (!this.isVisible) {
    return;
  }
  switch (mode) {
    case Modes.NORMAL:
      this.fsButton.style.display = 'block';
      this.fsButton.src = this.ICONS.fullscreen;
      this.vrButton.style.display = (isVRCompatible ? 'block' : 'none');
      break;
    case Modes.MAGIC_WINDOW:
      this.fsButton.style.display = 'block';
      this.fsButton.src = this.ICONS.exitFullscreen;
      this.vrButton.style.display = 'none';
      break;
    case Modes.VR:
      this.fsButton.style.display = 'none';
      this.vrButton.style.display = 'none';
      break;
  }

  // Hack for Safari Mac/iOS to force relayout (svg-specific issue)
  // http://goo.gl/hjgR6r
  var oldValue = this.fsButton.style.display;
  this.fsButton.style.display = 'inline-block';
  this.fsButton.offsetHeight;
  this.fsButton.style.display = oldValue;
};

ButtonManager.prototype.setVisibility = function(isVisible) {
  this.isVisible = isVisible;
  this.fsButton.style.display = isVisible ? 'block' : 'none';
  this.vrButton.style.display = isVisible ? 'block' : 'none';
};

ButtonManager.prototype.createClickHandler_ = function(eventName) {
  return function(e) {
    e.stopPropagation();
    e.preventDefault();
    this.emit(eventName);
  }.bind(this);
};

ButtonManager.prototype.loadIcons_ = function() {
  // Preload some hard-coded SVG.
  this.ICONS = {};
  this.ICONS.cardboard = Util.base64('image/svg+xml', 'PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNHB4IiBoZWlnaHQ9IjI0cHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iI0ZGRkZGRiI+CiAgICA8cGF0aCBkPSJNMjAuNzQgNkgzLjIxQzIuNTUgNiAyIDYuNTcgMiA3LjI4djEwLjQ0YzAgLjcuNTUgMS4yOCAxLjIzIDEuMjhoNC43OWMuNTIgMCAuOTYtLjMzIDEuMTQtLjc5bDEuNC0zLjQ4Yy4yMy0uNTkuNzktMS4wMSAxLjQ0LTEuMDFzMS4yMS40MiAxLjQ1IDEuMDFsMS4zOSAzLjQ4Yy4xOS40Ni42My43OSAxLjExLjc5aDQuNzljLjcxIDAgMS4yNi0uNTcgMS4yNi0xLjI4VjcuMjhjMC0uNy0uNTUtMS4yOC0xLjI2LTEuMjh6TTcuNSAxNC42MmMtMS4xNyAwLTIuMTMtLjk1LTIuMTMtMi4xMiAwLTEuMTcuOTYtMi4xMyAyLjEzLTIuMTMgMS4xOCAwIDIuMTIuOTYgMi4xMiAyLjEzcy0uOTUgMi4xMi0yLjEyIDIuMTJ6bTkgMGMtMS4xNyAwLTIuMTMtLjk1LTIuMTMtMi4xMiAwLTEuMTcuOTYtMi4xMyAyLjEzLTIuMTNzMi4xMi45NiAyLjEyIDIuMTMtLjk1IDIuMTItMi4xMiAyLjEyeiIvPgogICAgPHBhdGggZmlsbD0ibm9uZSIgZD0iTTAgMGgyNHYyNEgwVjB6Ii8+Cjwvc3ZnPgo=');
  this.ICONS.fullscreen = Util.base64('image/svg+xml', 'PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNHB4IiBoZWlnaHQ9IjI0cHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iI0ZGRkZGRiI+CiAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+CiAgICA8cGF0aCBkPSJNNyAxNEg1djVoNXYtMkg3di0zem0tMi00aDJWN2gzVjVINXY1em0xMiA3aC0zdjJoNXYtNWgtMnYzek0xNCA1djJoM3YzaDJWNWgtNXoiLz4KPC9zdmc+Cg==');
  this.ICONS.exitFullscreen = Util.base64('image/svg+xml', 'PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNHB4IiBoZWlnaHQ9IjI0cHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iI0ZGRkZGRiI+CiAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+CiAgICA8cGF0aCBkPSJNNSAxNmgzdjNoMnYtNUg1djJ6bTMtOEg1djJoNVY1SDh2M3ptNiAxMWgydi0zaDN2LTJoLTV2NXptMi0xMVY1aC0ydjVoNVY4aC0zeiIvPgo8L3N2Zz4K');
  this.ICONS.settings = Util.base64('image/svg+xml', 'PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNHB4IiBoZWlnaHQ9IjI0cHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iI0ZGRkZGRiI+CiAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+CiAgICA8cGF0aCBkPSJNMTkuNDMgMTIuOThjLjA0LS4zMi4wNy0uNjQuMDctLjk4cy0uMDMtLjY2LS4wNy0uOThsMi4xMS0xLjY1Yy4xOS0uMTUuMjQtLjQyLjEyLS42NGwtMi0zLjQ2Yy0uMTItLjIyLS4zOS0uMy0uNjEtLjIybC0yLjQ5IDFjLS41Mi0uNC0xLjA4LS43My0xLjY5LS45OGwtLjM4LTIuNjVDMTQuNDYgMi4xOCAxNC4yNSAyIDE0IDJoLTRjLS4yNSAwLS40Ni4xOC0uNDkuNDJsLS4zOCAyLjY1Yy0uNjEuMjUtMS4xNy41OS0xLjY5Ljk4bC0yLjQ5LTFjLS4yMy0uMDktLjQ5IDAtLjYxLjIybC0yIDMuNDZjLS4xMy4yMi0uMDcuNDkuMTIuNjRsMi4xMSAxLjY1Yy0uMDQuMzItLjA3LjY1LS4wNy45OHMuMDMuNjYuMDcuOThsLTIuMTEgMS42NWMtLjE5LjE1LS4yNC40Mi0uMTIuNjRsMiAzLjQ2Yy4xMi4yMi4zOS4zLjYxLjIybDIuNDktMWMuNTIuNCAxLjA4LjczIDEuNjkuOThsLjM4IDIuNjVjLjAzLjI0LjI0LjQyLjQ5LjQyaDRjLjI1IDAgLjQ2LS4xOC40OS0uNDJsLjM4LTIuNjVjLjYxLS4yNSAxLjE3LS41OSAxLjY5LS45OGwyLjQ5IDFjLjIzLjA5LjQ5IDAgLjYxLS4yMmwyLTMuNDZjLjEyLS4yMi4wNy0uNDktLjEyLS42NGwtMi4xMS0xLjY1ek0xMiAxNS41Yy0xLjkzIDAtMy41LTEuNTctMy41LTMuNXMxLjU3LTMuNSAzLjUtMy41IDMuNSAxLjU3IDMuNSAzLjUtMS41NyAzLjUtMy41IDMuNXoiLz4KPC9zdmc+Cg==');
};

module.exports = ButtonManager;

},{"./emitter.js":2,"./modes.js":3,"./util.js":4}],2:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function Emitter() {
  this.callbacks = {};
}

Emitter.prototype.emit = function(eventName) {
  var callbacks = this.callbacks[eventName];
  if (!callbacks) {
    //console.log('No valid callback specified.');
    return;
  }
  var args = [].slice.call(arguments);
  // Eliminate the first param (the callback).
  args.shift();
  for (var i = 0; i < callbacks.length; i++) {
    callbacks[i].apply(this, args);
  }
};

Emitter.prototype.on = function(eventName, callback) {
  if (eventName in this.callbacks) {
    this.callbacks[eventName].push(callback);
  } else {
    this.callbacks[eventName] = [callback];
  }
};

module.exports = Emitter;

},{}],3:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Modes = {
  UNKNOWN: 0,
  // Not fullscreen, just tracking.
  NORMAL: 1,
  // Magic window immersive mode.
  MAGIC_WINDOW: 2,
  // Full screen split screen VR mode.
  VR: 3,
};

module.exports = Modes;

},{}],4:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Util = {};

Util.base64 = function(mimeType, base64) {
  return 'data:' + mimeType + ';base64,' + base64;
};

Util.isMobile = function() {
  var check = false;
  (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check = true})(navigator.userAgent||navigator.vendor||window.opera);
  return check;
};

Util.isFirefox = function() {
  return /firefox/i.test(navigator.userAgent);
};

Util.isIOS = function() {
  return /(iPad|iPhone|iPod)/g.test(navigator.userAgent);
};

Util.isIFrame = function() {
  try {
    return window.self !== window.top;
  } catch (e) {
    return true;
  }
};

Util.appendQueryParameter = function(url, key, value) {
  // Determine delimiter based on if the URL already GET parameters in it.
  var delimiter = (url.indexOf('?') < 0 ? '?' : '&');
  url += delimiter + key + '=' + value;
  return url;
};

// From http://goo.gl/4WX3tg
Util.getQueryParameter = function(name) {
  var name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
  var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
      results = regex.exec(location.search);
  return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
};

Util.isLandscapeMode = function() {
  return (window.orientation == 90 || window.orientation == -90);
};

Util.getScreenWidth = function() {
  return Math.max(window.screen.width, window.screen.height) *
      window.devicePixelRatio;
};

Util.getScreenHeight = function() {
  return Math.min(window.screen.width, window.screen.height) *
      window.devicePixelRatio;
};

module.exports = Util;

},{}],5:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var ButtonManager = _dereq_('./button-manager.js');
var Emitter = _dereq_('./emitter.js');
var Modes = _dereq_('./modes.js');
var Util = _dereq_('./util.js');

/**
 * Helper for getting in and out of VR mode.
 */
function WebVRManager(renderer, effect, params) {
  this.params = params || {};

  this.mode = Modes.UNKNOWN;

  // Set option to hide the button.
  this.hideButton = this.params.hideButton || false;
  // Whether or not the FOV should be distorted or un-distorted. By default, it
  // should be distorted, but in the case of vertex shader based distortion,
  // ensure that we use undistorted parameters.
  this.predistorted = !!this.params.predistorted;

  // Save the THREE.js renderer and effect for later.
  this.renderer = renderer;
  this.effect = effect;
  var polyfillWrapper = document.querySelector('.webvr-polyfill-fullscreen-wrapper');
  this.button = new ButtonManager(polyfillWrapper);

  this.isFullscreenDisabled = !!Util.getQueryParameter('no_fullscreen');
  this.startMode = Modes.NORMAL;
  var startModeParam = parseInt(Util.getQueryParameter('start_mode'));
  if (!isNaN(startModeParam)) {
    this.startMode = startModeParam;
  }

  if (this.hideButton) {
    this.button.setVisibility(false);
  }

  // Check if the browser is compatible with WebVR.
  this.getDeviceByType_(VRDisplay).then(function(hmd) {
    this.hmd = hmd;

    // Only enable VR mode if there's a VR device attached or we are running the
    // polyfill on mobile.
    if (!this.isVRCompatibleOverride) {
      this.isVRCompatible =  !hmd.isPolyfilled || Util.isMobile();
    }

    switch (this.startMode) {
      case Modes.MAGIC_WINDOW:
        this.setMode_(Modes.MAGIC_WINDOW);
        break;
      case Modes.VR:
        this.enterVRMode_();
        this.setMode_(Modes.VR);
        break;
      default:
        this.setMode_(Modes.NORMAL);
    }

    this.emit('initialized');
  }.bind(this));

  // Hook up button listeners.
  this.button.on('fs', this.onFSClick_.bind(this));
  this.button.on('vr', this.onVRClick_.bind(this));

  // Bind to fullscreen events.
  document.addEventListener('webkitfullscreenchange',
      this.onFullscreenChange_.bind(this));
  document.addEventListener('mozfullscreenchange',
      this.onFullscreenChange_.bind(this));
  document.addEventListener('msfullscreenchange',
      this.onFullscreenChange_.bind(this));

  // Bind to VR* specific events.
  window.addEventListener('vrdisplaypresentchange',
      this.onVRDisplayPresentChange_.bind(this));
  window.addEventListener('vrdisplaydeviceparamschange',
      this.onVRDisplayDeviceParamsChange_.bind(this));
}

WebVRManager.prototype = new Emitter();

// Expose these values externally.
WebVRManager.Modes = Modes;

WebVRManager.prototype.render = function(scene, camera, timestamp) {
  // Scene may be an array of two scenes, one for each eye.
  if (scene instanceof Array) {
    this.effect.render(scene[0], camera);
  } else {
    this.effect.render(scene, camera);
  }
};

WebVRManager.prototype.setVRCompatibleOverride = function(isVRCompatible) {
  this.isVRCompatible = isVRCompatible;
  this.isVRCompatibleOverride = true;

  // Don't actually change modes, just update the buttons.
  this.button.setMode(this.mode, this.isVRCompatible);
};

WebVRManager.prototype.setFullscreenCallback = function(callback) {
  this.fullscreenCallback = callback;
};

WebVRManager.prototype.setVRCallback = function(callback) {
  this.vrCallback = callback;
};

WebVRManager.prototype.setExitFullscreenCallback = function(callback) {
  this.exitFullscreenCallback = callback;
}

/**
 * Promise returns true if there is at least one HMD device available.
 */
WebVRManager.prototype.getDeviceByType_ = function(type) {
  return new Promise(function(resolve, reject) {
    navigator.getVRDisplays().then(function(displays) {
      // Promise succeeds, but check if there are any displays actually.
      for (var i = 0; i < displays.length; i++) {
        if (displays[i] instanceof type) {
          resolve(displays[i]);
          break;
        }
      }
      resolve(null);
    }, function() {
      // No displays are found.
      resolve(null);
    });
  });
};

/**
 * Helper for entering VR mode.
 */
WebVRManager.prototype.enterVRMode_ = function() {
  this.hmd.requestPresent([{
    source: this.renderer.domElement,
    predistorted: this.predistorted
  }]);
};

WebVRManager.prototype.setMode_ = function(mode) {
  var oldMode = this.mode;
  if (mode == this.mode) {
    console.warn('Not changing modes, already in %s', mode);
    return;
  }
  // console.log('Mode change: %s => %s', this.mode, mode);
  this.mode = mode;
  this.button.setMode(mode, this.isVRCompatible);

  // Emit an event indicating the mode changed.
  this.emit('modechange', mode, oldMode);
};

/**
 * Main button was clicked.
 */
WebVRManager.prototype.onFSClick_ = function() {
  switch (this.mode) {
    case Modes.NORMAL:
      // TODO: Remove this hack if/when iOS gets real fullscreen mode.
      // If this is an iframe on iOS, break out and open in no_fullscreen mode.
      if (Util.isIOS() && Util.isIFrame()) {
        if (this.fullscreenCallback) {
          this.fullscreenCallback();
        } else {
          var url = window.location.href;
          url = Util.appendQueryParameter(url, 'no_fullscreen', 'true');
          url = Util.appendQueryParameter(url, 'start_mode', Modes.MAGIC_WINDOW);
          top.location.href = url;
          return;
        }
      }
      this.setMode_(Modes.MAGIC_WINDOW);
      this.requestFullscreen_();
      break;
    case Modes.MAGIC_WINDOW:
      if (this.isFullscreenDisabled) {
        window.history.back();
        return;
      }
      if (this.exitFullscreenCallback) {
        this.exitFullscreenCallback();
      }
      this.setMode_(Modes.NORMAL);
      this.exitFullscreen_();
      break;
  }
};

/**
 * The VR button was clicked.
 */
WebVRManager.prototype.onVRClick_ = function() {
  // TODO: Remove this hack when iOS has fullscreen mode.
  // If this is an iframe on iOS, break out and open in no_fullscreen mode.
  if (this.mode == Modes.NORMAL && Util.isIOS() && Util.isIFrame()) {
    if (this.vrCallback) {
      this.vrCallback();
    } else {
      var url = window.location.href;
      url = Util.appendQueryParameter(url, 'no_fullscreen', 'true');
      url = Util.appendQueryParameter(url, 'start_mode', Modes.VR);
      top.location.href = url;
      return;
    }
  }
  this.enterVRMode_();
};

WebVRManager.prototype.requestFullscreen_ = function() {
  var canvas = document.body;
  //var canvas = this.renderer.domElement;
  if (canvas.requestFullscreen) {
    canvas.requestFullscreen();
  } else if (canvas.mozRequestFullScreen) {
    canvas.mozRequestFullScreen();
  } else if (canvas.webkitRequestFullscreen) {
    canvas.webkitRequestFullscreen();
  } else if (canvas.msRequestFullscreen) {
    canvas.msRequestFullscreen();
  }
};

WebVRManager.prototype.exitFullscreen_ = function() {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen();
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen();
  } else if (document.msExitFullscreen) {
    document.msExitFullscreen();
  }
};

WebVRManager.prototype.onVRDisplayPresentChange_ = function(e) {
  console.log('onVRDisplayPresentChange_', e);
  if (this.hmd.isPresenting) {
    this.setMode_(Modes.VR);
  } else {
    this.setMode_(Modes.NORMAL);
  }
};

WebVRManager.prototype.onVRDisplayDeviceParamsChange_ = function(e) {
  console.log('onVRDisplayDeviceParamsChange_', e);
};

WebVRManager.prototype.onFullscreenChange_ = function(e) {
  // If we leave full-screen, go back to normal mode.
  if (document.webkitFullscreenElement === null ||
      document.mozFullScreenElement === null) {
    this.setMode_(Modes.NORMAL);
  }
};

module.exports = WebVRManager;

},{"./button-manager.js":1,"./emitter.js":2,"./modes.js":3,"./util.js":4}]},{},[5])(5)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],6:[function(require,module,exports){
(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ]

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    }

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift()
        return {done: value === undefined, value: value}
      }
    }

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      }
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)

    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var oldValue = this.map[name]
    this.map[name] = oldValue ? oldValue+','+value : value
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    name = normalizeName(name)
    return this.has(name) ? this.map[name] : null
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value)
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this)
      }
    }
  }

  Headers.prototype.keys = function() {
    var items = []
    this.forEach(function(value, name) { items.push(name) })
    return iteratorFor(items)
  }

  Headers.prototype.values = function() {
    var items = []
    this.forEach(function(value) { items.push(value) })
    return iteratorFor(items)
  }

  Headers.prototype.entries = function() {
    var items = []
    this.forEach(function(value, name) { items.push([name, value]) })
    return iteratorFor(items)
  }

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsArrayBuffer(blob)
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsText(blob)
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf)
    var chars = new Array(view.length)

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i])
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength)
      view.set(new Uint8Array(buf))
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false

    this._initBody = function(body) {
      this._bodyInit = body
      if (!body) {
        this._bodyText = ''
      } else if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString()
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer)
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer])
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body)
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      }
    }

    this.text = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body

    if (typeof input === 'string') {
      this.url = input
    } else {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body && input._bodyInit != null) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers()
    rawHeaders.split('\r\n').forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        headers.append(key, value)
      }
    })
    return headers
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = 'status' in options ? options.status : 200
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = 'statusText' in options ? options.statusText : 'OK'
    this.headers = new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init)
      var xhr = new XMLHttpRequest()

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        }
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);

},{}],7:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _three = (typeof window !== "undefined" ? window['THREE'] : typeof global !== "undefined" ? global['THREE'] : null);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Fire = function (_THREE$Object3D) {
  _inherits(Fire, _THREE$Object3D);

  function Fire() {
    _classCallCheck(this, Fire);

    var _this = _possibleConstructorReturn(this, _THREE$Object3D.call(this));

    _this.numParticles = 1000;

    _this.opts = {
      sparkLifecycle: 0.7,
      sparkStartSize: 10,
      sparkEndSize: 20,
      sparkDistanceScale: 1.5,

      flameMinHeight: 0.02,
      flameMaxHeight: 0.25,
      flamePeriod: 0.5,
      windStrength: 0.14,
      windFrequency: 0.5,

      color: 0xfcc648,
      endColor: 0xc0561c,

      opacity: 0.7,
      gravity: 0.2,

      // static - set at start
      baseWidth: 0.8 // angle - multiple of PI
    };

    var textureLoader = new THREE.TextureLoader();
    textureLoader.load('https://s3-us-west-2.amazonaws.com/s.cdpn.io/126747/snowflake_16x16.png', function (texture) {
      _this.texture = texture;
      _this.system.material.uniforms.texture.value = texture;
    });
    return _this;
  }

  Fire.prototype.init = function init() {
    // make sure gravity points in world Y
    // http://stackoverflow.com/questions/35641875/three-js-how-to-find-world-orientation-vector-of-objects-local-up-vector
    var v3 = new THREE.Vector3();
    v3.copy(this.up).applyQuaternion(this.getWorldQuaternion().inverse());

    var systemGeometry = new THREE.BufferGeometry();
    var systemMaterial = new THREE.ShaderMaterial({
      uniforms: {
        up: { type: 'v3', value: v3 },
        gravity: { type: 'f', value: this.opts.gravity },
        elapsedTime: { type: 'f', value: 0.0 },
        numParticles: { type: 'f', value: this.numParticles },
        color: { type: 'c', value: new THREE.Color(this.opts.color) },
        endColor: { type: 'c', value: new THREE.Color(this.opts.endColor) },
        flameMaxHeight: { type: 'f', value: this.opts.flameMaxHeight },
        flameMinHeight: { type: 'f', value: this.opts.flameMinHeight },
        flamePeriod: { type: 'f', value: this.opts.flamePeriod },
        windStrength: { type: 'f', value: this.opts.windStrength },
        windFrequency: { type: 'f', value: this.opts.windFrequency },
        sparkLifecycle: { type: 'f', value: this.opts.sparkLifecycle },
        sparkDistanceScale: { type: 'f', value: this.opts.sparkDistanceScale },
        sparkStartSize: { type: 'f', value: this.opts.sparkStartSize },
        sparkEndSize: { type: 'f', value: this.opts.sparkEndSize },
        opacity: { type: 'f', value: this.opts.opacity },
        texture: { type: 't', value: null }
      },
      transparent: true,
      // depthWrite: false,
      depthTest: false,
      // NOTE: don't use additive blending for light backgrounds
      // http://answers.unity3d.com/questions/573717/particle-effects-against-light-backgrounds.html
      // blending: THREE.AdditiveBlending,
      vertexShader: '\n        uniform float elapsedTime;\n        uniform float numParticles;\n        uniform float gravity;\n        uniform vec3 up;\n\n        uniform float sparkLifecycle;\n        uniform float sparkDistanceScale;\n        uniform float sparkStartSize;\n        uniform float sparkEndSize;\n\n        uniform float flameMaxHeight;\n        uniform float flameMinHeight;\n        uniform float flamePeriod;\n        uniform float windStrength;\n        uniform float windFrequency;\n\n        attribute vec3 direction;\n        attribute float uniqueness;\n        attribute float particleIndex;\n\n        #define PI 3.141592653589793238462643383279\n\n        varying float vTime;\n\n        void main( void ) {\n          // unique duration\n          float duration = sparkLifecycle + sparkLifecycle * uniqueness;\n\n          // make time loop\n          float particleOffset = (particleIndex / numParticles * duration);\n          float time = mod(elapsedTime + particleOffset, duration);\n\n          // store time as 0-1 for fragment shader\n          vTime = time / duration;\n\n          // apply "gravity" to fire\n          vec3 vGravity = up * gravity * pow(vTime, 2.0);\n\n          // move in direction based on elapsed time\n          float flameHeight = mix(flameMinHeight, flameMaxHeight, uniqueness);\n          vec3 vDistance = flameHeight * direction * vTime;\n\n          // close flame at top (0.5 is fully closed)\n          vDistance.xz *= cos(mix(0.0, PI * flamePeriod, vTime));\n\n          // apply some random horizonal wind\n          vec3 vWind = sin((elapsedTime + vTime * uniqueness) * windFrequency * uniqueness) * cross(up, direction) * windStrength * uniqueness * vTime;\n\n          // add all forces to get final position for this frame\n          vec3 pos = position + vDistance + vGravity + vWind;\n\n          // Set size based on frame and distance\n          vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );\n          gl_PointSize = mix(sparkStartSize, sparkEndSize, vTime);\n          gl_PointSize = gl_PointSize * (sparkDistanceScale / length(mvPosition.xyz));\n\n          // project position on screen\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n        }\n\n      ',
      fragmentShader: '\n        uniform vec3 color;\n        uniform vec3 endColor;\n        uniform float opacity;\n        uniform sampler2D texture;\n\n        varying float vTime;\n\n        void main() {\n          vec4 texColor = texture2D(texture, gl_PointCoord);\n          vec4 startColor = vec4(color, opacity);\n          vec4 endColor = vec4(endColor, 0.0);\n          gl_FragColor = texColor * mix(startColor, endColor, vTime);\n        }\n      '
    });

    // all flames start at 0,0,0
    var positions = new Float32Array(this.numParticles * 3);
    for (var i = 0; i < positions.length; i += 3) {
      positions[i] = 0;
    }

    var direction = new Float32Array(this.numParticles * 3);
    for (var _i = 0; _i < direction.length; _i += 3) {
      var phi = this.randCenter(Math.PI * this.opts.baseWidth);
      var theta = this.randCenter(Math.PI);
      // create normal vector in random direction
      var sphereCoord = THREE.Spherical(1, phi, theta);

      var v = new THREE.Vector3();
      v.setFromSpherical(sphereCoord);
      direction[_i] = v.x;
      direction[_i + 1] = v.y;
      direction[_i + 2] = v.z;
    }

    // push some uniqueness - because entropy...
    var uniqueness = new Float32Array(this.numParticles);
    for (var _i2 = 0; _i2 < this.numParticles; _i2++) {
      uniqueness[_i2] = Math.random();
    }

    // remember particle index
    var particleIndex = new Float32Array(this.numParticles);
    for (var _i3 = 0; _i3 < this.numParticles; _i3++) {
      particleIndex[_i3] = _i3;
    }

    systemGeometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
    systemGeometry.addAttribute('direction', new THREE.BufferAttribute(direction, 3));
    systemGeometry.addAttribute('uniqueness', new THREE.BufferAttribute(uniqueness, 1));
    systemGeometry.addAttribute('particleIndex', new THREE.BufferAttribute(particleIndex, 1));

    systemGeometry.computeBoundingSphere();
    this.system = new THREE.Points(systemGeometry, systemMaterial);

    this.add(this.system);

    this.system.renderOrder = 2;
  };

  Fire.prototype.update = function update(delta, elapsed) {
    this.system.material.uniforms.elapsedTime.value = elapsed;

    var up = new THREE.Vector3();
    up.copy(this.up).applyQuaternion(this.getWorldQuaternion().inverse());
    this.system.material.uniforms.up.value = up;
  };

  Fire.prototype.updateOne = function updateOne(opt) {
    this.system.material.uniforms[opt].value = this.opts[opt];
  };

  Fire.prototype.updateColor = function updateColor(opt) {
    this.system.material.uniforms[opt].value = new THREE.Color(this.opts[opt]);
  };

  Fire.prototype.randCenter = function randCenter(v) {
    return v * (Math.random() - 0.5);
  };

  return Fire;
}(THREE.Object3D);

exports.default = Fire;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _materialUtil = require('./utils/material-util');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Ground = function Ground(scene, objectLoader, snowHeight) {
  _classCallCheck(this, Ground);

  window.fetch('assets/models/snowcap.json').then(function (response) {
    if (response.status !== 200) {
      console.log('Looks like there was a problem. Status Code: ' + response.status);
      return;
    }
    // Examine the text in the response
    response.json().then(function (data) {
      (0, _materialUtil.convertMaterialsToLambert)(data);
      var obj = objectLoader.parse(data);
      obj.position.y = snowHeight + 0.1;
      obj.scale.setScalar(0.35);
      // for (let i = 0; i < obj.children.length; i++) {
      //   obj.children[i].geometry.computeFlatVertexNormals()
      // }
      scene.add(obj);
    });
  });
};

exports.default = Ground;

},{"./utils/material-util":16}],9:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _three = (typeof window !== "undefined" ? window['THREE'] : typeof global !== "undefined" ? global['THREE'] : null);

var THREE = _interopRequireWildcard(_three);

var _materialUtil = require('./utils/material-util');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Hand = function (_THREE$Object3D) {
  _inherits(Hand, _THREE$Object3D);

  function Hand(objectLoader, modelSrc) {
    _classCallCheck(this, Hand);

    var _this = _possibleConstructorReturn(this, _THREE$Object3D.call(this));

    _this.objectLoader = objectLoader;
    _this.modelSrc = modelSrc;
    _this.action = {};

    _this.load();
    return _this;
  }

  Hand.prototype.load = function load() {
    var _this2 = this;

    window.fetch(this.modelSrc).then(function (response) {
      if (response.status !== 200) {
        console.log('Looks like there was a problem. Status Code: ' + response.status);
        return;
      }
      // parse json
      response.json().then(_this2.handleData.bind(_this2));
    });
  };

  Hand.prototype.handleData = function handleData(data) {
    (0, _materialUtil.convertMaterialsToLambert)(data);

    // enable skinned animation
    for (var i = 0; i < data.materials.length; i++) {
      data.materials[i].skinning = true;
    }

    var obj = this.objectLoader.parse(data);

    // make flat shaded
    for (var _i = 0; _i < obj.children.length; _i++) {
      obj.children[_i].geometry.computeFlatVertexNormals();
    }

    var skinnedMesh = obj.children[0];
    var animations = skinnedMesh.geometry.animations;

    this.mixer = new THREE.AnimationMixer(skinnedMesh);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = animations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var animation = _step.value;

        this.action[animation.name] = this.mixer.clipAction(animation, skinnedMesh);
        this.action[animation.name].setLoop(THREE.LoopOnce, 0);
        this.action[animation.name].clampWhenFinished = true;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    this.add(obj);
  };

  Hand.prototype.update = function update(delta) {
    if (this.mixer) {
      this.mixer.update(delta);
    }
  };

  Hand.prototype.grip = function grip() {
    this.action['Grip'].play();
  };

  Hand.prototype.release = function release() {
    this.action['Grip'].stop();
  };

  return Hand;
}(THREE.Object3D);

exports.default = Hand;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./utils/material-util":16}],10:[function(require,module,exports){
(function (global){
'use strict';

require('whatwg-fetch');

var _three = (typeof window !== "undefined" ? window['THREE'] : typeof global !== "undefined" ? global['THREE'] : null);

var THREE = _interopRequireWildcard(_three);

var _query = require('./utils/query');

var _query2 = _interopRequireDefault(_query);

var _ground = require('./ground');

var _ground2 = _interopRequireDefault(_ground);

var _treeline = require('./treeline');

var _treeline2 = _interopRequireDefault(_treeline);

var _moose = require('./moose');

var _moose2 = _interopRequireDefault(_moose);

var _snowfall = require('./snowfall');

var _snowfall2 = _interopRequireDefault(_snowfall);

var _torch = require('./torch');

var _torch2 = _interopRequireDefault(_torch);

var _hand = require('./hand');

var _hand2 = _interopRequireDefault(_hand);

var _snowpuff = require('./snowpuff');

var _snowpuff2 = _interopRequireDefault(_snowpuff);

var _OBJLoader2 = require('OBJLoader');

var _OBJLoader3 = _interopRequireDefault(_OBJLoader2);

var _VRControls2 = require('VRControls');

var _VRControls3 = _interopRequireDefault(_VRControls2);

var _VREffect2 = require('VREffect');

var _VREffect3 = _interopRequireDefault(_VREffect2);

var _ViveController2 = require('ViveController');

var _ViveController3 = _interopRequireDefault(_ViveController2);

var _webvrBoilerplate = require('webvr-boilerplate');

var _webvrBoilerplate2 = _interopRequireDefault(_webvrBoilerplate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
var SNOW_HEIGHT = 0.5; // eslint-disable-line no-unused-vars

// Import WebVRManager npm module
// eslint-disable-line no-unused-vars


// load shimmed plugins - access on THREE namespace


var clock = new THREE.Clock();
var jsonLoader = new THREE.JSONLoader();
var objectLoader = new THREE.ObjectLoader();

// user objects that need update on each frame
var updateObjects = [];

var scene = void 0,
    camera = void 0,
    HEIGHT = void 0,
    WIDTH = void 0,
    renderer = void 0,
    container = void 0;
var vrControls = void 0,
    vrEffect = void 0,
    vrManager = void 0,
    vrDisplay = void 0;
var viveController1 = void 0,
    viveController2 = void 0;

var ground = void 0; // eslint-disable-line no-unused-vars
var treeline = void 0; // eslint-disable-line no-unused-vars

var isNight = _query2.default.isNight;
var bgColor = isNight ? 0x111122 : 0xc6ccff;

function createScene() {
  HEIGHT = window.innerHeight;
  WIDTH = window.innerWidth;

  // Create the scene
  scene = new THREE.Scene();

  // Add a fog vrEffect to the scene using similar color as background
  // scene.fog = new THREE.Fog(0xc6ccff, 4, 11)
  scene.fog = new THREE.FogExp2(bgColor, 0.15);

  // Create the camera
  var aspectRatio = WIDTH / HEIGHT;
  var fieldOfView = 60;
  var nearPlane = 0.05;
  var farPlane = 50;
  camera = new THREE.PerspectiveCamera(fieldOfView, aspectRatio, nearPlane, farPlane);

  // Create the renderer
  renderer = new THREE.WebGLRenderer({
    // Allow transparency to show the gradient background
    // we defined in the CSS
    alpha: false,
    // Activate the anti-aliasing this is less performant,
    // but, as our project is low-poly based, it should be fine :)
    antialias: true
  });

  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setClearColor(bgColor, 1);

  // Define the size of the renderer in this case,
  // it will fill the entire screen
  renderer.setSize(WIDTH, HEIGHT);

  // Enable shadow rendering
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  // Add the DOM element of the renderer to the
  // container we created in the HTML
  container = document.getElementById('world');
  container.appendChild(renderer.domElement);
}

function handleWindowResize() {
  // update height and width of the renderer and the camera
  HEIGHT = window.innerHeight;
  WIDTH = window.innerWidth;
  vrEffect.setSize(WIDTH, HEIGHT);
  renderer.setSize(WIDTH, HEIGHT);
  camera.aspect = WIDTH / HEIGHT;
  camera.updateProjectionMatrix();
}

function createLights() {
  // A directional light shines from a specific direction.
  // It acts like the sun, that means that all the rays produced are parallel.
  var shadowLight = new THREE.DirectionalLight(0xffffff, 0.1);

  // Set the direction of the light
  shadowLight.position.set(1, 2, -1);
  shadowLight.position.normalize();

  // Allow shadow casting
  shadowLight.castShadow = true;

  // define the visible area of the projected shadow
  shadowLight.shadow.camera.left = -10;
  shadowLight.shadow.camera.right = 10;
  shadowLight.shadow.camera.top = 10;
  shadowLight.shadow.camera.bottom = -10;
  shadowLight.shadow.camera.near = -10;
  shadowLight.shadow.camera.far = 10;

  // debug light
  if (_query2.default.debug) {
    scene.add(new THREE.CameraHelper(shadowLight.shadow.camera));
  }

  // define the resolution of the shadow the higher the better,
  // but also the more expensive and less performant
  shadowLight.shadow.mapSize.width = 1024 * 2;
  shadowLight.shadow.mapSize.height = 1024 * 2;

  // an ambient light modifies the global color of a scene and makes the shadows softer
  var ambientLight = new THREE.AmbientLight(0xffffff, 1.3);
  if (isNight) {
    ambientLight.intensity = 0.1;
  }

  scene.add(shadowLight);
  scene.add(ambientLight);
}

function createSnowFall() {
  var snowfall = new _snowfall2.default(100000);
  snowfall.system.position.set(0, SNOW_HEIGHT, 0);
  scene.add(snowfall.system);
  return snowfall;
}

function createHands() {
  if (viveController1) {
    (function () {
      var handL = new _hand2.default(objectLoader, 'assets/models/hands/handsForOculus/handL.json');
      viveController1.add(handL);
      viveController1.addEventListener('triggerdown', function () {
        return handL.grip();
      });
      viveController1.addEventListener('triggerup', function () {
        return handL.release();
      });
      updateObjects.push(handL);

      if (isNight) {
        // temp: add stuff to hands
        var torch = new _torch2.default();
        // torch.position.y = 1.35
        torch.position.z = 0.04;
        torch.position.y = -0.02;
        torch.rotation.z = -Math.PI / 2;
        torch.rotation.y = Math.PI / 4;

        // scene.add(torch)

        handL.add(torch);
        updateObjects.push(torch);
        // test rotate hand
        handL.rotation.z = Math.PI / 4;
      }
    })();
  }

  if (viveController2) {
    (function () {
      var handR = new _hand2.default(objectLoader, 'assets/models/hands/handsForOculus/handR.json');
      viveController2.add(handR);
      viveController2.addEventListener('triggerdown', function () {
        return handR.grip();
      });
      viveController2.addEventListener('triggerup', function () {
        return handR.release();
      });
      updateObjects.push(handR);
    })();
  }

  // window.addEventListener('mousedown', () => torch.on())
  // window.addEventListener('mouseup', () => torch.off())
  // viveController1.addEventListener('triggerdown', () => torch.on())
  // viveController1.addEventListener('triggerup', () => torch.off())
}

function loop() {
  var delta = clock.getDelta();
  var elapsed = clock.getElapsedTime();

  if (viveController1) {
    viveController1.update();
  }
  if (viveController2) {
    viveController2.update();
  }

  // update user objects
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = updateObjects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var object = _step.value;

      object.update(delta, elapsed);
    }

    // Render the scene through the vrManager.
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  vrControls.update(delta);
  vrManager.render(scene, camera, delta);

  // call the loop function again
  vrDisplay.requestAnimationFrame(loop);
}

function loadViveControllerModels() {
  var loader = new THREE.OBJLoader();
  loader.setPath('assets/models/vive-controller/');
  loader.load('vr_controller_vive_1_5.obj', function (object) {
    console.log('loaded controller OBJ');
    var loader = new THREE.TextureLoader();
    loader.setPath('assets/models/vive-controller/');

    var controller = object.children[0];
    controller.material.map = loader.load('onepointfive_texture.png');
    controller.material.specularMap = loader.load('onepointfive_spec.png');

    viveController1.add(object.clone());
    viveController2.add(object.clone());
  });
}

function showControllerGuideRays() {
  // show ray for debug
  var geometry = new THREE.Geometry();
  geometry.vertices.push(new THREE.Vector3(0, 0, 0));
  geometry.vertices.push(new THREE.Vector3(0, 0, -1));

  var line = new THREE.Line(geometry);
  line.name = 'line';
  line.scale.z = 5;

  viveController1.add(line.clone());
  viveController2.add(line.clone());
}

// VIVE CONTROLLER
function initViveControllers() {
  if (!navigator.getGamepads) {
    console.warn('GAMEPAD API not enabled?');
    return;
  }

  viveController1 = new THREE.ViveController(0);
  viveController1.standingMatrix = vrControls.getStandingMatrix();
  scene.add(viveController1);

  viveController2 = new THREE.ViveController(1);
  viveController2.standingMatrix = vrControls.getStandingMatrix();
  scene.add(viveController2);

  // loadViveControllerModels()

  if (_query2.default.debug) {
    showControllerGuideRays();
  }
}

function initVR() {
  // Apply VR headset positional data to camera.
  vrControls = new THREE.VRControls(camera);
  vrControls.standing = true;

  // Apply VR stereo rendering to renderer.
  vrEffect = new THREE.VREffect(renderer);
  vrEffect.setSize(window.innerWidth, window.innerHeight);

  // Create a VR vrManager helper to enter and exit VR mode.
  var params = {
    hideButton: false, // Default: false.
    isUndistorted: false // Default: false.
  };
  vrManager = new _webvrBoilerplate2.default(renderer, vrEffect, params);

  // For high end VR devices like Vive and Oculus, take into account the stage
  // parameters provided.
  setupStage();

  // init controllers
  initViveControllers();

  // Listen to the screen: if the user resizes it
  // we have to update the camera and the renderer size
  window.addEventListener('resize', handleWindowResize, false);
  window.addEventListener('vrdisplaypresentchange', handleWindowResize, true);
}

function init() {
  // set up the scene, the camera and the renderer
  createScene();

  initVR();

  // add the lights
  createLights();

  // create user objects
  ground = new _ground2.default(scene, objectLoader, SNOW_HEIGHT);
  treeline = new _treeline2.default(scene);

  createHands();

  // keep track of objects that need to update
  updateObjects.push(createSnowFall());
  updateObjects.push(new _moose2.default(scene, jsonLoader));

  // debug puff
  // const puff = new Snowpuff(scene)
  // puff.system.position.set(0, 0, -2)
  // scene.add(puff.system)
  // updateObjects.push(puff)
}

// Get the HMD, and if we're dealing with something that specifies
// stageParameters, rearrange the scene.
function setupStage() {
  navigator.getVRDisplays().then(function (displays) {
    if (displays.length > 0) {
      vrDisplay = displays[0];
      if (vrDisplay.stageParameters) {
        setStageDimensions(vrDisplay.stageParameters);
      }
      // start a loop that will update the objects' positions
      // and render the scene on each frame
      vrDisplay.requestAnimationFrame(loop);
    }
  });
}

function setStageDimensions(stage) {
  // Size the skybox according to the size of the actual stage.
  // var geometry = new THREE.BoxGeometry(stage.sizeX, boxSize, stage.sizeZ);
}

window.addEventListener('load', init, false);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./ground":8,"./hand":9,"./moose":11,"./snowfall":12,"./snowpuff":13,"./torch":14,"./treeline":15,"./utils/query":17,"OBJLoader":3,"VRControls":1,"VREffect":2,"ViveController":4,"webvr-boilerplate":5,"whatwg-fetch":6}],11:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _three = (typeof window !== "undefined" ? window['THREE'] : typeof global !== "undefined" ? global['THREE'] : null);

var THREE = _interopRequireWildcard(_three);

var _snowpuff = require('./snowpuff');

var _snowpuff2 = _interopRequireDefault(_snowpuff);

var _randomUtil = require('./utils/random-util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MIN_DISTANCE = 0.5; // 1.5
var MAX_DISTANCE = 7;

var Moose = function () {
  function Moose(scene, loader) {
    _classCallCheck(this, Moose);

    this.scene = scene;
    this.snowpuffs = [];
    this.loader = loader;

    this.mooseStart = -20;
    this.mooseDistance = 0;

    this.mooseFirstTime = true;
    this.mooseAngle = Math.PI;

    this.mooseWrapper = undefined;
    this.moose = undefined;
    this.mesh = undefined;
    this.mixer = undefined;
    this.animationClip = undefined;
    this.animationAction = undefined;

    this.load();
  }

  Moose.prototype.load = function load() {
    var _this = this;

    this.loader.load(
    // resource URL
    'assets/models/moose_life.js',
    // Function when resource is loaded
    function (geometry, materials) {
      _this.mesh = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({
        vertexColors: THREE.FaceColors,
        morphTargets: true
      }));
      _this.mesh.scale.setScalar(0.01);
      _this.mesh.castShadow = true;

      _this.moose = new THREE.Object3D();
      _this.moose.add(_this.mesh);

      _this.mooseWrapper = new THREE.Object3D();
      _this.mooseWrapper.add(_this.moose);

      // debug position
      // this.mooseWrapper.position.set(0, 0, -10)
      // this.moose.rotation.y = Math.PI / 2

      // add to scene
      _this.scene.add(_this.mooseWrapper);

      _this.initAnimation(geometry);
      _this.initSnowEffect();
    });
  };

  Moose.prototype.initAnimation = function initAnimation(geometry) {
    this.mixer = new THREE.AnimationMixer(this.mesh);
    this.animationClip = THREE.AnimationClip.CreateFromMorphTargetSequence('gallop', geometry.morphTargets, 60);
    this.animationAction = this.mixer.clipAction(this.animationClip).setDuration(1).play();
  };

  Moose.prototype.initSnowEffect = function initSnowEffect() {
    var puff = new _snowpuff2.default(this.scene);
    puff.system.position.set(0, 0, 0);
    this.moose.add(puff.system);
    this.snowpuffs.push(puff);

    var puff2 = new _snowpuff2.default(this.scene, 0.15);
    puff2.system.position.set(0, 0, -1.5);
    this.moose.add(puff2.system);
    this.snowpuffs.push(puff2);
  };

  Moose.prototype.update = function update(delta, elapsed) {
    if (!this.mixer) {
      return;
    }

    // figure out distance since last frame
    this.mooseDistance += delta * 3;
    var pos = this.mooseStart + this.mooseDistance;

    // turn around when out of screen
    if (this.mooseFirstTime || pos > Math.abs(this.mooseStart)) {
      this.mooseFirstTime = false;
      // turn around at slightly different random angle
      this.mooseAngle += Math.PI + (0, _randomUtil.randomBetween)(-Math.PI / 8, Math.PI / 8);
      this.mooseDistance = 0;
      this.mooseWrapper.rotation.y = this.mooseAngle;

      var distance = (0, _randomUtil.randomBetween)(MIN_DISTANCE, MAX_DISTANCE);
      this.moose.position.x = (0, _randomUtil.randomPick)([distance, -distance]);
    }

    // move and animate
    this.moose.position.z = pos;
    this.mixer.update(delta);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = this.snowpuffs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var snowpuff = _step.value;

        snowpuff.update(delta, elapsed);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  };

  return Moose;
}();

exports.default = Moose;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./snowpuff":13,"./utils/random-util":18}],12:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _three = (typeof window !== "undefined" ? window['THREE'] : typeof global !== "undefined" ? global['THREE'] : null);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PARTICLE_SIZE = 0.006;

var Snowfall = function () {
  function Snowfall() {
    var numParticles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;

    var _this = this;

    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
    var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;

    _classCallCheck(this, Snowfall);

    this.numParticles = numParticles;

    this.height = height;
    this.width = width;
    this.depth = depth;

    var textureLoader = new THREE.TextureLoader();
    textureLoader.load('assets/textures/snowflake.png', function (texture) {
      _this.texture = texture;
      _this.system.material.uniforms.texture.value = texture;
    });
    this._size = -1;
    this.setParticleSize();
    window.addEventListener('resize', function (x) {
      return _this.setParticleSize();
    });
    this.init();
  }

  Snowfall.prototype.setParticleSize = function setParticleSize() {
    this._size = window.innerHeight * PARTICLE_SIZE * window.devicePixelRatio;
  };

  // depends on viewport size


  Snowfall.prototype.getParticleSize = function getParticleSize() {
    return this._size;
  };

  Snowfall.prototype.init = function init() {
    var systemGeometry = new THREE.BufferGeometry();
    var systemMaterial = new THREE.ShaderMaterial({
      uniforms: {
        color: { type: 'c', value: new THREE.Color(0xFFFFFF) },
        height: { type: 'f', value: this.height },
        speedV: { type: 'f', value: 0.4 },
        speedH: { type: 'f', value: 2.0 },
        elapsedTime: { type: 'f', value: 0.0 },
        radius: { type: 'f', value: 0.02 },
        scale: { type: 'f', value: 2.0 },
        size: { type: 'f', value: this._size },
        opacity: { type: 'f', value: 0.1 },
        texture: { type: 't', value: null }
      },
      vertexShader: '\n        uniform float height;\n        uniform float elapsedTime;\n        uniform float speedV;\n        uniform float speedH;\n        uniform float radius;\n        uniform float scale;\n        uniform float size;\n        attribute float uniqueness;\n        void main() {\n          vec3 pos = position;\n          pos.x += cos((elapsedTime - position.z - uniqueness) * speedH) * radius;\n          pos.y = mod(position.y - elapsedTime * speedV, height);\n          pos.z += sin((elapsedTime - position.x - uniqueness) * speedH) * radius;\n          vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );\n          gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n          gl_Position = projectionMatrix * mvPosition;\n        }\n      ',
      fragmentShader: '\n        uniform vec3 color;\n        uniform float opacity;\n        uniform sampler2D texture;\n        void main() {\n          vec4 texColor = texture2D( texture, gl_PointCoord );\n          gl_FragColor = texColor * vec4( color, opacity );\n        }\n      ',
      transparent: true,
      depthTest: false,
      blending: THREE.AdditiveBlending
    });

    var positions = new Float32Array(this.numParticles * 3);
    var uniqueness = new Float32Array(this.numParticles);
    for (var i = 0; i < positions.length; i += 3) {
      // x
      positions[i] = this.randCenter(this.width);
      // y
      positions[i + 1] = Math.random() * this.height;
      // z
      positions[i + 2] = this.randCenter(this.depth);
    }

    // push some uniqueness - because snowflakes...
    for (var _i = 0; _i < this.numParticles; _i++) {
      uniqueness[_i] = Math.random();
    }

    // Set attributes for shaders to access
    systemGeometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
    systemGeometry.addAttribute('uniqueness', new THREE.BufferAttribute(uniqueness, 1));

    // must compute bounding box for bufferGeomtry
    systemGeometry.computeBoundingSphere();

    // create particle system
    this.system = new THREE.Points(systemGeometry, systemMaterial);

    // help THREE place snow on top of transparent objects
    this.system.renderOrder = 1;
    this.system.sortParticles = true;
  };

  Snowfall.prototype.update = function update(delta, elapsed) {
    this.system.material.uniforms.elapsedTime.value = elapsed;
    this.system.material.uniforms.size.value = this.getParticleSize();
  };

  Snowfall.prototype.randCenter = function randCenter(v) {
    return v * (Math.random() - 0.5);
  };

  return Snowfall;
}();

exports.default = Snowfall;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],13:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _three = (typeof window !== "undefined" ? window['THREE'] : typeof global !== "undefined" ? global['THREE'] : null);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Snowpuff = function () {
  function Snowpuff(scene) {
    var _this = this;

    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck(this, Snowpuff);

    this.scene = scene;
    this.numParticles = 20000;

    this.maxHeight = 0.5;
    this.minHeight = 0.2;
    this.offset = offset;

    var textureLoader = new THREE.TextureLoader();
    textureLoader.load('assets/textures/snowflake.png', function (texture) {
      _this.texture = texture;
      _this.system.material.uniforms.texture.value = texture;
    });
    this.init();
  }

  Snowpuff.prototype.init = function init() {
    var systemGeometry = new THREE.BufferGeometry();
    var systemMaterial = new THREE.ShaderMaterial({
      uniforms: {
        color: { type: 'c', value: new THREE.Color(0xFFFFFF) },
        speed: { type: 'f', value: 4 },
        elapsedTime: { type: 'f', value: 0.0 },
        scale: { type: 'f', value: 4.0 },
        size: { type: 'f', value: 8.0 },
        opacity: { type: 'f', value: 0.7 },
        fogColor: { type: 'c', value: this.scene.fog.color },
        fogNear: { type: 'f', value: this.scene.fog.near },
        fogFar: { type: 'f', value: this.scene.fog.far },
        fogDensity: { type: 'f', value: this.scene.fog.density },
        texture: { type: 't', value: null }
      },
      transparent: true,
      // depthTest: false,
      depthWrite: false,
      // blending: THREE.AdditiveBlending,
      fragmentShader: '\n        varying vec2 vUv;\n\n        uniform vec3 color;\n        uniform float opacity;\n        uniform sampler2D texture;\n\n        ' + THREE.ShaderChunk['common'] + '\n        ' + THREE.ShaderChunk['fog_pars_fragment'] + '\n        void main() {\n          vec4 texColor = texture2D( texture, gl_PointCoord );\n          gl_FragColor = texColor * vec4( color, opacity );\n          ' + THREE.ShaderChunk['fog_fragment'] + '\n\n          // addative blending bleeds through fog so let\'s reduce even more\n          // gl_FragColor.w *= mix(1.0, 0.05, fogFactor);\n        }\n      ',
      fog: true,
      vertexShader: '\n        uniform float elapsedTime;\n        uniform float speed;\n        uniform float scale;\n        uniform float size;\n        attribute vec3 velocity;\n        // attribute float uniqueness;\n\n        varying vec2 vUv;\n        varying vec3 vPosition;\n        void main( void ) {\n          vUv = uv;\n          vPosition = position;\n\n          // make time loop\n          float time = mod(elapsedTime, 1.0);\n\n          vec3 gravity = vec3(0, 1, 0) * time * speed * 0.4;\n          vec3 direction = (velocity + vec3(0, 0, -0.5)) * time * speed * 1.0;\n          vec3 pos = position + direction + pow(gravity, vec3(2.0)) * -1.0;\n\n          vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );\n          gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );\n        }\n      '
    });

    var positions = new Float32Array(this.numParticles * 3);
    for (var i = 0; i < positions.length; i += 3) {
      positions[i] = 0;
    }
    var uniqueness = new Float32Array(this.numParticles);
    var velocity = new Float32Array(this.numParticles * 3);
    for (var _i = 0; _i < velocity.length; _i += 3) {
      var len = Math.random() * this.maxHeight + this.minHeight;
      var phi = this.randCenter(Math.PI * 0.66);
      var theta = this.randCenter(Math.PI);
      var sphereCoord = THREE.Spherical(len, phi, theta);

      var v = new THREE.Vector3();
      v.setFromSpherical(sphereCoord);
      velocity[_i] = v.x;
      velocity[_i + 1] = v.y;
      velocity[_i + 2] = v.z;
    }

    // push some uniqueness - because snowflakes...
    for (var _i2 = 0; _i2 < this.numParticles; _i2++) {
      uniqueness[_i2] = Math.random();
    }

    systemGeometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
    systemGeometry.addAttribute('velocity', new THREE.BufferAttribute(velocity, 3));
    systemGeometry.addAttribute('uniqueness', new THREE.BufferAttribute(uniqueness, 1));
    systemGeometry.computeBoundingSphere();
    this.system = new THREE.Points(systemGeometry, systemMaterial);

    // help THREE place snow on top of transparent objects
    // this.system.renderOrder = 1
  };

  Snowpuff.prototype.update = function update(delta, elapsed) {
    this.system.material.uniforms.elapsedTime.value = elapsed + this.offset;
  };

  Snowpuff.prototype.randCenter = function randCenter(v) {
    return v * (Math.random() - 0.5);
  };

  return Snowpuff;
}();

exports.default = Snowpuff;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _three = (typeof window !== "undefined" ? window['THREE'] : typeof global !== "undefined" ? global['THREE'] : null);

var THREE = _interopRequireWildcard(_three);

var _fire = require('./fire');

var _fire2 = _interopRequireDefault(_fire);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Torch = function (_THREE$Object3D) {
  _inherits(Torch, _THREE$Object3D);

  function Torch() {
    var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0xffcc99;
    var intensity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;

    _classCallCheck(this, Torch);

    var _this = _possibleConstructorReturn(this, _THREE$Object3D.call(this));

    _this.color = color;
    _this.intensity = intensity;

    _this.light = new THREE.PointLight(color, intensity, 10, 1);
    _this.light.castShadow = true;
    _this.light.shadow.camera.near = 1;
    _this.light.shadow.camera.far = 30;
    _this.light.shadow.bias = 0.01;
    _this.add(_this.light);

    // handle
    var geometry = new THREE.CylinderGeometry(0.03, 0.01, 0.5, 16);
    var material = new THREE.MeshBasicMaterial({ color: 0x220000 });
    var handle = new THREE.Mesh(geometry, material);
    _this.add(handle);

    // fire
    _this.fire = new _fire2.default();
    _this.fire.init();
    _this.light.position.y = 0.255;
    _this.fire.position.y = 0.255;
    _this.add(_this.fire);

    // this.off()
    return _this;
  }

  Torch.prototype.update = function update(delta, elapsed) {
    this.fire.update(delta, elapsed);
  };

  Torch.prototype.on = function on() {
    this.light.intensity = this.intensity;
    this.sphere.material.color.setHex(this.color);
  };

  Torch.prototype.off = function off() {
    this.light.intensity = 0;
    this.sphere.material.color.setHex(0x000000);
  };

  return Torch;
}(THREE.Object3D);

exports.default = Torch;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./fire":7}],15:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _three = (typeof window !== "undefined" ? window['THREE'] : typeof global !== "undefined" ? global['THREE'] : null);

var THREE = _interopRequireWildcard(_three);

var _randomUtil = require('./utils/random-util');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Ground = function Ground(scene) {
  _classCallCheck(this, Ground);

  var loader = new THREE.JSONLoader();
  loader.load(
  // resource URL
  'assets/models/treeGenericLower.js',
  // Function when resource is loaded
  function (geometry) {
    var treeMesh = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({
      vertexColors: THREE.FaceColors,
      transparent: true,
      opacity: 0.8
    }));
    treeMesh.scale.setScalar(0.01);
    treeMesh.castShadow = true;

    for (var i = 0; i < 40; i++) {
      var randomX = (0, _randomUtil.randomBetween)(6, 11) * (0, _randomUtil.randomPick)([-1, 1]);
      var randomZ = (0, _randomUtil.randomBetween)(6, 11) * (0, _randomUtil.randomPick)([-1, 1]);
      var tree = treeMesh.clone();
      tree.position.set(randomX, -0.5, randomZ);
      scene.add(tree);
    }
  });
};

exports.default = Ground;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./utils/random-util":18}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

// replace all model materials with Lambert materials
var convertMaterialsToLambert = exports.convertMaterialsToLambert = function convertMaterialsToLambert(json) {
  // override all materials to be Lambert
  for (var i = 0; i < json.materials.length; i++) {
    var mat = json.materials[i];
    if (mat.type === 'MultiMaterial') {
      for (var j = 0; j < mat.materials.length; j++) {
        replaceMaterial(mat.materials[j]);
      }
    } else {
      replaceMaterial(json.materials[i]);
    }
  }
  function replaceMaterial(materialData) {
    materialData.type = 'MeshLambertMaterial';
    delete materialData.specular;
    materialData.shininess = 0;
  }
};

},{}],17:[function(require,module,exports){
'use strict';

module.exports = qs();

function qs() {
  var obj = {};
  var query = window.location.href.substring(window.location.href.indexOf('?') + 1, window.location.href.length);

  if (query.indexOf('#') !== -1) {
    query = query.substring(0, query.indexOf('#'));
  }

  var vars = query.split('&');
  for (var i = 0; i < vars.length; i++) {
    var pair = vars[i].split('=');
    var key = decodeURIComponent(pair[0]);
    var val = decodeURIComponent(pair[1]);
    obj[key] = val || true; // true so "?x"; if( query.x ){}
  }

  return obj;
}

},{}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.randomPick = randomPick;
exports.randomBetween = randomBetween;
exports.randomCenter = randomCenter;
function randomPick(list) {
  return list[Math.floor(Math.random() * list.length)];
}

function randomBetween(low, high) {
  return Math.floor(Math.random() * high) + low;
}

function randomCenter(v) {
  return v * (Math.random() - 0.5);
}

},{}]},{},[10])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanMvY29udHJvbHMvVlJDb250cm9scy5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9leGFtcGxlcy9qcy9lZmZlY3RzL1ZSRWZmZWN0LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzL2xvYWRlcnMvT0JKTG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzL3ZyL1ZpdmVDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL3dlYnZyLWJvaWxlcnBsYXRlL2J1aWxkL3dlYnZyLW1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvd2hhdHdnLWZldGNoL2ZldGNoLmpzIiwic3JjL2pzL2ZpcmUuanMiLCJzcmMvanMvZ3JvdW5kLmpzIiwic3JjL2pzL2hhbmQuanMiLCJzcmMvanMvbWFpbi5qcyIsInNyYy9qcy9tb29zZS5qcyIsInNyYy9qcy9zbm93ZmFsbC5qcyIsInNyYy9qcy9zbm93cHVmZi5qcyIsInNyYy9qcy90b3JjaC5qcyIsInNyYy9qcy90cmVlbGluZS5qcyIsInNyYy9qcy91dGlscy9tYXRlcmlhbC11dGlsLmpzIiwic3JjL2pzL3V0aWxzL3F1ZXJ5LmpzIiwic3JjL2pzL3V0aWxzL3JhbmRvbS11dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Z1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUMxY0E7O0lBQVksSzs7Ozs7Ozs7OztJ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TCxDQUFXLEtBQUssTUFBTCxLQUFnQixLQUFLLE1BQWhDLENBQUwsQ0FBUDtBQUNEOztBQUVNLFNBQVMsYUFBVCxDQUF3QixHQUF4QixFQUE2QixJQUE3QixFQUFtQztBQUN4QyxTQUFPLEtBQUssS0FBTCxDQUFXLEtBQUssTUFBTCxLQUFnQixJQUEzQixJQUFtQyxHQUExQztBQUNEOztBQUVNLFNBQVMsWUFBVCxDQUF1QixDQUF2QixFQUEwQjtBQUMvQixTQUFRLEtBQUssS0FBSyxNQUFMLEtBQWdCLEdBQXJCLENBQVI7QUFDRCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKipcbiAqIEBhdXRob3IgZG1hcmNvcyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9kbWFyY29zXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tXG4gKi9cblxuVEhSRUUuVlJDb250cm9scyA9IGZ1bmN0aW9uICggb2JqZWN0LCBvbkVycm9yICkge1xuXG5cdHZhciBzY29wZSA9IHRoaXM7XG5cblx0dmFyIHZyRGlzcGxheSwgdnJEaXNwbGF5cztcblxuXHR2YXIgc3RhbmRpbmdNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdHZhciBmcmFtZURhdGEgPSBudWxsO1xuXG5cdGlmICggJ1ZSRnJhbWVEYXRhJyBpbiB3aW5kb3cgKSB7XG5cblx0XHRmcmFtZURhdGEgPSBuZXcgVlJGcmFtZURhdGEoKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ290VlJEaXNwbGF5cyggZGlzcGxheXMgKSB7XG5cblx0XHR2ckRpc3BsYXlzID0gZGlzcGxheXM7XG5cblx0XHRpZiAoIGRpc3BsYXlzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdHZyRGlzcGxheSA9IGRpc3BsYXlzWyAwIF07XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCAnVlIgaW5wdXQgbm90IGF2YWlsYWJsZS4nICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGlmICggbmF2aWdhdG9yLmdldFZSRGlzcGxheXMgKSB7XG5cblx0XHRuYXZpZ2F0b3IuZ2V0VlJEaXNwbGF5cygpLnRoZW4oIGdvdFZSRGlzcGxheXMgKS5jYXRjaCAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJDb250cm9sczogVW5hYmxlIHRvIGdldCBWUiBEaXNwbGF5cycgKTtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0Ly8gdGhlIFJpZnQgU0RLIHJldHVybnMgdGhlIHBvc2l0aW9uIGluIG1ldGVyc1xuXHQvLyB0aGlzIHNjYWxlIGZhY3RvciBhbGxvd3MgdGhlIHVzZXIgdG8gZGVmaW5lIGhvdyBtZXRlcnNcblx0Ly8gYXJlIGNvbnZlcnRlZCB0byBzY2VuZSB1bml0cy5cblxuXHR0aGlzLnNjYWxlID0gMTtcblxuXHQvLyBJZiB0cnVlIHdpbGwgdXNlIFwic3RhbmRpbmcgc3BhY2VcIiBjb29yZGluYXRlIHN5c3RlbSB3aGVyZSB5PTAgaXMgdGhlXG5cdC8vIGZsb29yIGFuZCB4PTAsIHo9MCBpcyB0aGUgY2VudGVyIG9mIHRoZSByb29tLlxuXHR0aGlzLnN0YW5kaW5nID0gZmFsc2U7XG5cblx0Ly8gRGlzdGFuY2UgZnJvbSB0aGUgdXNlcnMgZXllcyB0byB0aGUgZmxvb3IgaW4gbWV0ZXJzLiBVc2VkIHdoZW5cblx0Ly8gc3RhbmRpbmc9dHJ1ZSBidXQgdGhlIFZSRGlzcGxheSBkb2Vzbid0IHByb3ZpZGUgc3RhZ2VQYXJhbWV0ZXJzLlxuXHR0aGlzLnVzZXJIZWlnaHQgPSAxLjY7XG5cblx0dGhpcy5nZXRWUkRpc3BsYXkgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdnJEaXNwbGF5O1xuXG5cdH07XG5cblx0dGhpcy5zZXRWUkRpc3BsYXkgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dnJEaXNwbGF5ID0gdmFsdWU7XG5cblx0fTtcblxuXHR0aGlzLmdldFZSRGlzcGxheXMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUkNvbnRyb2xzOiBnZXRWUkRpc3BsYXlzKCkgaXMgYmVpbmcgZGVwcmVjYXRlZC4nICk7XG5cdFx0cmV0dXJuIHZyRGlzcGxheXM7XG5cblx0fTtcblxuXHR0aGlzLmdldFN0YW5kaW5nTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHN0YW5kaW5nTWF0cml4O1xuXG5cdH07XG5cblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoIHZyRGlzcGxheSApIHtcblxuXHRcdFx0dmFyIHBvc2U7XG5cblx0XHRcdGlmICggdnJEaXNwbGF5LmdldEZyYW1lRGF0YSApIHtcblxuXHRcdFx0XHR2ckRpc3BsYXkuZ2V0RnJhbWVEYXRhKCBmcmFtZURhdGEgKTtcblx0XHRcdFx0cG9zZSA9IGZyYW1lRGF0YS5wb3NlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB2ckRpc3BsYXkuZ2V0UG9zZSApIHtcblxuXHRcdFx0XHRwb3NlID0gdnJEaXNwbGF5LmdldFBvc2UoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHBvc2Uub3JpZW50YXRpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0b2JqZWN0LnF1YXRlcm5pb24uZnJvbUFycmF5KCBwb3NlLm9yaWVudGF0aW9uICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwb3NlLnBvc2l0aW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdG9iamVjdC5wb3NpdGlvbi5mcm9tQXJyYXkoIHBvc2UucG9zaXRpb24gKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRvYmplY3QucG9zaXRpb24uc2V0KCAwLCAwLCAwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLnN0YW5kaW5nICkge1xuXG5cdFx0XHRcdGlmICggdnJEaXNwbGF5LnN0YWdlUGFyYW1ldGVycyApIHtcblxuXHRcdFx0XHRcdG9iamVjdC51cGRhdGVNYXRyaXgoKTtcblxuXHRcdFx0XHRcdHN0YW5kaW5nTWF0cml4LmZyb21BcnJheSggdnJEaXNwbGF5LnN0YWdlUGFyYW1ldGVycy5zaXR0aW5nVG9TdGFuZGluZ1RyYW5zZm9ybSApO1xuXHRcdFx0XHRcdG9iamVjdC5hcHBseU1hdHJpeCggc3RhbmRpbmdNYXRyaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0b2JqZWN0LnBvc2l0aW9uLnNldFkoIG9iamVjdC5wb3NpdGlvbi55ICsgdGhpcy51c2VySGVpZ2h0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdC5wb3NpdGlvbi5tdWx0aXBseVNjYWxhciggc2NvcGUuc2NhbGUgKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMucmVzZXRQb3NlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0aWYgKCB2ckRpc3BsYXkgKSB7XG5cblx0XHRcdHZyRGlzcGxheS5yZXNldFBvc2UoKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMucmVzZXRTZW5zb3IgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUkNvbnRyb2xzOiAucmVzZXRTZW5zb3IoKSBpcyBub3cgLnJlc2V0UG9zZSgpLicgKTtcblx0XHR0aGlzLnJlc2V0UG9zZSgpO1xuXG5cdH07XG5cblx0dGhpcy56ZXJvU2Vuc29yID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJDb250cm9sczogLnplcm9TZW5zb3IoKSBpcyBub3cgLnJlc2V0UG9zZSgpLicgKTtcblx0XHR0aGlzLnJlc2V0UG9zZSgpO1xuXG5cdH07XG5cblx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dnJEaXNwbGF5ID0gbnVsbDtcblxuXHR9O1xuXG59O1xuIiwiLyoqXG4gKiBAYXV0aG9yIGRtYXJjb3MgLyBodHRwczovL2dpdGh1Yi5jb20vZG1hcmNvc1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbVxuICpcbiAqIFdlYlZSIFNwZWM6IGh0dHA6Ly9tb3p2ci5naXRodWIuaW8vd2VidnItc3BlYy93ZWJ2ci5odG1sXG4gKlxuICogRmlyZWZveDogaHR0cDovL21venZyLmNvbS9kb3dubG9hZHMvXG4gKiBDaHJvbWl1bTogaHR0cHM6Ly93ZWJ2ci5pbmZvL2dldC1jaHJvbWVcbiAqXG4gKi9cblxuVEhSRUUuVlJFZmZlY3QgPSBmdW5jdGlvbiggcmVuZGVyZXIsIG9uRXJyb3IgKSB7XG5cblx0dmFyIHZyRGlzcGxheSwgdnJEaXNwbGF5cztcblx0dmFyIGV5ZVRyYW5zbGF0aW9uTCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciBleWVUcmFuc2xhdGlvblIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgcmVuZGVyUmVjdEwsIHJlbmRlclJlY3RSO1xuXG5cdHZhciBmcmFtZURhdGEgPSBudWxsO1xuXG5cdGlmICggJ1ZSRnJhbWVEYXRhJyBpbiB3aW5kb3cgKSB7XG5cblx0XHRmcmFtZURhdGEgPSBuZXcgd2luZG93LlZSRnJhbWVEYXRhKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdvdFZSRGlzcGxheXMoIGRpc3BsYXlzICkge1xuXG5cdFx0dnJEaXNwbGF5cyA9IGRpc3BsYXlzO1xuXG5cdFx0aWYgKCBkaXNwbGF5cy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHR2ckRpc3BsYXkgPSBkaXNwbGF5c1sgMCBdO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggJ0hNRCBub3QgYXZhaWxhYmxlJyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRpZiAoIG5hdmlnYXRvci5nZXRWUkRpc3BsYXlzICkge1xuXG5cdFx0bmF2aWdhdG9yLmdldFZSRGlzcGxheXMoKS50aGVuKCBnb3RWUkRpc3BsYXlzICkuY2F0Y2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUkVmZmVjdDogVW5hYmxlIHRvIGdldCBWUiBEaXNwbGF5cycgKTtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0Ly9cblxuXHR0aGlzLmlzUHJlc2VudGluZyA9IGZhbHNlO1xuXHR0aGlzLnNjYWxlID0gMTtcblxuXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdHZhciByZW5kZXJlclNpemUgPSByZW5kZXJlci5nZXRTaXplKCk7XG5cdHZhciByZW5kZXJlclVwZGF0ZVN0eWxlID0gZmFsc2U7XG5cdHZhciByZW5kZXJlclBpeGVsUmF0aW8gPSByZW5kZXJlci5nZXRQaXhlbFJhdGlvKCk7XG5cblx0dGhpcy5nZXRWUkRpc3BsYXkgPSBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiB2ckRpc3BsYXk7XG5cblx0fTtcblxuXHR0aGlzLnNldFZSRGlzcGxheSA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblxuXHRcdHZyRGlzcGxheSA9IHZhbHVlO1xuXG5cdH07XG5cblx0dGhpcy5nZXRWUkRpc3BsYXlzID0gZnVuY3Rpb24oKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUkVmZmVjdDogZ2V0VlJEaXNwbGF5cygpIGlzIGJlaW5nIGRlcHJlY2F0ZWQuJyApO1xuXHRcdHJldHVybiB2ckRpc3BsYXlzO1xuXG5cdH07XG5cblx0dGhpcy5zZXRTaXplID0gZnVuY3Rpb24oIHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlICkge1xuXG5cdFx0cmVuZGVyZXJTaXplID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG5cdFx0cmVuZGVyZXJVcGRhdGVTdHlsZSA9IHVwZGF0ZVN0eWxlO1xuXG5cdFx0aWYgKCBzY29wZS5pc1ByZXNlbnRpbmcgKSB7XG5cblx0XHRcdHZhciBleWVQYXJhbXNMID0gdnJEaXNwbGF5LmdldEV5ZVBhcmFtZXRlcnMoICdsZWZ0JyApO1xuXHRcdFx0cmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyggMSApO1xuXHRcdFx0cmVuZGVyZXIuc2V0U2l6ZSggZXllUGFyYW1zTC5yZW5kZXJXaWR0aCAqIDIsIGV5ZVBhcmFtc0wucmVuZGVySGVpZ2h0LCBmYWxzZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyggcmVuZGVyZXJQaXhlbFJhdGlvICk7XG5cdFx0XHRyZW5kZXJlci5zZXRTaXplKCB3aWR0aCwgaGVpZ2h0LCB1cGRhdGVTdHlsZSApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gVlIgcHJlc2VudGF0aW9uXG5cblx0dmFyIGNhbnZhcyA9IHJlbmRlcmVyLmRvbUVsZW1lbnQ7XG5cdHZhciBkZWZhdWx0TGVmdEJvdW5kcyA9IFsgMC4wLCAwLjAsIDAuNSwgMS4wIF07XG5cdHZhciBkZWZhdWx0UmlnaHRCb3VuZHMgPSBbIDAuNSwgMC4wLCAwLjUsIDEuMCBdO1xuXG5cdGZ1bmN0aW9uIG9uVlJEaXNwbGF5UHJlc2VudENoYW5nZSgpIHtcblxuXHRcdHZhciB3YXNQcmVzZW50aW5nID0gc2NvcGUuaXNQcmVzZW50aW5nO1xuXHRcdHNjb3BlLmlzUHJlc2VudGluZyA9IHZyRGlzcGxheSAhPT0gdW5kZWZpbmVkICYmIHZyRGlzcGxheS5pc1ByZXNlbnRpbmc7XG5cblx0XHRpZiAoIHNjb3BlLmlzUHJlc2VudGluZyApIHtcblxuXHRcdFx0dmFyIGV5ZVBhcmFtc0wgPSB2ckRpc3BsYXkuZ2V0RXllUGFyYW1ldGVycyggJ2xlZnQnICk7XG5cdFx0XHR2YXIgZXllV2lkdGggPSBleWVQYXJhbXNMLnJlbmRlcldpZHRoO1xuXHRcdFx0dmFyIGV5ZUhlaWdodCA9IGV5ZVBhcmFtc0wucmVuZGVySGVpZ2h0O1xuXG5cdFx0XHRpZiAoICEgd2FzUHJlc2VudGluZyApIHtcblxuXHRcdFx0XHRyZW5kZXJlclBpeGVsUmF0aW8gPSByZW5kZXJlci5nZXRQaXhlbFJhdGlvKCk7XG5cdFx0XHRcdHJlbmRlcmVyU2l6ZSA9IHJlbmRlcmVyLmdldFNpemUoKTtcblxuXHRcdFx0XHRyZW5kZXJlci5zZXRQaXhlbFJhdGlvKCAxICk7XG5cdFx0XHRcdHJlbmRlcmVyLnNldFNpemUoIGV5ZVdpZHRoICogMiwgZXllSGVpZ2h0LCBmYWxzZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCB3YXNQcmVzZW50aW5nICkge1xuXG5cdFx0XHRyZW5kZXJlci5zZXRQaXhlbFJhdGlvKCByZW5kZXJlclBpeGVsUmF0aW8gKTtcblx0XHRcdHJlbmRlcmVyLnNldFNpemUoIHJlbmRlcmVyU2l6ZS53aWR0aCwgcmVuZGVyZXJTaXplLmhlaWdodCwgcmVuZGVyZXJVcGRhdGVTdHlsZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3ZyZGlzcGxheXByZXNlbnRjaGFuZ2UnLCBvblZSRGlzcGxheVByZXNlbnRDaGFuZ2UsIGZhbHNlICk7XG5cblx0dGhpcy5zZXRGdWxsU2NyZWVuID0gZnVuY3Rpb24oIGJvb2xlYW4gKSB7XG5cblx0XHRyZXR1cm4gbmV3IFByb21pc2UoIGZ1bmN0aW9uKCByZXNvbHZlLCByZWplY3QgKSB7XG5cblx0XHRcdGlmICggdnJEaXNwbGF5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmVqZWN0KCBuZXcgRXJyb3IoICdObyBWUiBoYXJkd2FyZSBmb3VuZC4nICkgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggc2NvcGUuaXNQcmVzZW50aW5nID09PSBib29sZWFuICkge1xuXG5cdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYm9vbGVhbiApIHtcblxuXHRcdFx0XHRyZXNvbHZlKCB2ckRpc3BsYXkucmVxdWVzdFByZXNlbnQoIFsgeyBzb3VyY2U6IGNhbnZhcyB9IF0gKSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJlc29sdmUoIHZyRGlzcGxheS5leGl0UHJlc2VudCgpICk7XG5cblx0XHRcdH1cblxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdHRoaXMucmVxdWVzdFByZXNlbnQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZ1bGxTY3JlZW4oIHRydWUgKTtcblxuXHR9O1xuXG5cdHRoaXMuZXhpdFByZXNlbnQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZ1bGxTY3JlZW4oIGZhbHNlICk7XG5cblx0fTtcblxuXHR0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKCBmICkge1xuXG5cdFx0aWYgKCB2ckRpc3BsYXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cmV0dXJuIHZyRGlzcGxheS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGYgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBmICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oIGggKSB7XG5cblx0XHRpZiAoIHZyRGlzcGxheSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2ckRpc3BsYXkuY2FuY2VsQW5pbWF0aW9uRnJhbWUoIGggKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSggaCApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5zdWJtaXRGcmFtZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0aWYgKCB2ckRpc3BsYXkgIT09IHVuZGVmaW5lZCAmJiBzY29wZS5pc1ByZXNlbnRpbmcgKSB7XG5cblx0XHRcdHZyRGlzcGxheS5zdWJtaXRGcmFtZSgpO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5hdXRvU3VibWl0RnJhbWUgPSB0cnVlO1xuXG5cdC8vIHJlbmRlclxuXG5cdHZhciBjYW1lcmFMID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCk7XG5cdGNhbWVyYUwubGF5ZXJzLmVuYWJsZSggMSApO1xuXG5cdHZhciBjYW1lcmFSID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCk7XG5cdGNhbWVyYVIubGF5ZXJzLmVuYWJsZSggMiApO1xuXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24oIHNjZW5lLCBjYW1lcmEsIHJlbmRlclRhcmdldCwgZm9yY2VDbGVhciApIHtcblxuXHRcdGlmICggdnJEaXNwbGF5ICYmIHNjb3BlLmlzUHJlc2VudGluZyApIHtcblxuXHRcdFx0dmFyIGF1dG9VcGRhdGUgPSBzY2VuZS5hdXRvVXBkYXRlO1xuXG5cdFx0XHRpZiAoIGF1dG9VcGRhdGUgKSB7XG5cblx0XHRcdFx0c2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcblx0XHRcdFx0c2NlbmUuYXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBleWVQYXJhbXNMID0gdnJEaXNwbGF5LmdldEV5ZVBhcmFtZXRlcnMoICdsZWZ0JyApO1xuXHRcdFx0dmFyIGV5ZVBhcmFtc1IgPSB2ckRpc3BsYXkuZ2V0RXllUGFyYW1ldGVycyggJ3JpZ2h0JyApO1xuXG5cdFx0XHRleWVUcmFuc2xhdGlvbkwuZnJvbUFycmF5KCBleWVQYXJhbXNMLm9mZnNldCApO1xuXHRcdFx0ZXllVHJhbnNsYXRpb25SLmZyb21BcnJheSggZXllUGFyYW1zUi5vZmZzZXQgKTtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBzY2VuZSApICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSRWZmZWN0LnJlbmRlcigpIG5vIGxvbmdlciBzdXBwb3J0cyBhcnJheXMuIFVzZSBvYmplY3QubGF5ZXJzIGluc3RlYWQuJyApO1xuXHRcdFx0XHRzY2VuZSA9IHNjZW5lWyAwIF07XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gV2hlbiByZW5kZXJpbmcgd2UgZG9uJ3QgY2FyZSB3aGF0IHRoZSByZWNvbW1lbmRlZCBzaXplIGlzLCBvbmx5IHdoYXQgdGhlIGFjdHVhbCBzaXplXG5cdFx0XHQvLyBvZiB0aGUgYmFja2J1ZmZlciBpcy5cblx0XHRcdHZhciBzaXplID0gcmVuZGVyZXIuZ2V0U2l6ZSgpO1xuXHRcdFx0dmFyIGxheWVycyA9IHZyRGlzcGxheS5nZXRMYXllcnMoKTtcblx0XHRcdHZhciBsZWZ0Qm91bmRzO1xuXHRcdFx0dmFyIHJpZ2h0Qm91bmRzO1xuXG5cdFx0XHRpZiAoIGxheWVycy5sZW5ndGggKSB7XG5cblx0XHRcdFx0dmFyIGxheWVyID0gbGF5ZXJzWyAwIF07XG5cblx0XHRcdFx0bGVmdEJvdW5kcyA9IGxheWVyLmxlZnRCb3VuZHMgIT09IG51bGwgJiYgbGF5ZXIubGVmdEJvdW5kcy5sZW5ndGggPT09IDQgPyBsYXllci5sZWZ0Qm91bmRzIDogZGVmYXVsdExlZnRCb3VuZHM7XG5cdFx0XHRcdHJpZ2h0Qm91bmRzID0gbGF5ZXIucmlnaHRCb3VuZHMgIT09IG51bGwgJiYgbGF5ZXIucmlnaHRCb3VuZHMubGVuZ3RoID09PSA0ID8gbGF5ZXIucmlnaHRCb3VuZHMgOiBkZWZhdWx0UmlnaHRCb3VuZHM7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bGVmdEJvdW5kcyA9IGRlZmF1bHRMZWZ0Qm91bmRzO1xuXHRcdFx0XHRyaWdodEJvdW5kcyA9IGRlZmF1bHRSaWdodEJvdW5kcztcblxuXHRcdFx0fVxuXG5cdFx0XHRyZW5kZXJSZWN0TCA9IHtcblx0XHRcdFx0eDogTWF0aC5yb3VuZCggc2l6ZS53aWR0aCAqIGxlZnRCb3VuZHNbIDAgXSApLFxuXHRcdFx0XHR5OiBNYXRoLnJvdW5kKCBzaXplLmhlaWdodCAqIGxlZnRCb3VuZHNbIDEgXSApLFxuXHRcdFx0XHR3aWR0aDogTWF0aC5yb3VuZCggc2l6ZS53aWR0aCAqIGxlZnRCb3VuZHNbIDIgXSApLFxuXHRcdFx0XHRoZWlnaHQ6IE1hdGgucm91bmQoIHNpemUuaGVpZ2h0ICogbGVmdEJvdW5kc1sgMyBdIClcblx0XHRcdH07XG5cdFx0XHRyZW5kZXJSZWN0UiA9IHtcblx0XHRcdFx0eDogTWF0aC5yb3VuZCggc2l6ZS53aWR0aCAqIHJpZ2h0Qm91bmRzWyAwIF0gKSxcblx0XHRcdFx0eTogTWF0aC5yb3VuZCggc2l6ZS5oZWlnaHQgKiByaWdodEJvdW5kc1sgMSBdICksXG5cdFx0XHRcdHdpZHRoOiBNYXRoLnJvdW5kKCBzaXplLndpZHRoICogcmlnaHRCb3VuZHNbIDIgXSApLFxuXHRcdFx0XHRoZWlnaHQ6IE1hdGgucm91bmQoIHNpemUuaGVpZ2h0ICogcmlnaHRCb3VuZHNbIDMgXSApXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xuXHRcdFx0XHRyZW5kZXJUYXJnZXQuc2Npc3NvclRlc3QgPSB0cnVlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggbnVsbCApO1xuXHRcdFx0XHRyZW5kZXJlci5zZXRTY2lzc29yVGVzdCggdHJ1ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcmVuZGVyZXIuYXV0b0NsZWFyIHx8IGZvcmNlQ2xlYXIgKSByZW5kZXJlci5jbGVhcigpO1xuXG5cdFx0XHRpZiAoIGNhbWVyYS5wYXJlbnQgPT09IG51bGwgKSBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdFx0Y2FtZXJhLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggY2FtZXJhTC5wb3NpdGlvbiwgY2FtZXJhTC5xdWF0ZXJuaW9uLCBjYW1lcmFMLnNjYWxlICk7XG5cdFx0XHRjYW1lcmEubWF0cml4V29ybGQuZGVjb21wb3NlKCBjYW1lcmFSLnBvc2l0aW9uLCBjYW1lcmFSLnF1YXRlcm5pb24sIGNhbWVyYVIuc2NhbGUgKTtcblxuXHRcdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcblx0XHRcdGNhbWVyYUwudHJhbnNsYXRlT25BeGlzKCBleWVUcmFuc2xhdGlvbkwsIHNjYWxlICk7XG5cdFx0XHRjYW1lcmFSLnRyYW5zbGF0ZU9uQXhpcyggZXllVHJhbnNsYXRpb25SLCBzY2FsZSApO1xuXG5cdFx0XHRpZiAoIHZyRGlzcGxheS5nZXRGcmFtZURhdGEgKSB7XG5cblx0XHRcdFx0dnJEaXNwbGF5LmRlcHRoTmVhciA9IGNhbWVyYS5uZWFyO1xuXHRcdFx0XHR2ckRpc3BsYXkuZGVwdGhGYXIgPSBjYW1lcmEuZmFyO1xuXG5cdFx0XHRcdHZyRGlzcGxheS5nZXRGcmFtZURhdGEoIGZyYW1lRGF0YSApO1xuXG5cdFx0XHRcdGNhbWVyYUwucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cyA9IGZyYW1lRGF0YS5sZWZ0UHJvamVjdGlvbk1hdHJpeDtcblx0XHRcdFx0Y2FtZXJhUi5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzID0gZnJhbWVEYXRhLnJpZ2h0UHJvamVjdGlvbk1hdHJpeDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjYW1lcmFMLnByb2plY3Rpb25NYXRyaXggPSBmb3ZUb1Byb2plY3Rpb24oIGV5ZVBhcmFtc0wuZmllbGRPZlZpZXcsIHRydWUsIGNhbWVyYS5uZWFyLCBjYW1lcmEuZmFyICk7XG5cdFx0XHRcdGNhbWVyYVIucHJvamVjdGlvbk1hdHJpeCA9IGZvdlRvUHJvamVjdGlvbiggZXllUGFyYW1zUi5maWVsZE9mVmlldywgdHJ1ZSwgY2FtZXJhLm5lYXIsIGNhbWVyYS5mYXIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZW5kZXIgbGVmdCBleWVcblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0XHRcdHJlbmRlclRhcmdldC52aWV3cG9ydC5zZXQoIHJlbmRlclJlY3RMLngsIHJlbmRlclJlY3RMLnksIHJlbmRlclJlY3RMLndpZHRoLCByZW5kZXJSZWN0TC5oZWlnaHQgKTtcblx0XHRcdFx0cmVuZGVyVGFyZ2V0LnNjaXNzb3Iuc2V0KCByZW5kZXJSZWN0TC54LCByZW5kZXJSZWN0TC55LCByZW5kZXJSZWN0TC53aWR0aCwgcmVuZGVyUmVjdEwuaGVpZ2h0ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmVuZGVyZXIuc2V0Vmlld3BvcnQoIHJlbmRlclJlY3RMLngsIHJlbmRlclJlY3RMLnksIHJlbmRlclJlY3RMLndpZHRoLCByZW5kZXJSZWN0TC5oZWlnaHQgKTtcblx0XHRcdFx0cmVuZGVyZXIuc2V0U2Npc3NvciggcmVuZGVyUmVjdEwueCwgcmVuZGVyUmVjdEwueSwgcmVuZGVyUmVjdEwud2lkdGgsIHJlbmRlclJlY3RMLmhlaWdodCApO1xuXG5cdFx0XHR9XG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFMLCByZW5kZXJUYXJnZXQsIGZvcmNlQ2xlYXIgKTtcblxuXHRcdFx0Ly8gcmVuZGVyIHJpZ2h0IGV5ZVxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdFx0cmVuZGVyVGFyZ2V0LnZpZXdwb3J0LnNldCggcmVuZGVyUmVjdFIueCwgcmVuZGVyUmVjdFIueSwgcmVuZGVyUmVjdFIud2lkdGgsIHJlbmRlclJlY3RSLmhlaWdodCApO1xuXHRcdFx0XHRyZW5kZXJUYXJnZXQuc2Npc3Nvci5zZXQoIHJlbmRlclJlY3RSLngsIHJlbmRlclJlY3RSLnksIHJlbmRlclJlY3RSLndpZHRoLCByZW5kZXJSZWN0Ui5oZWlnaHQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZW5kZXJlci5zZXRWaWV3cG9ydCggcmVuZGVyUmVjdFIueCwgcmVuZGVyUmVjdFIueSwgcmVuZGVyUmVjdFIud2lkdGgsIHJlbmRlclJlY3RSLmhlaWdodCApO1xuXHRcdFx0XHRyZW5kZXJlci5zZXRTY2lzc29yKCByZW5kZXJSZWN0Ui54LCByZW5kZXJSZWN0Ui55LCByZW5kZXJSZWN0Ui53aWR0aCwgcmVuZGVyUmVjdFIuaGVpZ2h0ICk7XG5cblx0XHRcdH1cblx0XHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVIsIHJlbmRlclRhcmdldCwgZm9yY2VDbGVhciApO1xuXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0XHRyZW5kZXJUYXJnZXQudmlld3BvcnQuc2V0KCAwLCAwLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCApO1xuXHRcdFx0XHRyZW5kZXJUYXJnZXQuc2Npc3Nvci5zZXQoIDAsIDAsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0ICk7XG5cdFx0XHRcdHJlbmRlclRhcmdldC5zY2lzc29yVGVzdCA9IGZhbHNlO1xuXHRcdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIG51bGwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZW5kZXJlci5zZXRWaWV3cG9ydCggMCwgMCwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQgKTtcblx0XHRcdFx0cmVuZGVyZXIuc2V0U2Npc3NvclRlc3QoIGZhbHNlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBhdXRvVXBkYXRlICkge1xuXG5cdFx0XHRcdHNjZW5lLmF1dG9VcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggc2NvcGUuYXV0b1N1Ym1pdEZyYW1lICkge1xuXG5cdFx0XHRcdHNjb3BlLnN1Ym1pdEZyYW1lKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0Ly8gUmVndWxhciByZW5kZXIgbW9kZSBpZiBub3QgSE1EXG5cblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmEsIHJlbmRlclRhcmdldCwgZm9yY2VDbGVhciApO1xuXG5cdH07XG5cblx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3ZyZGlzcGxheXByZXNlbnRjaGFuZ2UnLCBvblZSRGlzcGxheVByZXNlbnRDaGFuZ2UsIGZhbHNlICk7XG5cblx0fTtcblxuXHQvL1xuXG5cdGZ1bmN0aW9uIGZvdlRvTkRDU2NhbGVPZmZzZXQoIGZvdiApIHtcblxuXHRcdHZhciBweHNjYWxlID0gMi4wIC8gKCBmb3YubGVmdFRhbiArIGZvdi5yaWdodFRhbiApO1xuXHRcdHZhciBweG9mZnNldCA9ICggZm92LmxlZnRUYW4gLSBmb3YucmlnaHRUYW4gKSAqIHB4c2NhbGUgKiAwLjU7XG5cdFx0dmFyIHB5c2NhbGUgPSAyLjAgLyAoIGZvdi51cFRhbiArIGZvdi5kb3duVGFuICk7XG5cdFx0dmFyIHB5b2Zmc2V0ID0gKCBmb3YudXBUYW4gLSBmb3YuZG93blRhbiApICogcHlzY2FsZSAqIDAuNTtcblx0XHRyZXR1cm4geyBzY2FsZTogWyBweHNjYWxlLCBweXNjYWxlIF0sIG9mZnNldDogWyBweG9mZnNldCwgcHlvZmZzZXQgXSB9O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBmb3ZQb3J0VG9Qcm9qZWN0aW9uKCBmb3YsIHJpZ2h0SGFuZGVkLCB6TmVhciwgekZhciApIHtcblxuXHRcdHJpZ2h0SGFuZGVkID0gcmlnaHRIYW5kZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiByaWdodEhhbmRlZDtcblx0XHR6TmVhciA9IHpOZWFyID09PSB1bmRlZmluZWQgPyAwLjAxIDogek5lYXI7XG5cdFx0ekZhciA9IHpGYXIgPT09IHVuZGVmaW5lZCA/IDEwMDAwLjAgOiB6RmFyO1xuXG5cdFx0dmFyIGhhbmRlZG5lc3NTY2FsZSA9IHJpZ2h0SGFuZGVkID8gLSAxLjAgOiAxLjA7XG5cblx0XHQvLyBzdGFydCB3aXRoIGFuIGlkZW50aXR5IG1hdHJpeFxuXHRcdHZhciBtb2JqID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblx0XHR2YXIgbSA9IG1vYmouZWxlbWVudHM7XG5cblx0XHQvLyBhbmQgd2l0aCBzY2FsZS9vZmZzZXQgaW5mbyBmb3Igbm9ybWFsaXplZCBkZXZpY2UgY29vcmRzXG5cdFx0dmFyIHNjYWxlQW5kT2Zmc2V0ID0gZm92VG9ORENTY2FsZU9mZnNldCggZm92ICk7XG5cblx0XHQvLyBYIHJlc3VsdCwgbWFwIGNsaXAgZWRnZXMgdG8gWy13LCt3XVxuXHRcdG1bIDAgKiA0ICsgMCBdID0gc2NhbGVBbmRPZmZzZXQuc2NhbGVbIDAgXTtcblx0XHRtWyAwICogNCArIDEgXSA9IDAuMDtcblx0XHRtWyAwICogNCArIDIgXSA9IHNjYWxlQW5kT2Zmc2V0Lm9mZnNldFsgMCBdICogaGFuZGVkbmVzc1NjYWxlO1xuXHRcdG1bIDAgKiA0ICsgMyBdID0gMC4wO1xuXG5cdFx0Ly8gWSByZXN1bHQsIG1hcCBjbGlwIGVkZ2VzIHRvIFstdywrd11cblx0XHQvLyBZIG9mZnNldCBpcyBuZWdhdGVkIGJlY2F1c2UgdGhpcyBwcm9qIG1hdHJpeCB0cmFuc2Zvcm1zIGZyb20gd29ybGQgY29vcmRzIHdpdGggWT11cCxcblx0XHQvLyBidXQgdGhlIE5EQyBzY2FsaW5nIGhhcyBZPWRvd24gKHRoYW5rcyBEM0Q/KVxuXHRcdG1bIDEgKiA0ICsgMCBdID0gMC4wO1xuXHRcdG1bIDEgKiA0ICsgMSBdID0gc2NhbGVBbmRPZmZzZXQuc2NhbGVbIDEgXTtcblx0XHRtWyAxICogNCArIDIgXSA9IC0gc2NhbGVBbmRPZmZzZXQub2Zmc2V0WyAxIF0gKiBoYW5kZWRuZXNzU2NhbGU7XG5cdFx0bVsgMSAqIDQgKyAzIF0gPSAwLjA7XG5cblx0XHQvLyBaIHJlc3VsdCAodXAgdG8gdGhlIGFwcClcblx0XHRtWyAyICogNCArIDAgXSA9IDAuMDtcblx0XHRtWyAyICogNCArIDEgXSA9IDAuMDtcblx0XHRtWyAyICogNCArIDIgXSA9IHpGYXIgLyAoIHpOZWFyIC0gekZhciApICogLSBoYW5kZWRuZXNzU2NhbGU7XG5cdFx0bVsgMiAqIDQgKyAzIF0gPSAoIHpGYXIgKiB6TmVhciApIC8gKCB6TmVhciAtIHpGYXIgKTtcblxuXHRcdC8vIFcgcmVzdWx0ICg9IFogaW4pXG5cdFx0bVsgMyAqIDQgKyAwIF0gPSAwLjA7XG5cdFx0bVsgMyAqIDQgKyAxIF0gPSAwLjA7XG5cdFx0bVsgMyAqIDQgKyAyIF0gPSBoYW5kZWRuZXNzU2NhbGU7XG5cdFx0bVsgMyAqIDQgKyAzIF0gPSAwLjA7XG5cblx0XHRtb2JqLnRyYW5zcG9zZSgpO1xuXG5cdFx0cmV0dXJuIG1vYmo7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGZvdlRvUHJvamVjdGlvbiggZm92LCByaWdodEhhbmRlZCwgek5lYXIsIHpGYXIgKSB7XG5cblx0XHR2YXIgREVHMlJBRCA9IE1hdGguUEkgLyAxODAuMDtcblxuXHRcdHZhciBmb3ZQb3J0ID0ge1xuXHRcdFx0dXBUYW46IE1hdGgudGFuKCBmb3YudXBEZWdyZWVzICogREVHMlJBRCApLFxuXHRcdFx0ZG93blRhbjogTWF0aC50YW4oIGZvdi5kb3duRGVncmVlcyAqIERFRzJSQUQgKSxcblx0XHRcdGxlZnRUYW46IE1hdGgudGFuKCBmb3YubGVmdERlZ3JlZXMgKiBERUcyUkFEICksXG5cdFx0XHRyaWdodFRhbjogTWF0aC50YW4oIGZvdi5yaWdodERlZ3JlZXMgKiBERUcyUkFEIClcblx0XHR9O1xuXG5cdFx0cmV0dXJuIGZvdlBvcnRUb1Byb2plY3Rpb24oIGZvdlBvcnQsIHJpZ2h0SGFuZGVkLCB6TmVhciwgekZhciApO1xuXG5cdH1cblxufTtcbiIsIi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5PQkpMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cblx0dGhpcy5tYXRlcmlhbHMgPSBudWxsO1xuXG5cdHRoaXMucmVnZXhwID0ge1xuXHRcdC8vIHYgZmxvYXQgZmxvYXQgZmxvYXRcblx0XHR2ZXJ0ZXhfcGF0dGVybiAgICAgICAgICAgOiAvXnZcXHMrKFtcXGR8XFwufFxcK3xcXC18ZXxFXSspXFxzKyhbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKVxccysoW1xcZHxcXC58XFwrfFxcLXxlfEVdKykvLFxuXHRcdC8vIHZuIGZsb2F0IGZsb2F0IGZsb2F0XG5cdFx0bm9ybWFsX3BhdHRlcm4gICAgICAgICAgIDogL152blxccysoW1xcZHxcXC58XFwrfFxcLXxlfEVdKylcXHMrKFtcXGR8XFwufFxcK3xcXC18ZXxFXSspXFxzKyhbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKS8sXG5cdFx0Ly8gdnQgZmxvYXQgZmxvYXRcblx0XHR1dl9wYXR0ZXJuICAgICAgICAgICAgICAgOiAvXnZ0XFxzKyhbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKVxccysoW1xcZHxcXC58XFwrfFxcLXxlfEVdKykvLFxuXHRcdC8vIGYgdmVydGV4IHZlcnRleCB2ZXJ0ZXhcblx0XHRmYWNlX3ZlcnRleCAgICAgICAgICAgICAgOiAvXmZcXHMrKC0/XFxkKylcXHMrKC0/XFxkKylcXHMrKC0/XFxkKykoPzpcXHMrKC0/XFxkKykpPy8sXG5cdFx0Ly8gZiB2ZXJ0ZXgvdXYgdmVydGV4L3V2IHZlcnRleC91dlxuXHRcdGZhY2VfdmVydGV4X3V2ICAgICAgICAgICA6IC9eZlxccysoLT9cXGQrKVxcLygtP1xcZCspXFxzKygtP1xcZCspXFwvKC0/XFxkKylcXHMrKC0/XFxkKylcXC8oLT9cXGQrKSg/OlxccysoLT9cXGQrKVxcLygtP1xcZCspKT8vLFxuXHRcdC8vIGYgdmVydGV4L3V2L25vcm1hbCB2ZXJ0ZXgvdXYvbm9ybWFsIHZlcnRleC91di9ub3JtYWxcblx0XHRmYWNlX3ZlcnRleF91dl9ub3JtYWwgICAgOiAvXmZcXHMrKC0/XFxkKylcXC8oLT9cXGQrKVxcLygtP1xcZCspXFxzKygtP1xcZCspXFwvKC0/XFxkKylcXC8oLT9cXGQrKVxccysoLT9cXGQrKVxcLygtP1xcZCspXFwvKC0/XFxkKykoPzpcXHMrKC0/XFxkKylcXC8oLT9cXGQrKVxcLygtP1xcZCspKT8vLFxuXHRcdC8vIGYgdmVydGV4Ly9ub3JtYWwgdmVydGV4Ly9ub3JtYWwgdmVydGV4Ly9ub3JtYWxcblx0XHRmYWNlX3ZlcnRleF9ub3JtYWwgICAgICAgOiAvXmZcXHMrKC0/XFxkKylcXC9cXC8oLT9cXGQrKVxccysoLT9cXGQrKVxcL1xcLygtP1xcZCspXFxzKygtP1xcZCspXFwvXFwvKC0/XFxkKykoPzpcXHMrKC0/XFxkKylcXC9cXC8oLT9cXGQrKSk/Lyxcblx0XHQvLyBvIG9iamVjdF9uYW1lIHwgZyBncm91cF9uYW1lXG5cdFx0b2JqZWN0X3BhdHRlcm4gICAgICAgICAgIDogL15bb2ddXFxzKiguKyk/Lyxcblx0XHQvLyBzIGJvb2xlYW5cblx0XHRzbW9vdGhpbmdfcGF0dGVybiAgICAgICAgOiAvXnNcXHMrKFxcZCt8b258b2ZmKS8sXG5cdFx0Ly8gbXRsbGliIGZpbGVfcmVmZXJlbmNlXG5cdFx0bWF0ZXJpYWxfbGlicmFyeV9wYXR0ZXJuIDogL15tdGxsaWIgLyxcblx0XHQvLyB1c2VtdGwgbWF0ZXJpYWxfbmFtZVxuXHRcdG1hdGVyaWFsX3VzZV9wYXR0ZXJuICAgICA6IC9edXNlbXRsIC9cblx0fTtcblxufTtcblxuVEhSRUUuT0JKTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuT0JKTG9hZGVyLFxuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5GaWxlTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggdGV4dCApICk7XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0fSxcblxuXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5wYXRoID0gdmFsdWU7XG5cblx0fSxcblxuXHRzZXRNYXRlcmlhbHM6IGZ1bmN0aW9uICggbWF0ZXJpYWxzICkge1xuXG5cdFx0dGhpcy5tYXRlcmlhbHMgPSBtYXRlcmlhbHM7XG5cblx0fSxcblxuXHRfY3JlYXRlUGFyc2VyU3RhdGUgOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgc3RhdGUgPSB7XG5cdFx0XHRvYmplY3RzICA6IFtdLFxuXHRcdFx0b2JqZWN0ICAgOiB7fSxcblxuXHRcdFx0dmVydGljZXMgOiBbXSxcblx0XHRcdG5vcm1hbHMgIDogW10sXG5cdFx0XHR1dnMgICAgICA6IFtdLFxuXG5cdFx0XHRtYXRlcmlhbExpYnJhcmllcyA6IFtdLFxuXG5cdFx0XHRzdGFydE9iamVjdDogZnVuY3Rpb24gKCBuYW1lLCBmcm9tRGVjbGFyYXRpb24gKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGN1cnJlbnQgb2JqZWN0IChpbml0aWFsIGZyb20gcmVzZXQpIGlzIG5vdCBmcm9tIGEgZy9vIGRlY2xhcmF0aW9uIGluIHRoZSBwYXJzZWRcblx0XHRcdFx0Ly8gZmlsZS4gV2UgbmVlZCB0byB1c2UgaXQgZm9yIHRoZSBmaXJzdCBwYXJzZWQgZy9vIHRvIGtlZXAgdGhpbmdzIGluIHN5bmMuXG5cdFx0XHRcdGlmICggdGhpcy5vYmplY3QgJiYgdGhpcy5vYmplY3QuZnJvbURlY2xhcmF0aW9uID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdHRoaXMub2JqZWN0Lm5hbWUgPSBuYW1lO1xuXHRcdFx0XHRcdHRoaXMub2JqZWN0LmZyb21EZWNsYXJhdGlvbiA9ICggZnJvbURlY2xhcmF0aW9uICE9PSBmYWxzZSApO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHByZXZpb3VzTWF0ZXJpYWwgPSAoIHRoaXMub2JqZWN0ICYmIHR5cGVvZiB0aGlzLm9iamVjdC5jdXJyZW50TWF0ZXJpYWwgPT09ICdmdW5jdGlvbicgPyB0aGlzLm9iamVjdC5jdXJyZW50TWF0ZXJpYWwoKSA6IHVuZGVmaW5lZCApO1xuXG5cdFx0XHRcdGlmICggdGhpcy5vYmplY3QgJiYgdHlwZW9mIHRoaXMub2JqZWN0Ll9maW5hbGl6ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblxuXHRcdFx0XHRcdHRoaXMub2JqZWN0Ll9maW5hbGl6ZSggdHJ1ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLm9iamVjdCA9IHtcblx0XHRcdFx0XHRuYW1lIDogbmFtZSB8fCAnJyxcblx0XHRcdFx0XHRmcm9tRGVjbGFyYXRpb24gOiAoIGZyb21EZWNsYXJhdGlvbiAhPT0gZmFsc2UgKSxcblxuXHRcdFx0XHRcdGdlb21ldHJ5IDoge1xuXHRcdFx0XHRcdFx0dmVydGljZXMgOiBbXSxcblx0XHRcdFx0XHRcdG5vcm1hbHMgIDogW10sXG5cdFx0XHRcdFx0XHR1dnMgICAgICA6IFtdXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRtYXRlcmlhbHMgOiBbXSxcblx0XHRcdFx0XHRzbW9vdGggOiB0cnVlLFxuXG5cdFx0XHRcdFx0c3RhcnRNYXRlcmlhbCA6IGZ1bmN0aW9uKCBuYW1lLCBsaWJyYXJpZXMgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBwcmV2aW91cyA9IHRoaXMuX2ZpbmFsaXplKCBmYWxzZSApO1xuXG5cdFx0XHRcdFx0XHQvLyBOZXcgdXNlbXRsIGRlY2xhcmF0aW9uIG92ZXJ3cml0ZXMgYW4gaW5oZXJpdGVkIG1hdGVyaWFsLCBleGNlcHQgaWYgZmFjZXMgd2VyZSBkZWNsYXJlZFxuXHRcdFx0XHRcdFx0Ly8gYWZ0ZXIgdGhlIG1hdGVyaWFsLCB0aGVuIGl0IG11c3QgYmUgcHJlc2VydmVkIGZvciBwcm9wZXIgTXVsdGlNYXRlcmlhbCBjb250aW51YXRpb24uXG5cdFx0XHRcdFx0XHRpZiAoIHByZXZpb3VzICYmICggcHJldmlvdXMuaW5oZXJpdGVkIHx8IHByZXZpb3VzLmdyb3VwQ291bnQgPD0gMCApICkge1xuXG5cdFx0XHRcdFx0XHRcdHRoaXMubWF0ZXJpYWxzLnNwbGljZSggcHJldmlvdXMuaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSB7XG5cdFx0XHRcdFx0XHRcdGluZGV4ICAgICAgOiB0aGlzLm1hdGVyaWFscy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdG5hbWUgICAgICAgOiBuYW1lIHx8ICcnLFxuXHRcdFx0XHRcdFx0XHRtdGxsaWIgICAgIDogKCBBcnJheS5pc0FycmF5KCBsaWJyYXJpZXMgKSAmJiBsaWJyYXJpZXMubGVuZ3RoID4gMCA/IGxpYnJhcmllc1sgbGlicmFyaWVzLmxlbmd0aCAtIDEgXSA6ICcnICksXG5cdFx0XHRcdFx0XHRcdHNtb290aCAgICAgOiAoIHByZXZpb3VzICE9PSB1bmRlZmluZWQgPyBwcmV2aW91cy5zbW9vdGggOiB0aGlzLnNtb290aCApLFxuXHRcdFx0XHRcdFx0XHRncm91cFN0YXJ0IDogKCBwcmV2aW91cyAhPT0gdW5kZWZpbmVkID8gcHJldmlvdXMuZ3JvdXBFbmQgOiAwICksXG5cdFx0XHRcdFx0XHRcdGdyb3VwRW5kICAgOiAtMSxcblx0XHRcdFx0XHRcdFx0Z3JvdXBDb3VudCA6IC0xLFxuXHRcdFx0XHRcdFx0XHRpbmhlcml0ZWQgIDogZmFsc2UsXG5cblx0XHRcdFx0XHRcdFx0Y2xvbmUgOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGNsb25lZCA9IHtcblx0XHRcdFx0XHRcdFx0XHRcdGluZGV4ICAgICAgOiAoIHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicgPyBpbmRleCA6IHRoaXMuaW5kZXggKSxcblx0XHRcdFx0XHRcdFx0XHRcdG5hbWUgICAgICAgOiB0aGlzLm5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRtdGxsaWIgICAgIDogdGhpcy5tdGxsaWIsXG5cdFx0XHRcdFx0XHRcdFx0XHRzbW9vdGggICAgIDogdGhpcy5zbW9vdGgsXG5cdFx0XHRcdFx0XHRcdFx0XHRncm91cFN0YXJ0IDogMCxcblx0XHRcdFx0XHRcdFx0XHRcdGdyb3VwRW5kICAgOiAtMSxcblx0XHRcdFx0XHRcdFx0XHRcdGdyb3VwQ291bnQgOiAtMSxcblx0XHRcdFx0XHRcdFx0XHRcdGluaGVyaXRlZCAgOiBmYWxzZVxuXHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdFx0Y2xvbmVkLmNsb25lID0gdGhpcy5jbG9uZS5iaW5kKGNsb25lZCk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGNsb25lZDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0dGhpcy5tYXRlcmlhbHMucHVzaCggbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdGN1cnJlbnRNYXRlcmlhbCA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMubWF0ZXJpYWxzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbHMubGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdF9maW5hbGl6ZSA6IGZ1bmN0aW9uKCBlbmQgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBsYXN0TXVsdGlNYXRlcmlhbCA9IHRoaXMuY3VycmVudE1hdGVyaWFsKCk7XG5cdFx0XHRcdFx0XHRpZiAoIGxhc3RNdWx0aU1hdGVyaWFsICYmIGxhc3RNdWx0aU1hdGVyaWFsLmdyb3VwRW5kID09PSAtMSApIHtcblxuXHRcdFx0XHRcdFx0XHRsYXN0TXVsdGlNYXRlcmlhbC5ncm91cEVuZCA9IHRoaXMuZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoIC8gMztcblx0XHRcdFx0XHRcdFx0bGFzdE11bHRpTWF0ZXJpYWwuZ3JvdXBDb3VudCA9IGxhc3RNdWx0aU1hdGVyaWFsLmdyb3VwRW5kIC0gbGFzdE11bHRpTWF0ZXJpYWwuZ3JvdXBTdGFydDtcblx0XHRcdFx0XHRcdFx0bGFzdE11bHRpTWF0ZXJpYWwuaW5oZXJpdGVkID0gZmFsc2U7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSWdub3JlIG9iamVjdHMgdGFpbCBtYXRlcmlhbHMgaWYgbm8gZmFjZSBkZWNsYXJhdGlvbnMgZm9sbG93ZWQgdGhlbSBiZWZvcmUgYSBuZXcgby9nIHN0YXJ0ZWQuXG5cdFx0XHRcdFx0XHRpZiAoIGVuZCAmJiB0aGlzLm1hdGVyaWFscy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBtaSA9IHRoaXMubWF0ZXJpYWxzLmxlbmd0aCAtIDE7IG1pID49IDA7IG1pLS0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0aGlzLm1hdGVyaWFsc1ttaV0uZ3JvdXBDb3VudCA8PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5tYXRlcmlhbHMuc3BsaWNlKCBtaSwgMSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEd1YXJhbnRlZSBhdCBsZWFzdCBvbmUgZW1wdHkgbWF0ZXJpYWwsIHRoaXMgbWFrZXMgdGhlIGNyZWF0aW9uIGxhdGVyIG1vcmUgc3RyYWlnaHQgZm9yd2FyZC5cblx0XHRcdFx0XHRcdGlmICggZW5kICYmIHRoaXMubWF0ZXJpYWxzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0XHR0aGlzLm1hdGVyaWFscy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lICAgOiAnJyxcblx0XHRcdFx0XHRcdFx0XHRzbW9vdGggOiB0aGlzLnNtb290aFxuXHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gbGFzdE11bHRpTWF0ZXJpYWw7XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gSW5oZXJpdCBwcmV2aW91cyBvYmplY3RzIG1hdGVyaWFsLlxuXHRcdFx0XHQvLyBTcGVjIHRlbGxzIHVzIHRoYXQgYSBkZWNsYXJlZCBtYXRlcmlhbCBtdXN0IGJlIHNldCB0byBhbGwgb2JqZWN0cyB1bnRpbCBhIG5ldyBtYXRlcmlhbCBpcyBkZWNsYXJlZC5cblx0XHRcdFx0Ly8gSWYgYSB1c2VtdGwgZGVjbGFyYXRpb24gaXMgZW5jb3VudGVyZWQgd2hpbGUgdGhpcyBuZXcgb2JqZWN0IGlzIGJlaW5nIHBhcnNlZCwgaXQgd2lsbFxuXHRcdFx0XHQvLyBvdmVyd3JpdGUgdGhlIGluaGVyaXRlZCBtYXRlcmlhbC4gRXhjZXB0aW9uIGJlaW5nIHRoYXQgdGhlcmUgd2FzIGFscmVhZHkgZmFjZSBkZWNsYXJhdGlvbnNcblx0XHRcdFx0Ly8gdG8gdGhlIGluaGVyaXRlZCBtYXRlcmlhbCwgdGhlbiBpdCB3aWxsIGJlIHByZXNlcnZlZCBmb3IgcHJvcGVyIE11bHRpTWF0ZXJpYWwgY29udGludWF0aW9uLlxuXG5cdFx0XHRcdGlmICggcHJldmlvdXNNYXRlcmlhbCAmJiBwcmV2aW91c01hdGVyaWFsLm5hbWUgJiYgdHlwZW9mIHByZXZpb3VzTWF0ZXJpYWwuY2xvbmUgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0XHRcdHZhciBkZWNsYXJlZCA9IHByZXZpb3VzTWF0ZXJpYWwuY2xvbmUoIDAgKTtcblx0XHRcdFx0XHRkZWNsYXJlZC5pbmhlcml0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMub2JqZWN0Lm1hdGVyaWFscy5wdXNoKCBkZWNsYXJlZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLm9iamVjdHMucHVzaCggdGhpcy5vYmplY3QgKTtcblxuXHRcdFx0fSxcblxuXHRcdFx0ZmluYWxpemUgOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRpZiAoIHRoaXMub2JqZWN0ICYmIHR5cGVvZiB0aGlzLm9iamVjdC5fZmluYWxpemUgPT09ICdmdW5jdGlvbicgKSB7XG5cblx0XHRcdFx0XHR0aGlzLm9iamVjdC5fZmluYWxpemUoIHRydWUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHRcdHBhcnNlVmVydGV4SW5kZXg6IGZ1bmN0aW9uICggdmFsdWUsIGxlbiApIHtcblxuXHRcdFx0XHR2YXIgaW5kZXggPSBwYXJzZUludCggdmFsdWUsIDEwICk7XG5cdFx0XHRcdHJldHVybiAoIGluZGV4ID49IDAgPyBpbmRleCAtIDEgOiBpbmRleCArIGxlbiAvIDMgKSAqIDM7XG5cblx0XHRcdH0sXG5cblx0XHRcdHBhcnNlTm9ybWFsSW5kZXg6IGZ1bmN0aW9uICggdmFsdWUsIGxlbiApIHtcblxuXHRcdFx0XHR2YXIgaW5kZXggPSBwYXJzZUludCggdmFsdWUsIDEwICk7XG5cdFx0XHRcdHJldHVybiAoIGluZGV4ID49IDAgPyBpbmRleCAtIDEgOiBpbmRleCArIGxlbiAvIDMgKSAqIDM7XG5cblx0XHRcdH0sXG5cblx0XHRcdHBhcnNlVVZJbmRleDogZnVuY3Rpb24gKCB2YWx1ZSwgbGVuICkge1xuXG5cdFx0XHRcdHZhciBpbmRleCA9IHBhcnNlSW50KCB2YWx1ZSwgMTAgKTtcblx0XHRcdFx0cmV0dXJuICggaW5kZXggPj0gMCA/IGluZGV4IC0gMSA6IGluZGV4ICsgbGVuIC8gMiApICogMjtcblxuXHRcdFx0fSxcblxuXHRcdFx0YWRkVmVydGV4OiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XG5cblx0XHRcdFx0dmFyIHNyYyA9IHRoaXMudmVydGljZXM7XG5cdFx0XHRcdHZhciBkc3QgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBhICsgMCBdICk7XG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGEgKyAxIF0gKTtcblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYSArIDIgXSApO1xuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBiICsgMCBdICk7XG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGIgKyAxIF0gKTtcblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYiArIDIgXSApO1xuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBjICsgMCBdICk7XG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGMgKyAxIF0gKTtcblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYyArIDIgXSApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRhZGRWZXJ0ZXhMaW5lOiBmdW5jdGlvbiAoIGEgKSB7XG5cblx0XHRcdFx0dmFyIHNyYyA9IHRoaXMudmVydGljZXM7XG5cdFx0XHRcdHZhciBkc3QgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBhICsgMCBdICk7XG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGEgKyAxIF0gKTtcblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYSArIDIgXSApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRhZGROb3JtYWwgOiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XG5cblx0XHRcdFx0dmFyIHNyYyA9IHRoaXMubm9ybWFscztcblx0XHRcdFx0dmFyIGRzdCA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5Lm5vcm1hbHM7XG5cblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYSArIDAgXSApO1xuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBhICsgMSBdICk7XG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGEgKyAyIF0gKTtcblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYiArIDAgXSApO1xuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBiICsgMSBdICk7XG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGIgKyAyIF0gKTtcblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYyArIDAgXSApO1xuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBjICsgMSBdICk7XG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGMgKyAyIF0gKTtcblxuXHRcdFx0fSxcblxuXHRcdFx0YWRkVVY6IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuXHRcdFx0XHR2YXIgc3JjID0gdGhpcy51dnM7XG5cdFx0XHRcdHZhciBkc3QgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS51dnM7XG5cblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYSArIDAgXSApO1xuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBhICsgMSBdICk7XG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGIgKyAwIF0gKTtcblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYiArIDEgXSApO1xuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBjICsgMCBdICk7XG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGMgKyAxIF0gKTtcblxuXHRcdFx0fSxcblxuXHRcdFx0YWRkVVZMaW5lOiBmdW5jdGlvbiAoIGEgKSB7XG5cblx0XHRcdFx0dmFyIHNyYyA9IHRoaXMudXZzO1xuXHRcdFx0XHR2YXIgZHN0ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkudXZzO1xuXG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGEgKyAwIF0gKTtcblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYSArIDEgXSApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRhZGRGYWNlOiBmdW5jdGlvbiAoIGEsIGIsIGMsIGQsIHVhLCB1YiwgdWMsIHVkLCBuYSwgbmIsIG5jLCBuZCApIHtcblxuXHRcdFx0XHR2YXIgdkxlbiA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuXG5cdFx0XHRcdHZhciBpYSA9IHRoaXMucGFyc2VWZXJ0ZXhJbmRleCggYSwgdkxlbiApO1xuXHRcdFx0XHR2YXIgaWIgPSB0aGlzLnBhcnNlVmVydGV4SW5kZXgoIGIsIHZMZW4gKTtcblx0XHRcdFx0dmFyIGljID0gdGhpcy5wYXJzZVZlcnRleEluZGV4KCBjLCB2TGVuICk7XG5cdFx0XHRcdHZhciBpZDtcblxuXHRcdFx0XHRpZiAoIGQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHRoaXMuYWRkVmVydGV4KCBpYSwgaWIsIGljICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlkID0gdGhpcy5wYXJzZVZlcnRleEluZGV4KCBkLCB2TGVuICk7XG5cblx0XHRcdFx0XHR0aGlzLmFkZFZlcnRleCggaWEsIGliLCBpZCApO1xuXHRcdFx0XHRcdHRoaXMuYWRkVmVydGV4KCBpYiwgaWMsIGlkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdWEgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHZhciB1dkxlbiA9IHRoaXMudXZzLmxlbmd0aDtcblxuXHRcdFx0XHRcdGlhID0gdGhpcy5wYXJzZVVWSW5kZXgoIHVhLCB1dkxlbiApO1xuXHRcdFx0XHRcdGliID0gdGhpcy5wYXJzZVVWSW5kZXgoIHViLCB1dkxlbiApO1xuXHRcdFx0XHRcdGljID0gdGhpcy5wYXJzZVVWSW5kZXgoIHVjLCB1dkxlbiApO1xuXG5cdFx0XHRcdFx0aWYgKCBkID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuYWRkVVYoIGlhLCBpYiwgaWMgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGlkID0gdGhpcy5wYXJzZVVWSW5kZXgoIHVkLCB1dkxlbiApO1xuXG5cdFx0XHRcdFx0XHR0aGlzLmFkZFVWKCBpYSwgaWIsIGlkICk7XG5cdFx0XHRcdFx0XHR0aGlzLmFkZFVWKCBpYiwgaWMsIGlkICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbmEgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdC8vIE5vcm1hbHMgYXJlIG1hbnkgdGltZXMgdGhlIHNhbWUuIElmIHNvLCBza2lwIGZ1bmN0aW9uIGNhbGwgYW5kIHBhcnNlSW50LlxuXHRcdFx0XHRcdHZhciBuTGVuID0gdGhpcy5ub3JtYWxzLmxlbmd0aDtcblx0XHRcdFx0XHRpYSA9IHRoaXMucGFyc2VOb3JtYWxJbmRleCggbmEsIG5MZW4gKTtcblxuXHRcdFx0XHRcdGliID0gbmEgPT09IG5iID8gaWEgOiB0aGlzLnBhcnNlTm9ybWFsSW5kZXgoIG5iLCBuTGVuICk7XG5cdFx0XHRcdFx0aWMgPSBuYSA9PT0gbmMgPyBpYSA6IHRoaXMucGFyc2VOb3JtYWxJbmRleCggbmMsIG5MZW4gKTtcblxuXHRcdFx0XHRcdGlmICggZCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR0aGlzLmFkZE5vcm1hbCggaWEsIGliLCBpYyApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0aWQgPSB0aGlzLnBhcnNlTm9ybWFsSW5kZXgoIG5kLCBuTGVuICk7XG5cblx0XHRcdFx0XHRcdHRoaXMuYWRkTm9ybWFsKCBpYSwgaWIsIGlkICk7XG5cdFx0XHRcdFx0XHR0aGlzLmFkZE5vcm1hbCggaWIsIGljLCBpZCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdFx0YWRkTGluZUdlb21ldHJ5OiBmdW5jdGlvbiAoIHZlcnRpY2VzLCB1dnMgKSB7XG5cblx0XHRcdFx0dGhpcy5vYmplY3QuZ2VvbWV0cnkudHlwZSA9ICdMaW5lJztcblxuXHRcdFx0XHR2YXIgdkxlbiA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuXHRcdFx0XHR2YXIgdXZMZW4gPSB0aGlzLnV2cy5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggdmFyIHZpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgdmkgPCBsOyB2aSArKyApIHtcblxuXHRcdFx0XHRcdHRoaXMuYWRkVmVydGV4TGluZSggdGhpcy5wYXJzZVZlcnRleEluZGV4KCB2ZXJ0aWNlc1sgdmkgXSwgdkxlbiApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIHZhciB1dmkgPSAwLCBsID0gdXZzLmxlbmd0aDsgdXZpIDwgbDsgdXZpICsrICkge1xuXG5cdFx0XHRcdFx0dGhpcy5hZGRVVkxpbmUoIHRoaXMucGFyc2VVVkluZGV4KCB1dnNbIHV2aSBdLCB1dkxlbiApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0c3RhdGUuc3RhcnRPYmplY3QoICcnLCBmYWxzZSApO1xuXG5cdFx0cmV0dXJuIHN0YXRlO1xuXG5cdH0sXG5cblx0cGFyc2U6IGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdGNvbnNvbGUudGltZSggJ09CSkxvYWRlcicgKTtcblxuXHRcdHZhciBzdGF0ZSA9IHRoaXMuX2NyZWF0ZVBhcnNlclN0YXRlKCk7XG5cblx0XHRpZiAoIHRleHQuaW5kZXhPZiggJ1xcclxcbicgKSAhPT0gLSAxICkge1xuXG5cdFx0XHQvLyBUaGlzIGlzIGZhc3RlciB0aGFuIFN0cmluZy5zcGxpdCB3aXRoIHJlZ2V4IHRoYXQgc3BsaXRzIG9uIGJvdGhcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIC9cXHJcXG4vZywgJ1xcbicgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGV4dC5pbmRleE9mKCAnXFxcXFxcbicgKSAhPT0gLSAxKSB7XG5cblx0XHRcdC8vIGpvaW4gbGluZXMgc2VwYXJhdGVkIGJ5IGEgbGluZSBjb250aW51YXRpb24gY2hhcmFjdGVyIChcXClcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIC9cXFxcXFxuL2csICcnICk7XG5cblx0XHR9XG5cblx0XHR2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCAnXFxuJyApO1xuXHRcdHZhciBsaW5lID0gJycsIGxpbmVGaXJzdENoYXIgPSAnJywgbGluZVNlY29uZENoYXIgPSAnJztcblx0XHR2YXIgbGluZUxlbmd0aCA9IDA7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXG5cdFx0Ly8gRmFzdGVyIHRvIGp1c3QgdHJpbSBsZWZ0IHNpZGUgb2YgdGhlIGxpbmUuIFVzZSBpZiBhdmFpbGFibGUuXG5cdFx0dmFyIHRyaW1MZWZ0ID0gKCB0eXBlb2YgJycudHJpbUxlZnQgPT09ICdmdW5jdGlvbicgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGxpbmUgPSBsaW5lc1sgaSBdO1xuXG5cdFx0XHRsaW5lID0gdHJpbUxlZnQgPyBsaW5lLnRyaW1MZWZ0KCkgOiBsaW5lLnRyaW0oKTtcblxuXHRcdFx0bGluZUxlbmd0aCA9IGxpbmUubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIGxpbmVMZW5ndGggPT09IDAgKSBjb250aW51ZTtcblxuXHRcdFx0bGluZUZpcnN0Q2hhciA9IGxpbmUuY2hhckF0KCAwICk7XG5cblx0XHRcdC8vIEB0b2RvIGludm9rZSBwYXNzZWQgaW4gaGFuZGxlciBpZiBhbnlcblx0XHRcdGlmICggbGluZUZpcnN0Q2hhciA9PT0gJyMnICkgY29udGludWU7XG5cblx0XHRcdGlmICggbGluZUZpcnN0Q2hhciA9PT0gJ3YnICkge1xuXG5cdFx0XHRcdGxpbmVTZWNvbmRDaGFyID0gbGluZS5jaGFyQXQoIDEgKTtcblxuXHRcdFx0XHRpZiAoIGxpbmVTZWNvbmRDaGFyID09PSAnICcgJiYgKCByZXN1bHQgPSB0aGlzLnJlZ2V4cC52ZXJ0ZXhfcGF0dGVybi5leGVjKCBsaW5lICkgKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdC8vIDAgICAgICAgICAgICAgICAgICAxICAgICAgMiAgICAgIDNcblx0XHRcdFx0XHQvLyBbXCJ2IDEuMCAyLjAgMy4wXCIsIFwiMS4wXCIsIFwiMi4wXCIsIFwiMy4wXCJdXG5cblx0XHRcdFx0XHRzdGF0ZS52ZXJ0aWNlcy5wdXNoKFxuXHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggcmVzdWx0WyAxIF0gKSxcblx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIHJlc3VsdFsgMiBdICksXG5cdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCByZXN1bHRbIDMgXSApXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBsaW5lU2Vjb25kQ2hhciA9PT0gJ24nICYmICggcmVzdWx0ID0gdGhpcy5yZWdleHAubm9ybWFsX3BhdHRlcm4uZXhlYyggbGluZSApICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHQvLyAwICAgICAgICAgICAgICAgICAgIDEgICAgICAyICAgICAgM1xuXHRcdFx0XHRcdC8vIFtcInZuIDEuMCAyLjAgMy4wXCIsIFwiMS4wXCIsIFwiMi4wXCIsIFwiMy4wXCJdXG5cblx0XHRcdFx0XHRzdGF0ZS5ub3JtYWxzLnB1c2goXG5cdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCByZXN1bHRbIDEgXSApLFxuXHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggcmVzdWx0WyAyIF0gKSxcblx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIHJlc3VsdFsgMyBdIClcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGxpbmVTZWNvbmRDaGFyID09PSAndCcgJiYgKCByZXN1bHQgPSB0aGlzLnJlZ2V4cC51dl9wYXR0ZXJuLmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0Ly8gMCAgICAgICAgICAgICAgIDEgICAgICAyXG5cdFx0XHRcdFx0Ly8gW1widnQgMC4xIDAuMlwiLCBcIjAuMVwiLCBcIjAuMlwiXVxuXG5cdFx0XHRcdFx0c3RhdGUudXZzLnB1c2goXG5cdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCByZXN1bHRbIDEgXSApLFxuXHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggcmVzdWx0WyAyIF0gKVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJVbmV4cGVjdGVkIHZlcnRleC9ub3JtYWwvdXYgbGluZTogJ1wiICsgbGluZSAgKyBcIidcIiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggbGluZUZpcnN0Q2hhciA9PT0gXCJmXCIgKSB7XG5cblx0XHRcdFx0aWYgKCAoIHJlc3VsdCA9IHRoaXMucmVnZXhwLmZhY2VfdmVydGV4X3V2X25vcm1hbC5leGVjKCBsaW5lICkgKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdC8vIGYgdmVydGV4L3V2L25vcm1hbCB2ZXJ0ZXgvdXYvbm9ybWFsIHZlcnRleC91di9ub3JtYWxcblx0XHRcdFx0XHQvLyAwICAgICAgICAgICAgICAgICAgICAgICAgMSAgICAyICAgIDMgICAgNCAgICA1ICAgIDYgICAgNyAgICA4ICAgIDkgICAxMCAgICAgICAgIDExICAgICAgICAgMTJcblx0XHRcdFx0XHQvLyBbXCJmIDEvMS8xIDIvMi8yIDMvMy8zXCIsIFwiMVwiLCBcIjFcIiwgXCIxXCIsIFwiMlwiLCBcIjJcIiwgXCIyXCIsIFwiM1wiLCBcIjNcIiwgXCIzXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXG5cblx0XHRcdFx0XHRzdGF0ZS5hZGRGYWNlKFxuXHRcdFx0XHRcdFx0cmVzdWx0WyAxIF0sIHJlc3VsdFsgNCBdLCByZXN1bHRbIDcgXSwgcmVzdWx0WyAxMCBdLFxuXHRcdFx0XHRcdFx0cmVzdWx0WyAyIF0sIHJlc3VsdFsgNSBdLCByZXN1bHRbIDggXSwgcmVzdWx0WyAxMSBdLFxuXHRcdFx0XHRcdFx0cmVzdWx0WyAzIF0sIHJlc3VsdFsgNiBdLCByZXN1bHRbIDkgXSwgcmVzdWx0WyAxMiBdXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIHJlc3VsdCA9IHRoaXMucmVnZXhwLmZhY2VfdmVydGV4X3V2LmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0Ly8gZiB2ZXJ0ZXgvdXYgdmVydGV4L3V2IHZlcnRleC91dlxuXHRcdFx0XHRcdC8vIDAgICAgICAgICAgICAgICAgICAxICAgIDIgICAgMyAgICA0ICAgIDUgICAgNiAgIDcgICAgICAgICAgOFxuXHRcdFx0XHRcdC8vIFtcImYgMS8xIDIvMiAzLzNcIiwgXCIxXCIsIFwiMVwiLCBcIjJcIiwgXCIyXCIsIFwiM1wiLCBcIjNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXG5cblx0XHRcdFx0XHRzdGF0ZS5hZGRGYWNlKFxuXHRcdFx0XHRcdFx0cmVzdWx0WyAxIF0sIHJlc3VsdFsgMyBdLCByZXN1bHRbIDUgXSwgcmVzdWx0WyA3IF0sXG5cdFx0XHRcdFx0XHRyZXN1bHRbIDIgXSwgcmVzdWx0WyA0IF0sIHJlc3VsdFsgNiBdLCByZXN1bHRbIDggXVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggKCByZXN1bHQgPSB0aGlzLnJlZ2V4cC5mYWNlX3ZlcnRleF9ub3JtYWwuZXhlYyggbGluZSApICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHQvLyBmIHZlcnRleC8vbm9ybWFsIHZlcnRleC8vbm9ybWFsIHZlcnRleC8vbm9ybWFsXG5cdFx0XHRcdFx0Ly8gMCAgICAgICAgICAgICAgICAgICAgIDEgICAgMiAgICAzICAgIDQgICAgNSAgICA2ICAgNyAgICAgICAgICA4XG5cdFx0XHRcdFx0Ly8gW1wiZiAxLy8xIDIvLzIgMy8vM1wiLCBcIjFcIiwgXCIxXCIsIFwiMlwiLCBcIjJcIiwgXCIzXCIsIFwiM1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cblxuXHRcdFx0XHRcdHN0YXRlLmFkZEZhY2UoXG5cdFx0XHRcdFx0XHRyZXN1bHRbIDEgXSwgcmVzdWx0WyAzIF0sIHJlc3VsdFsgNSBdLCByZXN1bHRbIDcgXSxcblx0XHRcdFx0XHRcdHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCxcblx0XHRcdFx0XHRcdHJlc3VsdFsgMiBdLCByZXN1bHRbIDQgXSwgcmVzdWx0WyA2IF0sIHJlc3VsdFsgOCBdXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIHJlc3VsdCA9IHRoaXMucmVnZXhwLmZhY2VfdmVydGV4LmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0Ly8gZiB2ZXJ0ZXggdmVydGV4IHZlcnRleFxuXHRcdFx0XHRcdC8vIDAgICAgICAgICAgICAxICAgIDIgICAgMyAgIDRcblx0XHRcdFx0XHQvLyBbXCJmIDEgMiAzXCIsIFwiMVwiLCBcIjJcIiwgXCIzXCIsIHVuZGVmaW5lZF1cblxuXHRcdFx0XHRcdHN0YXRlLmFkZEZhY2UoXG5cdFx0XHRcdFx0XHRyZXN1bHRbIDEgXSwgcmVzdWx0WyAyIF0sIHJlc3VsdFsgMyBdLCByZXN1bHRbIDQgXVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJVbmV4cGVjdGVkIGZhY2UgbGluZTogJ1wiICsgbGluZSAgKyBcIidcIiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggbGluZUZpcnN0Q2hhciA9PT0gXCJsXCIgKSB7XG5cblx0XHRcdFx0dmFyIGxpbmVQYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKCAxICkudHJpbSgpLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHR2YXIgbGluZVZlcnRpY2VzID0gW10sIGxpbmVVVnMgPSBbXTtcblxuXHRcdFx0XHRpZiAoIGxpbmUuaW5kZXhPZiggXCIvXCIgKSA9PT0gLSAxICkge1xuXG5cdFx0XHRcdFx0bGluZVZlcnRpY2VzID0gbGluZVBhcnRzO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgbGkgPSAwLCBsbGVuID0gbGluZVBhcnRzLmxlbmd0aDsgbGkgPCBsbGVuOyBsaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHBhcnRzID0gbGluZVBhcnRzWyBsaSBdLnNwbGl0KCBcIi9cIiApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHBhcnRzWyAwIF0gIT09IFwiXCIgKSBsaW5lVmVydGljZXMucHVzaCggcGFydHNbIDAgXSApO1xuXHRcdFx0XHRcdFx0aWYgKCBwYXJ0c1sgMSBdICE9PSBcIlwiICkgbGluZVVWcy5wdXNoKCBwYXJ0c1sgMSBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXHRcdFx0XHRzdGF0ZS5hZGRMaW5lR2VvbWV0cnkoIGxpbmVWZXJ0aWNlcywgbGluZVVWcyApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCAoIHJlc3VsdCA9IHRoaXMucmVnZXhwLm9iamVjdF9wYXR0ZXJuLmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdC8vIG8gb2JqZWN0X25hbWVcblx0XHRcdFx0Ly8gb3Jcblx0XHRcdFx0Ly8gZyBncm91cF9uYW1lXG5cblx0XHRcdFx0Ly8gV09SS0FST1VORDogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Mjg2OVxuXHRcdFx0XHQvLyB2YXIgbmFtZSA9IHJlc3VsdFsgMCBdLnN1YnN0ciggMSApLnRyaW0oKTtcblx0XHRcdFx0dmFyIG5hbWUgPSAoIFwiIFwiICsgcmVzdWx0WyAwIF0uc3Vic3RyKCAxICkudHJpbSgpICkuc3Vic3RyKCAxICk7XG5cblx0XHRcdFx0c3RhdGUuc3RhcnRPYmplY3QoIG5hbWUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggdGhpcy5yZWdleHAubWF0ZXJpYWxfdXNlX3BhdHRlcm4udGVzdCggbGluZSApICkge1xuXG5cdFx0XHRcdC8vIG1hdGVyaWFsXG5cblx0XHRcdFx0c3RhdGUub2JqZWN0LnN0YXJ0TWF0ZXJpYWwoIGxpbmUuc3Vic3RyaW5nKCA3ICkudHJpbSgpLCBzdGF0ZS5tYXRlcmlhbExpYnJhcmllcyApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnJlZ2V4cC5tYXRlcmlhbF9saWJyYXJ5X3BhdHRlcm4udGVzdCggbGluZSApICkge1xuXG5cdFx0XHRcdC8vIG10bCBmaWxlXG5cblx0XHRcdFx0c3RhdGUubWF0ZXJpYWxMaWJyYXJpZXMucHVzaCggbGluZS5zdWJzdHJpbmcoIDcgKS50cmltKCkgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggKCByZXN1bHQgPSB0aGlzLnJlZ2V4cC5zbW9vdGhpbmdfcGF0dGVybi5leGVjKCBsaW5lICkgKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHQvLyBzbW9vdGggc2hhZGluZ1xuXG5cdFx0XHRcdC8vIEB0b2RvIEhhbmRsZSBmaWxlcyB0aGF0IGhhdmUgdmFyeWluZyBzbW9vdGggdmFsdWVzIGZvciBhIHNldCBvZiBmYWNlcyBpbnNpZGUgb25lIGdlb21ldHJ5LFxuXHRcdFx0XHQvLyBidXQgZG9lcyBub3QgZGVmaW5lIGEgdXNlbXRsIGZvciBlYWNoIGZhY2Ugc2V0LlxuXHRcdFx0XHQvLyBUaGlzIHNob3VsZCBiZSBkZXRlY3RlZCBhbmQgYSBkdW1teSBtYXRlcmlhbCBjcmVhdGVkIChsYXRlciBNdWx0aU1hdGVyaWFsIGFuZCBnZW9tZXRyeSBncm91cHMpLlxuXHRcdFx0XHQvLyBUaGlzIHJlcXVpcmVzIHNvbWUgY2FyZSB0byBub3QgY3JlYXRlIGV4dHJhIG1hdGVyaWFsIG9uIGVhY2ggc21vb3RoIHZhbHVlIGZvciBcIm5vcm1hbFwiIG9iaiBmaWxlcy5cblx0XHRcdFx0Ly8gd2hlcmUgZXhwbGljaXQgdXNlbXRsIGRlZmluZXMgZ2VvbWV0cnkgZ3JvdXBzLlxuXHRcdFx0XHQvLyBFeGFtcGxlIGFzc2V0OiBleGFtcGxlcy9tb2RlbHMvb2JqL2NlcmJlcnVzL0NlcmJlcnVzLm9ialxuXG5cdFx0XHRcdHZhciB2YWx1ZSA9IHJlc3VsdFsgMSBdLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRzdGF0ZS5vYmplY3Quc21vb3RoID0gKCB2YWx1ZSA9PT0gJzEnIHx8IHZhbHVlID09PSAnb24nICk7XG5cblx0XHRcdFx0dmFyIG1hdGVyaWFsID0gc3RhdGUub2JqZWN0LmN1cnJlbnRNYXRlcmlhbCgpO1xuXHRcdFx0XHRpZiAoIG1hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0bWF0ZXJpYWwuc21vb3RoID0gc3RhdGUub2JqZWN0LnNtb290aDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIG51bGwgdGVybWluYXRlZCBmaWxlcyB3aXRob3V0IGV4Y2VwdGlvblxuXHRcdFx0XHRpZiAoIGxpbmUgPT09ICdcXDAnICkgY29udGludWU7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcIlVuZXhwZWN0ZWQgbGluZTogJ1wiICsgbGluZSAgKyBcIidcIiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRzdGF0ZS5maW5hbGl6ZSgpO1xuXG5cdFx0dmFyIGNvbnRhaW5lciA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuXHRcdGNvbnRhaW5lci5tYXRlcmlhbExpYnJhcmllcyA9IFtdLmNvbmNhdCggc3RhdGUubWF0ZXJpYWxMaWJyYXJpZXMgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHN0YXRlLm9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIG9iamVjdCA9IHN0YXRlLm9iamVjdHNbIGkgXTtcblx0XHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblx0XHRcdHZhciBtYXRlcmlhbHMgPSBvYmplY3QubWF0ZXJpYWxzO1xuXHRcdFx0dmFyIGlzTGluZSA9ICggZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmUnICk7XG5cblx0XHRcdC8vIFNraXAgby9nIGxpbmUgZGVjbGFyYXRpb25zIHRoYXQgZGlkIG5vdCBmb2xsb3cgd2l0aCBhbnkgZmFjZXNcblx0XHRcdGlmICggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoID09PSAwICkgY29udGludWU7XG5cblx0XHRcdHZhciBidWZmZXJnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0XHRidWZmZXJnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICksIDMgKSApO1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5Lm5vcm1hbHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRidWZmZXJnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5ub3JtYWxzICksIDMgKSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGJ1ZmZlcmdlb21ldHJ5LmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9tZXRyeS51dnMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRidWZmZXJnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnV2cyApLCAyICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDcmVhdGUgbWF0ZXJpYWxzXG5cblx0XHRcdHZhciBjcmVhdGVkTWF0ZXJpYWxzID0gW107XG5cblx0XHRcdGZvciAoIHZhciBtaSA9IDAsIG1pTGVuID0gbWF0ZXJpYWxzLmxlbmd0aDsgbWkgPCBtaUxlbiA7IG1pKysgKSB7XG5cblx0XHRcdFx0dmFyIHNvdXJjZU1hdGVyaWFsID0gbWF0ZXJpYWxzW21pXTtcblx0XHRcdFx0dmFyIG1hdGVyaWFsID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdGlmICggdGhpcy5tYXRlcmlhbHMgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWxzLmNyZWF0ZSggc291cmNlTWF0ZXJpYWwubmFtZSApO1xuXG5cdFx0XHRcdFx0Ly8gbXRsIGV0Yy4gbG9hZGVycyBwcm9iYWJseSBjYW4ndCBjcmVhdGUgbGluZSBtYXRlcmlhbHMgY29ycmVjdGx5LCBjb3B5IHByb3BlcnRpZXMgdG8gYSBsaW5lIG1hdGVyaWFsLlxuXHRcdFx0XHRcdGlmICggaXNMaW5lICYmIG1hdGVyaWFsICYmICEgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsICkgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbExpbmUgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoKTtcblx0XHRcdFx0XHRcdG1hdGVyaWFsTGluZS5jb3B5KCBtYXRlcmlhbCApO1xuXHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSBtYXRlcmlhbExpbmU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggISBtYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsID0gKCAhIGlzTGluZSA/IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCgpIDogbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCkgKTtcblx0XHRcdFx0XHRtYXRlcmlhbC5uYW1lID0gc291cmNlTWF0ZXJpYWwubmFtZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWF0ZXJpYWwuc2hhZGluZyA9IHNvdXJjZU1hdGVyaWFsLnNtb290aCA/IFRIUkVFLlNtb290aFNoYWRpbmcgOiBUSFJFRS5GbGF0U2hhZGluZztcblxuXHRcdFx0XHRjcmVhdGVkTWF0ZXJpYWxzLnB1c2gobWF0ZXJpYWwpO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIENyZWF0ZSBtZXNoXG5cblx0XHRcdHZhciBtZXNoO1xuXG5cdFx0XHRpZiAoIGNyZWF0ZWRNYXRlcmlhbHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgbWkgPSAwLCBtaUxlbiA9IG1hdGVyaWFscy5sZW5ndGg7IG1pIDwgbWlMZW4gOyBtaSsrICkge1xuXG5cdFx0XHRcdFx0dmFyIHNvdXJjZU1hdGVyaWFsID0gbWF0ZXJpYWxzW21pXTtcblx0XHRcdFx0XHRidWZmZXJnZW9tZXRyeS5hZGRHcm91cCggc291cmNlTWF0ZXJpYWwuZ3JvdXBTdGFydCwgc291cmNlTWF0ZXJpYWwuZ3JvdXBDb3VudCwgbWkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG11bHRpTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTXVsdGlNYXRlcmlhbCggY3JlYXRlZE1hdGVyaWFscyApO1xuXHRcdFx0XHRtZXNoID0gKCAhIGlzTGluZSA/IG5ldyBUSFJFRS5NZXNoKCBidWZmZXJnZW9tZXRyeSwgbXVsdGlNYXRlcmlhbCApIDogbmV3IFRIUkVFLkxpbmVTZWdtZW50cyggYnVmZmVyZ2VvbWV0cnksIG11bHRpTWF0ZXJpYWwgKSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG1lc2ggPSAoICEgaXNMaW5lID8gbmV3IFRIUkVFLk1lc2goIGJ1ZmZlcmdlb21ldHJ5LCBjcmVhdGVkTWF0ZXJpYWxzWyAwIF0gKSA6IG5ldyBUSFJFRS5MaW5lU2VnbWVudHMoIGJ1ZmZlcmdlb21ldHJ5LCBjcmVhdGVkTWF0ZXJpYWxzWyAwIF0gKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRtZXNoLm5hbWUgPSBvYmplY3QubmFtZTtcblxuXHRcdFx0Y29udGFpbmVyLmFkZCggbWVzaCApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc29sZS50aW1lRW5kKCAnT0JKTG9hZGVyJyApO1xuXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcblxuXHR9XG5cbn07XG4iLCIvKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb21cbiAqIEBhdXRob3Igc3Rld2RpbyAvIGh0dHA6Ly9zdGV3ZC5pb1xuICovXG5cblRIUkVFLlZpdmVDb250cm9sbGVyID0gZnVuY3Rpb24gKCBpZCApIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dmFyIHNjb3BlID0gdGhpcztcblx0dmFyIGdhbWVwYWQ7XG5cblx0dmFyIGF4ZXMgPSBbIDAsIDAgXTtcblx0dmFyIHRodW1icGFkSXNQcmVzc2VkID0gZmFsc2U7XG5cdHZhciB0cmlnZ2VySXNQcmVzc2VkID0gZmFsc2U7XG5cdHZhciBncmlwc0FyZVByZXNzZWQgPSBmYWxzZTtcblx0dmFyIG1lbnVJc1ByZXNzZWQgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBmaW5kR2FtZXBhZCggaWQgKSB7XG5cblx0XHQvLyBJdGVyYXRlIGFjcm9zcyBnYW1lcGFkcyBhcyBWaXZlIENvbnRyb2xsZXJzIG1heSBub3QgYmVcblx0XHQvLyBpbiBwb3NpdGlvbiAwIGFuZCAxLlxuXG5cdFx0dmFyIGdhbWVwYWRzID0gbmF2aWdhdG9yLmdldEdhbWVwYWRzKCk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwOyBpIDwgNDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGdhbWVwYWQgPSBnYW1lcGFkc1sgaSBdO1xuXG5cdFx0XHRpZiAoIGdhbWVwYWQgJiYgZ2FtZXBhZC5pZCA9PT0gJ09wZW5WUiBHYW1lcGFkJyApIHtcblxuXHRcdFx0XHRpZiAoIGogPT09IGlkICkgcmV0dXJuIGdhbWVwYWQ7XG5cblx0XHRcdFx0aiArKztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0dGhpcy5zdGFuZGluZ01hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0dGhpcy5nZXRHYW1lcGFkID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIGdhbWVwYWQ7XG5cblx0fTtcblxuXHR0aGlzLmdldEJ1dHRvblN0YXRlID0gZnVuY3Rpb24gKCBidXR0b24gKSB7XG5cblx0XHRpZiAoIGJ1dHRvbiA9PT0gJ3RodW1icGFkJyApIHJldHVybiB0aHVtYnBhZElzUHJlc3NlZDtcblx0XHRpZiAoIGJ1dHRvbiA9PT0gJ3RyaWdnZXInICkgcmV0dXJuIHRyaWdnZXJJc1ByZXNzZWQ7XG5cdFx0aWYgKCBidXR0b24gPT09ICdncmlwcycgKSByZXR1cm4gZ3JpcHNBcmVQcmVzc2VkO1xuXHRcdGlmICggYnV0dG9uID09PSAnbWVudScgKSByZXR1cm4gbWVudUlzUHJlc3NlZDtcblxuXHR9O1xuXG5cdHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Z2FtZXBhZCA9IGZpbmRHYW1lcGFkKCBpZCApO1xuXG5cdFx0aWYgKCBnYW1lcGFkICE9PSB1bmRlZmluZWQgJiYgZ2FtZXBhZC5wb3NlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggZ2FtZXBhZC5wb3NlID09PSBudWxsICkgcmV0dXJuOyAvLyBObyB1c2VyIGFjdGlvbiB5ZXRcblxuXHRcdFx0Ly8gIFBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbi5cblxuXHRcdFx0dmFyIHBvc2UgPSBnYW1lcGFkLnBvc2U7XG5cblx0XHRcdGlmICggcG9zZS5wb3NpdGlvbiAhPT0gbnVsbCApIHNjb3BlLnBvc2l0aW9uLmZyb21BcnJheSggcG9zZS5wb3NpdGlvbiApO1xuXHRcdFx0aWYgKCBwb3NlLm9yaWVudGF0aW9uICE9PSBudWxsICkgc2NvcGUucXVhdGVybmlvbi5mcm9tQXJyYXkoIHBvc2Uub3JpZW50YXRpb24gKTtcblx0XHRcdHNjb3BlLm1hdHJpeC5jb21wb3NlKCBzY29wZS5wb3NpdGlvbiwgc2NvcGUucXVhdGVybmlvbiwgc2NvcGUuc2NhbGUgKTtcblx0XHRcdHNjb3BlLm1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzY29wZS5zdGFuZGluZ01hdHJpeCwgc2NvcGUubWF0cml4ICk7XG5cdFx0XHRzY29wZS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdHNjb3BlLnZpc2libGUgPSB0cnVlO1xuXG5cdFx0XHQvLyAgVGh1bWJwYWQgYW5kIEJ1dHRvbnMuXG5cblx0XHRcdGlmICggYXhlc1sgMCBdICE9PSBnYW1lcGFkLmF4ZXNbIDAgXSB8fCBheGVzWyAxIF0gIT09IGdhbWVwYWQuYXhlc1sgMSBdICkge1xuXG5cdFx0XHRcdGF4ZXNbIDAgXSA9IGdhbWVwYWQuYXhlc1sgMCBdOyAvLyAgWCBheGlzOiAtMSA9IExlZnQsICsxID0gUmlnaHQuXG5cdFx0XHRcdGF4ZXNbIDEgXSA9IGdhbWVwYWQuYXhlc1sgMSBdOyAvLyAgWSBheGlzOiAtMSA9IEJvdHRvbSwgKzEgPSBUb3AuXG5cdFx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2F4aXNjaGFuZ2VkJywgYXhlczogYXhlcyB9ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aHVtYnBhZElzUHJlc3NlZCAhPT0gZ2FtZXBhZC5idXR0b25zWyAwIF0ucHJlc3NlZCApIHtcblxuXHRcdFx0XHR0aHVtYnBhZElzUHJlc3NlZCA9IGdhbWVwYWQuYnV0dG9uc1sgMCBdLnByZXNzZWQ7XG5cdFx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogdGh1bWJwYWRJc1ByZXNzZWQgPyAndGh1bWJwYWRkb3duJyA6ICd0aHVtYnBhZHVwJyB9ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0cmlnZ2VySXNQcmVzc2VkICE9PSBnYW1lcGFkLmJ1dHRvbnNbIDEgXS5wcmVzc2VkICkge1xuXG5cdFx0XHRcdHRyaWdnZXJJc1ByZXNzZWQgPSBnYW1lcGFkLmJ1dHRvbnNbIDEgXS5wcmVzc2VkO1xuXHRcdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6IHRyaWdnZXJJc1ByZXNzZWQgPyAndHJpZ2dlcmRvd24nIDogJ3RyaWdnZXJ1cCcgfSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZ3JpcHNBcmVQcmVzc2VkICE9PSBnYW1lcGFkLmJ1dHRvbnNbIDIgXS5wcmVzc2VkICkge1xuXG5cdFx0XHRcdGdyaXBzQXJlUHJlc3NlZCA9IGdhbWVwYWQuYnV0dG9uc1sgMiBdLnByZXNzZWQ7XG5cdFx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogZ3JpcHNBcmVQcmVzc2VkID8gJ2dyaXBzZG93bicgOiAnZ3JpcHN1cCcgfSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWVudUlzUHJlc3NlZCAhPT0gZ2FtZXBhZC5idXR0b25zWyAzIF0ucHJlc3NlZCApIHtcblxuXHRcdFx0XHRtZW51SXNQcmVzc2VkID0gZ2FtZXBhZC5idXR0b25zWyAzIF0ucHJlc3NlZDtcblx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiBtZW51SXNQcmVzc2VkID8gJ21lbnVkb3duJyA6ICdtZW51dXAnIH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0c2NvcGUudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdH07XG5cbn07XG5cblRIUkVFLlZpdmVDb250cm9sbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuVml2ZUNvbnRyb2xsZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVml2ZUNvbnRyb2xsZXI7XG4iLCIoZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5XZWJWUk1hbmFnZXIgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG52YXIgRW1pdHRlciA9IF9kZXJlcV8oJy4vZW1pdHRlci5qcycpO1xudmFyIE1vZGVzID0gX2RlcmVxXygnLi9tb2Rlcy5qcycpO1xudmFyIFV0aWwgPSBfZGVyZXFfKCcuL3V0aWwuanMnKTtcblxuLyoqXG4gKiBFdmVyeXRoaW5nIGhhdmluZyB0byBkbyB3aXRoIHRoZSBXZWJWUiBidXR0b24uXG4gKiBFbWl0cyBhICdjbGljaycgZXZlbnQgd2hlbiBpdCdzIGNsaWNrZWQuXG4gKi9cbmZ1bmN0aW9uIEJ1dHRvbk1hbmFnZXIob3B0X3Jvb3QpIHtcbiAgdmFyIHJvb3QgPSBvcHRfcm9vdCB8fCBkb2N1bWVudC5ib2R5O1xuICB0aGlzLmxvYWRJY29uc18oKTtcblxuICAvLyBNYWtlIHRoZSBmdWxsc2NyZWVuIGJ1dHRvbi5cbiAgdmFyIGZzQnV0dG9uID0gdGhpcy5jcmVhdGVCdXR0b24oKTtcbiAgZnNCdXR0b24uc3JjID0gdGhpcy5JQ09OUy5mdWxsc2NyZWVuO1xuICBmc0J1dHRvbi50aXRsZSA9ICdGdWxsc2NyZWVuIG1vZGUnO1xuICB2YXIgcyA9IGZzQnV0dG9uLnN0eWxlO1xuICBzLmJvdHRvbSA9IDA7XG4gIHMucmlnaHQgPSAwO1xuICBmc0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuY3JlYXRlQ2xpY2tIYW5kbGVyXygnZnMnKSk7XG4gIHJvb3QuYXBwZW5kQ2hpbGQoZnNCdXR0b24pO1xuICB0aGlzLmZzQnV0dG9uID0gZnNCdXR0b247XG5cbiAgLy8gTWFrZSB0aGUgVlIgYnV0dG9uLlxuICB2YXIgdnJCdXR0b24gPSB0aGlzLmNyZWF0ZUJ1dHRvbigpO1xuICB2ckJ1dHRvbi5zcmMgPSB0aGlzLklDT05TLmNhcmRib2FyZDtcbiAgdnJCdXR0b24udGl0bGUgPSAnVmlydHVhbCByZWFsaXR5IG1vZGUnO1xuICB2YXIgcyA9IHZyQnV0dG9uLnN0eWxlO1xuICBzLmJvdHRvbSA9IDA7XG4gIHMucmlnaHQgPSAnNDhweCc7XG4gIHZyQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jcmVhdGVDbGlja0hhbmRsZXJfKCd2cicpKTtcbiAgcm9vdC5hcHBlbmRDaGlsZCh2ckJ1dHRvbik7XG4gIHRoaXMudnJCdXR0b24gPSB2ckJ1dHRvbjtcblxuICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7XG5cbn1cbkJ1dHRvbk1hbmFnZXIucHJvdG90eXBlID0gbmV3IEVtaXR0ZXIoKTtcblxuQnV0dG9uTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlQnV0dG9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgYnV0dG9uLmNsYXNzTmFtZSA9ICd3ZWJ2ci1idXR0b24nO1xuICB2YXIgcyA9IGJ1dHRvbi5zdHlsZTtcbiAgcy5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIHMud2lkdGggPSAnMjRweCdcbiAgcy5oZWlnaHQgPSAnMjRweCc7XG4gIHMuYmFja2dyb3VuZFNpemUgPSAnY292ZXInO1xuICBzLmJhY2tncm91bmRDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gIHMuYm9yZGVyID0gMDtcbiAgcy51c2VyU2VsZWN0ID0gJ25vbmUnO1xuICBzLndlYmtpdFVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gIHMuTW96VXNlclNlbGVjdCA9ICdub25lJztcbiAgcy5jdXJzb3IgPSAncG9pbnRlcic7XG4gIHMucGFkZGluZyA9ICcxMnB4JztcbiAgcy56SW5kZXggPSAxO1xuICBzLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHMuYm94U2l6aW5nID0gJ2NvbnRlbnQtYm94JztcblxuICAvLyBQcmV2ZW50IGJ1dHRvbiBmcm9tIGJlaW5nIHNlbGVjdGVkIGFuZCBkcmFnZ2VkLlxuICBidXR0b24uZHJhZ2dhYmxlID0gZmFsc2U7XG4gIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBmdW5jdGlvbihlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcblxuICAvLyBTdHlsZSBpdCBvbiBob3Zlci5cbiAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBmdW5jdGlvbihlKSB7XG4gICAgcy5maWx0ZXIgPSBzLndlYmtpdEZpbHRlciA9ICdkcm9wLXNoYWRvdygwIDAgNXB4IHJnYmEoMjU1LDI1NSwyNTUsMSkpJztcbiAgfSk7XG4gIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24oZSkge1xuICAgIHMuZmlsdGVyID0gcy53ZWJraXRGaWx0ZXIgPSAnJztcbiAgfSk7XG4gIHJldHVybiBidXR0b247XG59O1xuXG5CdXR0b25NYW5hZ2VyLnByb3RvdHlwZS5zZXRNb2RlID0gZnVuY3Rpb24obW9kZSwgaXNWUkNvbXBhdGlibGUpIHtcbiAgaXNWUkNvbXBhdGlibGUgPSBpc1ZSQ29tcGF0aWJsZSB8fCBXZWJWUkNvbmZpZy5GT1JDRV9FTkFCTEVfVlI7XG4gIGlmICghdGhpcy5pc1Zpc2libGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSBNb2Rlcy5OT1JNQUw6XG4gICAgICB0aGlzLmZzQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgdGhpcy5mc0J1dHRvbi5zcmMgPSB0aGlzLklDT05TLmZ1bGxzY3JlZW47XG4gICAgICB0aGlzLnZyQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAoaXNWUkNvbXBhdGlibGUgPyAnYmxvY2snIDogJ25vbmUnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTW9kZXMuTUFHSUNfV0lORE9XOlxuICAgICAgdGhpcy5mc0J1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIHRoaXMuZnNCdXR0b24uc3JjID0gdGhpcy5JQ09OUy5leGl0RnVsbHNjcmVlbjtcbiAgICAgIHRoaXMudnJCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTW9kZXMuVlI6XG4gICAgICB0aGlzLmZzQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLnZyQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIEhhY2sgZm9yIFNhZmFyaSBNYWMvaU9TIHRvIGZvcmNlIHJlbGF5b3V0IChzdmctc3BlY2lmaWMgaXNzdWUpXG4gIC8vIGh0dHA6Ly9nb28uZ2wvaGpnUjZyXG4gIHZhciBvbGRWYWx1ZSA9IHRoaXMuZnNCdXR0b24uc3R5bGUuZGlzcGxheTtcbiAgdGhpcy5mc0J1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gIHRoaXMuZnNCdXR0b24ub2Zmc2V0SGVpZ2h0O1xuICB0aGlzLmZzQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSBvbGRWYWx1ZTtcbn07XG5cbkJ1dHRvbk1hbmFnZXIucHJvdG90eXBlLnNldFZpc2liaWxpdHkgPSBmdW5jdGlvbihpc1Zpc2libGUpIHtcbiAgdGhpcy5pc1Zpc2libGUgPSBpc1Zpc2libGU7XG4gIHRoaXMuZnNCdXR0b24uc3R5bGUuZGlzcGxheSA9IGlzVmlzaWJsZSA/ICdibG9jaycgOiAnbm9uZSc7XG4gIHRoaXMudnJCdXR0b24uc3R5bGUuZGlzcGxheSA9IGlzVmlzaWJsZSA/ICdibG9jaycgOiAnbm9uZSc7XG59O1xuXG5CdXR0b25NYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVDbGlja0hhbmRsZXJfID0gZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5lbWl0KGV2ZW50TmFtZSk7XG4gIH0uYmluZCh0aGlzKTtcbn07XG5cbkJ1dHRvbk1hbmFnZXIucHJvdG90eXBlLmxvYWRJY29uc18gPSBmdW5jdGlvbigpIHtcbiAgLy8gUHJlbG9hZCBzb21lIGhhcmQtY29kZWQgU1ZHLlxuICB0aGlzLklDT05TID0ge307XG4gIHRoaXMuSUNPTlMuY2FyZGJvYXJkID0gVXRpbC5iYXNlNjQoJ2ltYWdlL3N2Zyt4bWwnLCAnUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5IQjRJaUJvWldsbmFIUTlJakkwY0hnaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSWdabWxzYkQwaUkwWkdSa1pHUmlJK0NpQWdJQ0E4Y0dGMGFDQmtQU0pOTWpBdU56UWdOa2d6TGpJeFF6SXVOVFVnTmlBeUlEWXVOVGNnTWlBM0xqSTRkakV3TGpRMFl6QWdMamN1TlRVZ01TNHlPQ0F4TGpJeklERXVNamhvTkM0M09XTXVOVElnTUNBdU9UWXRMak16SURFdU1UUXRMamM1YkRFdU5DMHpMalE0WXk0eU15MHVOVGt1TnprdE1TNHdNU0F4TGpRMExURXVNREZ6TVM0eU1TNDBNaUF4TGpRMUlERXVNREZzTVM0ek9TQXpMalE0WXk0eE9TNDBOaTQyTXk0M09TQXhMakV4TGpjNWFEUXVOemxqTGpjeElEQWdNUzR5TmkwdU5UY2dNUzR5TmkweExqSTRWamN1TWpoak1DMHVOeTB1TlRVdE1TNHlPQzB4TGpJMkxURXVNamg2VFRjdU5TQXhOQzQyTW1NdE1TNHhOeUF3TFRJdU1UTXRMamsxTFRJdU1UTXRNaTR4TWlBd0xURXVNVGN1T1RZdE1pNHhNeUF5TGpFekxUSXVNVE1nTVM0eE9DQXdJREl1TVRJdU9UWWdNaTR4TWlBeUxqRXpjeTB1T1RVZ01pNHhNaTB5TGpFeUlESXVNVEo2YlRrZ01HTXRNUzR4TnlBd0xUSXVNVE10TGprMUxUSXVNVE10TWk0eE1pQXdMVEV1TVRjdU9UWXRNaTR4TXlBeUxqRXpMVEl1TVROek1pNHhNaTQ1TmlBeUxqRXlJREl1TVRNdExqazFJREl1TVRJdE1pNHhNaUF5TGpFeWVpSXZQZ29nSUNBZ1BIQmhkR2dnWm1sc2JEMGlibTl1WlNJZ1pEMGlUVEFnTUdneU5IWXlORWd3VmpCNklpOCtDand2YzNablBnbz0nKTtcbiAgdGhpcy5JQ09OUy5mdWxsc2NyZWVuID0gVXRpbC5iYXNlNjQoJ2ltYWdlL3N2Zyt4bWwnLCAnUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5IQjRJaUJvWldsbmFIUTlJakkwY0hnaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSWdabWxzYkQwaUkwWkdSa1pHUmlJK0NpQWdJQ0E4Y0dGMGFDQmtQU0pOTUNBd2FESTBkakkwU0RCNklpQm1hV3hzUFNKdWIyNWxJaTgrQ2lBZ0lDQThjR0YwYUNCa1BTSk5OeUF4TkVnMWRqVm9OWFl0TWtnM2RpMHplbTB0TWkwMGFESldOMmd6VmpWSU5YWTFlbTB4TWlBM2FDMHpkakpvTlhZdE5XZ3RNbll6ZWsweE5DQTFkakpvTTNZemFESldOV2d0TlhvaUx6NEtQQzl6ZG1jK0NnPT0nKTtcbiAgdGhpcy5JQ09OUy5leGl0RnVsbHNjcmVlbiA9IFV0aWwuYmFzZTY0KCdpbWFnZS9zdmcreG1sJywgJ1BITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlOSEI0SWlCb1pXbG5hSFE5SWpJMGNIZ2lJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lnWm1sc2JEMGlJMFpHUmtaR1JpSStDaUFnSUNBOGNHRjBhQ0JrUFNKTk1DQXdhREkwZGpJMFNEQjZJaUJtYVd4c1BTSnViMjVsSWk4K0NpQWdJQ0E4Y0dGMGFDQmtQU0pOTlNBeE5tZ3pkak5vTW5ZdE5VZzFkako2YlRNdE9FZzFkakpvTlZZMVNEaDJNM3B0TmlBeE1XZ3lkaTB6YUROMkxUSm9MVFYyTlhwdE1pMHhNVlkxYUMweWRqVm9OVlk0YUMwemVpSXZQZ284TDNOMlp6NEsnKTtcbiAgdGhpcy5JQ09OUy5zZXR0aW5ncyA9IFV0aWwuYmFzZTY0KCdpbWFnZS9zdmcreG1sJywgJ1BITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlOSEI0SWlCb1pXbG5hSFE5SWpJMGNIZ2lJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lnWm1sc2JEMGlJMFpHUmtaR1JpSStDaUFnSUNBOGNHRjBhQ0JrUFNKTk1DQXdhREkwZGpJMFNEQjZJaUJtYVd4c1BTSnViMjVsSWk4K0NpQWdJQ0E4Y0dGMGFDQmtQU0pOTVRrdU5ETWdNVEl1T1RoakxqQTBMUzR6TWk0d055MHVOalF1TURjdExqazRjeTB1TURNdExqWTJMUzR3TnkwdU9UaHNNaTR4TVMweExqWTFZeTR4T1MwdU1UVXVNalF0TGpReUxqRXlMUzQyTkd3dE1pMHpMalEyWXkwdU1USXRMakl5TFM0ek9TMHVNeTB1TmpFdExqSXliQzB5TGpRNUlERmpMUzQxTWkwdU5DMHhMakE0TFM0M015MHhMalk1TFM0NU9Hd3RMak00TFRJdU5qVkRNVFF1TkRZZ01pNHhPQ0F4TkM0eU5TQXlJREUwSURKb0xUUmpMUzR5TlNBd0xTNDBOaTR4T0MwdU5Ea3VOREpzTFM0ek9DQXlMalkxWXkwdU5qRXVNalV0TVM0eE55NDFPUzB4TGpZNUxqazRiQzB5TGpRNUxURmpMUzR5TXkwdU1Ea3RMalE1SURBdExqWXhMakl5YkMweUlETXVORFpqTFM0eE15NHlNaTB1TURjdU5Ea3VNVEl1TmpSc01pNHhNU0F4TGpZMVl5MHVNRFF1TXpJdExqQTNMalkxTFM0d055NDVPSE11TURNdU5qWXVNRGN1T1Roc0xUSXVNVEVnTVM0Mk5XTXRMakU1TGpFMUxTNHlOQzQwTWkwdU1USXVOalJzTWlBekxqUTJZeTR4TWk0eU1pNHpPUzR6TGpZeExqSXliREl1TkRrdE1XTXVOVEl1TkNBeExqQTRMamN6SURFdU5qa3VPVGhzTGpNNElESXVOalZqTGpBekxqSTBMakkwTGpReUxqUTVMalF5YURSakxqSTFJREFnTGpRMkxTNHhPQzQwT1MwdU5ESnNMak00TFRJdU5qVmpMall4TFM0eU5TQXhMakUzTFM0MU9TQXhMalk1TFM0NU9Hd3lMalE1SURGakxqSXpMakE1TGpRNUlEQWdMall4TFM0eU1td3lMVE11TkRaakxqRXlMUzR5TWk0d055MHVORGt0TGpFeUxTNDJOR3d0TWk0eE1TMHhMalkxZWsweE1pQXhOUzQxWXkweExqa3pJREF0TXk0MUxURXVOVGN0TXk0MUxUTXVOWE14TGpVM0xUTXVOU0F6TGpVdE15NDFJRE11TlNBeExqVTNJRE11TlNBekxqVXRNUzQxTnlBekxqVXRNeTQxSURNdU5Yb2lMejRLUEM5emRtYytDZz09Jyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1dHRvbk1hbmFnZXI7XG5cbn0se1wiLi9lbWl0dGVyLmpzXCI6MixcIi4vbW9kZXMuanNcIjozLFwiLi91dGlsLmpzXCI6NH1dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgdGhpcy5jYWxsYmFja3MgPSB7fTtcbn1cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3NbZXZlbnROYW1lXTtcbiAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAvL2NvbnNvbGUubG9nKCdObyB2YWxpZCBjYWxsYmFjayBzcGVjaWZpZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAvLyBFbGltaW5hdGUgdGhlIGZpcnN0IHBhcmFtICh0aGUgY2FsbGJhY2spLlxuICBhcmdzLnNoaWZ0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG59O1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgaWYgKGV2ZW50TmFtZSBpbiB0aGlzLmNhbGxiYWNrcykge1xuICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50TmFtZV0ucHVzaChjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5jYWxsYmFja3NbZXZlbnROYW1lXSA9IFtjYWxsYmFja107XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxufSx7fV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG52YXIgTW9kZXMgPSB7XG4gIFVOS05PV046IDAsXG4gIC8vIE5vdCBmdWxsc2NyZWVuLCBqdXN0IHRyYWNraW5nLlxuICBOT1JNQUw6IDEsXG4gIC8vIE1hZ2ljIHdpbmRvdyBpbW1lcnNpdmUgbW9kZS5cbiAgTUFHSUNfV0lORE9XOiAyLFxuICAvLyBGdWxsIHNjcmVlbiBzcGxpdCBzY3JlZW4gVlIgbW9kZS5cbiAgVlI6IDMsXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVzO1xuXG59LHt9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbnZhciBVdGlsID0ge307XG5cblV0aWwuYmFzZTY0ID0gZnVuY3Rpb24obWltZVR5cGUsIGJhc2U2NCkge1xuICByZXR1cm4gJ2RhdGE6JyArIG1pbWVUeXBlICsgJztiYXNlNjQsJyArIGJhc2U2NDtcbn07XG5cblV0aWwuaXNNb2JpbGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNoZWNrID0gZmFsc2U7XG4gIChmdW5jdGlvbihhKXtpZigvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXJpc3xraW5kbGV8bGdlIHxtYWVtb3xtaWRwfG1tcHxtb2JpbGUuK2ZpcmVmb3h8bmV0ZnJvbnR8b3BlcmEgbShvYnxpbilpfHBhbG0oIG9zKT98cGhvbmV8cChpeGl8cmUpXFwvfHBsdWNrZXJ8cG9ja2V0fHBzcHxzZXJpZXMoNHw2KTB8c3ltYmlhbnx0cmVvfHVwXFwuKGJyb3dzZXJ8bGluayl8dm9kYWZvbmV8d2FwfHdpbmRvd3MgY2V8eGRhfHhpaW5vL2kudGVzdChhKXx8LzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2kudGVzdChhLnN1YnN0cigwLDQpKSljaGVjayA9IHRydWV9KShuYXZpZ2F0b3IudXNlckFnZW50fHxuYXZpZ2F0b3IudmVuZG9yfHx3aW5kb3cub3BlcmEpO1xuICByZXR1cm4gY2hlY2s7XG59O1xuXG5VdGlsLmlzRmlyZWZveCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gL2ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufTtcblxuVXRpbC5pc0lPUyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gLyhpUGFkfGlQaG9uZXxpUG9kKS9nLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59O1xuXG5VdGlsLmlzSUZyYW1lID0gZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5zZWxmICE9PSB3aW5kb3cudG9wO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblV0aWwuYXBwZW5kUXVlcnlQYXJhbWV0ZXIgPSBmdW5jdGlvbih1cmwsIGtleSwgdmFsdWUpIHtcbiAgLy8gRGV0ZXJtaW5lIGRlbGltaXRlciBiYXNlZCBvbiBpZiB0aGUgVVJMIGFscmVhZHkgR0VUIHBhcmFtZXRlcnMgaW4gaXQuXG4gIHZhciBkZWxpbWl0ZXIgPSAodXJsLmluZGV4T2YoJz8nKSA8IDAgPyAnPycgOiAnJicpO1xuICB1cmwgKz0gZGVsaW1pdGVyICsga2V5ICsgJz0nICsgdmFsdWU7XG4gIHJldHVybiB1cmw7XG59O1xuXG4vLyBGcm9tIGh0dHA6Ly9nb28uZ2wvNFdYM3RnXG5VdGlsLmdldFF1ZXJ5UGFyYW1ldGVyID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgbmFtZSA9IG5hbWUucmVwbGFjZSgvW1xcW10vLCBcIlxcXFxbXCIpLnJlcGxhY2UoL1tcXF1dLywgXCJcXFxcXVwiKTtcbiAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChcIltcXFxcPyZdXCIgKyBuYW1lICsgXCI9KFteJiNdKilcIiksXG4gICAgICByZXN1bHRzID0gcmVnZXguZXhlYyhsb2NhdGlvbi5zZWFyY2gpO1xuICByZXR1cm4gcmVzdWx0cyA9PT0gbnVsbCA/IFwiXCIgOiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0c1sxXS5yZXBsYWNlKC9cXCsvZywgXCIgXCIpKTtcbn07XG5cblV0aWwuaXNMYW5kc2NhcGVNb2RlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAod2luZG93Lm9yaWVudGF0aW9uID09IDkwIHx8IHdpbmRvdy5vcmllbnRhdGlvbiA9PSAtOTApO1xufTtcblxuVXRpbC5nZXRTY3JlZW5XaWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTWF0aC5tYXgod2luZG93LnNjcmVlbi53aWR0aCwgd2luZG93LnNjcmVlbi5oZWlnaHQpICpcbiAgICAgIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xufTtcblxuVXRpbC5nZXRTY3JlZW5IZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGgubWluKHdpbmRvdy5zY3JlZW4ud2lkdGgsIHdpbmRvdy5zY3JlZW4uaGVpZ2h0KSAqXG4gICAgICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVXRpbDtcblxufSx7fV0sNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG52YXIgQnV0dG9uTWFuYWdlciA9IF9kZXJlcV8oJy4vYnV0dG9uLW1hbmFnZXIuanMnKTtcbnZhciBFbWl0dGVyID0gX2RlcmVxXygnLi9lbWl0dGVyLmpzJyk7XG52YXIgTW9kZXMgPSBfZGVyZXFfKCcuL21vZGVzLmpzJyk7XG52YXIgVXRpbCA9IF9kZXJlcV8oJy4vdXRpbC5qcycpO1xuXG4vKipcbiAqIEhlbHBlciBmb3IgZ2V0dGluZyBpbiBhbmQgb3V0IG9mIFZSIG1vZGUuXG4gKi9cbmZ1bmN0aW9uIFdlYlZSTWFuYWdlcihyZW5kZXJlciwgZWZmZWN0LCBwYXJhbXMpIHtcbiAgdGhpcy5wYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgdGhpcy5tb2RlID0gTW9kZXMuVU5LTk9XTjtcblxuICAvLyBTZXQgb3B0aW9uIHRvIGhpZGUgdGhlIGJ1dHRvbi5cbiAgdGhpcy5oaWRlQnV0dG9uID0gdGhpcy5wYXJhbXMuaGlkZUJ1dHRvbiB8fCBmYWxzZTtcbiAgLy8gV2hldGhlciBvciBub3QgdGhlIEZPViBzaG91bGQgYmUgZGlzdG9ydGVkIG9yIHVuLWRpc3RvcnRlZC4gQnkgZGVmYXVsdCwgaXRcbiAgLy8gc2hvdWxkIGJlIGRpc3RvcnRlZCwgYnV0IGluIHRoZSBjYXNlIG9mIHZlcnRleCBzaGFkZXIgYmFzZWQgZGlzdG9ydGlvbixcbiAgLy8gZW5zdXJlIHRoYXQgd2UgdXNlIHVuZGlzdG9ydGVkIHBhcmFtZXRlcnMuXG4gIHRoaXMucHJlZGlzdG9ydGVkID0gISF0aGlzLnBhcmFtcy5wcmVkaXN0b3J0ZWQ7XG5cbiAgLy8gU2F2ZSB0aGUgVEhSRUUuanMgcmVuZGVyZXIgYW5kIGVmZmVjdCBmb3IgbGF0ZXIuXG4gIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgdGhpcy5lZmZlY3QgPSBlZmZlY3Q7XG4gIHZhciBwb2x5ZmlsbFdyYXBwZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcud2VidnItcG9seWZpbGwtZnVsbHNjcmVlbi13cmFwcGVyJyk7XG4gIHRoaXMuYnV0dG9uID0gbmV3IEJ1dHRvbk1hbmFnZXIocG9seWZpbGxXcmFwcGVyKTtcblxuICB0aGlzLmlzRnVsbHNjcmVlbkRpc2FibGVkID0gISFVdGlsLmdldFF1ZXJ5UGFyYW1ldGVyKCdub19mdWxsc2NyZWVuJyk7XG4gIHRoaXMuc3RhcnRNb2RlID0gTW9kZXMuTk9STUFMO1xuICB2YXIgc3RhcnRNb2RlUGFyYW0gPSBwYXJzZUludChVdGlsLmdldFF1ZXJ5UGFyYW1ldGVyKCdzdGFydF9tb2RlJykpO1xuICBpZiAoIWlzTmFOKHN0YXJ0TW9kZVBhcmFtKSkge1xuICAgIHRoaXMuc3RhcnRNb2RlID0gc3RhcnRNb2RlUGFyYW07XG4gIH1cblxuICBpZiAodGhpcy5oaWRlQnV0dG9uKSB7XG4gICAgdGhpcy5idXR0b24uc2V0VmlzaWJpbGl0eShmYWxzZSk7XG4gIH1cblxuICAvLyBDaGVjayBpZiB0aGUgYnJvd3NlciBpcyBjb21wYXRpYmxlIHdpdGggV2ViVlIuXG4gIHRoaXMuZ2V0RGV2aWNlQnlUeXBlXyhWUkRpc3BsYXkpLnRoZW4oZnVuY3Rpb24oaG1kKSB7XG4gICAgdGhpcy5obWQgPSBobWQ7XG5cbiAgICAvLyBPbmx5IGVuYWJsZSBWUiBtb2RlIGlmIHRoZXJlJ3MgYSBWUiBkZXZpY2UgYXR0YWNoZWQgb3Igd2UgYXJlIHJ1bm5pbmcgdGhlXG4gICAgLy8gcG9seWZpbGwgb24gbW9iaWxlLlxuICAgIGlmICghdGhpcy5pc1ZSQ29tcGF0aWJsZU92ZXJyaWRlKSB7XG4gICAgICB0aGlzLmlzVlJDb21wYXRpYmxlID0gICFobWQuaXNQb2x5ZmlsbGVkIHx8IFV0aWwuaXNNb2JpbGUoKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuc3RhcnRNb2RlKSB7XG4gICAgICBjYXNlIE1vZGVzLk1BR0lDX1dJTkRPVzpcbiAgICAgICAgdGhpcy5zZXRNb2RlXyhNb2Rlcy5NQUdJQ19XSU5ET1cpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTW9kZXMuVlI6XG4gICAgICAgIHRoaXMuZW50ZXJWUk1vZGVfKCk7XG4gICAgICAgIHRoaXMuc2V0TW9kZV8oTW9kZXMuVlIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuc2V0TW9kZV8oTW9kZXMuTk9STUFMKTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ2luaXRpYWxpemVkJyk7XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgLy8gSG9vayB1cCBidXR0b24gbGlzdGVuZXJzLlxuICB0aGlzLmJ1dHRvbi5vbignZnMnLCB0aGlzLm9uRlNDbGlja18uYmluZCh0aGlzKSk7XG4gIHRoaXMuYnV0dG9uLm9uKCd2cicsIHRoaXMub25WUkNsaWNrXy5iaW5kKHRoaXMpKTtcblxuICAvLyBCaW5kIHRvIGZ1bGxzY3JlZW4gZXZlbnRzLlxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJyxcbiAgICAgIHRoaXMub25GdWxsc2NyZWVuQ2hhbmdlXy5iaW5kKHRoaXMpKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW96ZnVsbHNjcmVlbmNoYW5nZScsXG4gICAgICB0aGlzLm9uRnVsbHNjcmVlbkNoYW5nZV8uYmluZCh0aGlzKSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21zZnVsbHNjcmVlbmNoYW5nZScsXG4gICAgICB0aGlzLm9uRnVsbHNjcmVlbkNoYW5nZV8uYmluZCh0aGlzKSk7XG5cbiAgLy8gQmluZCB0byBWUiogc3BlY2lmaWMgZXZlbnRzLlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndnJkaXNwbGF5cHJlc2VudGNoYW5nZScsXG4gICAgICB0aGlzLm9uVlJEaXNwbGF5UHJlc2VudENoYW5nZV8uYmluZCh0aGlzKSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd2cmRpc3BsYXlkZXZpY2VwYXJhbXNjaGFuZ2UnLFxuICAgICAgdGhpcy5vblZSRGlzcGxheURldmljZVBhcmFtc0NoYW5nZV8uYmluZCh0aGlzKSk7XG59XG5cbldlYlZSTWFuYWdlci5wcm90b3R5cGUgPSBuZXcgRW1pdHRlcigpO1xuXG4vLyBFeHBvc2UgdGhlc2UgdmFsdWVzIGV4dGVybmFsbHkuXG5XZWJWUk1hbmFnZXIuTW9kZXMgPSBNb2RlcztcblxuV2ViVlJNYW5hZ2VyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzY2VuZSwgY2FtZXJhLCB0aW1lc3RhbXApIHtcbiAgLy8gU2NlbmUgbWF5IGJlIGFuIGFycmF5IG9mIHR3byBzY2VuZXMsIG9uZSBmb3IgZWFjaCBleWUuXG4gIGlmIChzY2VuZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdGhpcy5lZmZlY3QucmVuZGVyKHNjZW5lWzBdLCBjYW1lcmEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZWZmZWN0LnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgfVxufTtcblxuV2ViVlJNYW5hZ2VyLnByb3RvdHlwZS5zZXRWUkNvbXBhdGlibGVPdmVycmlkZSA9IGZ1bmN0aW9uKGlzVlJDb21wYXRpYmxlKSB7XG4gIHRoaXMuaXNWUkNvbXBhdGlibGUgPSBpc1ZSQ29tcGF0aWJsZTtcbiAgdGhpcy5pc1ZSQ29tcGF0aWJsZU92ZXJyaWRlID0gdHJ1ZTtcblxuICAvLyBEb24ndCBhY3R1YWxseSBjaGFuZ2UgbW9kZXMsIGp1c3QgdXBkYXRlIHRoZSBidXR0b25zLlxuICB0aGlzLmJ1dHRvbi5zZXRNb2RlKHRoaXMubW9kZSwgdGhpcy5pc1ZSQ29tcGF0aWJsZSk7XG59O1xuXG5XZWJWUk1hbmFnZXIucHJvdG90eXBlLnNldEZ1bGxzY3JlZW5DYWxsYmFjayA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHRoaXMuZnVsbHNjcmVlbkNhbGxiYWNrID0gY2FsbGJhY2s7XG59O1xuXG5XZWJWUk1hbmFnZXIucHJvdG90eXBlLnNldFZSQ2FsbGJhY2sgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB0aGlzLnZyQ2FsbGJhY2sgPSBjYWxsYmFjaztcbn07XG5cbldlYlZSTWFuYWdlci5wcm90b3R5cGUuc2V0RXhpdEZ1bGxzY3JlZW5DYWxsYmFjayA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHRoaXMuZXhpdEZ1bGxzY3JlZW5DYWxsYmFjayA9IGNhbGxiYWNrO1xufVxuXG4vKipcbiAqIFByb21pc2UgcmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBITUQgZGV2aWNlIGF2YWlsYWJsZS5cbiAqL1xuV2ViVlJNYW5hZ2VyLnByb3RvdHlwZS5nZXREZXZpY2VCeVR5cGVfID0gZnVuY3Rpb24odHlwZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbmF2aWdhdG9yLmdldFZSRGlzcGxheXMoKS50aGVuKGZ1bmN0aW9uKGRpc3BsYXlzKSB7XG4gICAgICAvLyBQcm9taXNlIHN1Y2NlZWRzLCBidXQgY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBkaXNwbGF5cyBhY3R1YWxseS5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGRpc3BsYXlzW2ldIGluc3RhbmNlb2YgdHlwZSkge1xuICAgICAgICAgIHJlc29sdmUoZGlzcGxheXNbaV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXNvbHZlKG51bGwpO1xuICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gTm8gZGlzcGxheXMgYXJlIGZvdW5kLlxuICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEhlbHBlciBmb3IgZW50ZXJpbmcgVlIgbW9kZS5cbiAqL1xuV2ViVlJNYW5hZ2VyLnByb3RvdHlwZS5lbnRlclZSTW9kZV8gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5obWQucmVxdWVzdFByZXNlbnQoW3tcbiAgICBzb3VyY2U6IHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCxcbiAgICBwcmVkaXN0b3J0ZWQ6IHRoaXMucHJlZGlzdG9ydGVkXG4gIH1dKTtcbn07XG5cbldlYlZSTWFuYWdlci5wcm90b3R5cGUuc2V0TW9kZV8gPSBmdW5jdGlvbihtb2RlKSB7XG4gIHZhciBvbGRNb2RlID0gdGhpcy5tb2RlO1xuICBpZiAobW9kZSA9PSB0aGlzLm1vZGUpIHtcbiAgICBjb25zb2xlLndhcm4oJ05vdCBjaGFuZ2luZyBtb2RlcywgYWxyZWFkeSBpbiAlcycsIG1vZGUpO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBjb25zb2xlLmxvZygnTW9kZSBjaGFuZ2U6ICVzID0+ICVzJywgdGhpcy5tb2RlLCBtb2RlKTtcbiAgdGhpcy5tb2RlID0gbW9kZTtcbiAgdGhpcy5idXR0b24uc2V0TW9kZShtb2RlLCB0aGlzLmlzVlJDb21wYXRpYmxlKTtcblxuICAvLyBFbWl0IGFuIGV2ZW50IGluZGljYXRpbmcgdGhlIG1vZGUgY2hhbmdlZC5cbiAgdGhpcy5lbWl0KCdtb2RlY2hhbmdlJywgbW9kZSwgb2xkTW9kZSk7XG59O1xuXG4vKipcbiAqIE1haW4gYnV0dG9uIHdhcyBjbGlja2VkLlxuICovXG5XZWJWUk1hbmFnZXIucHJvdG90eXBlLm9uRlNDbGlja18gPSBmdW5jdGlvbigpIHtcbiAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICBjYXNlIE1vZGVzLk5PUk1BTDpcbiAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIGhhY2sgaWYvd2hlbiBpT1MgZ2V0cyByZWFsIGZ1bGxzY3JlZW4gbW9kZS5cbiAgICAgIC8vIElmIHRoaXMgaXMgYW4gaWZyYW1lIG9uIGlPUywgYnJlYWsgb3V0IGFuZCBvcGVuIGluIG5vX2Z1bGxzY3JlZW4gbW9kZS5cbiAgICAgIGlmIChVdGlsLmlzSU9TKCkgJiYgVXRpbC5pc0lGcmFtZSgpKSB7XG4gICAgICAgIGlmICh0aGlzLmZ1bGxzY3JlZW5DYWxsYmFjaykge1xuICAgICAgICAgIHRoaXMuZnVsbHNjcmVlbkNhbGxiYWNrKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgICAgICAgIHVybCA9IFV0aWwuYXBwZW5kUXVlcnlQYXJhbWV0ZXIodXJsLCAnbm9fZnVsbHNjcmVlbicsICd0cnVlJyk7XG4gICAgICAgICAgdXJsID0gVXRpbC5hcHBlbmRRdWVyeVBhcmFtZXRlcih1cmwsICdzdGFydF9tb2RlJywgTW9kZXMuTUFHSUNfV0lORE9XKTtcbiAgICAgICAgICB0b3AubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0TW9kZV8oTW9kZXMuTUFHSUNfV0lORE9XKTtcbiAgICAgIHRoaXMucmVxdWVzdEZ1bGxzY3JlZW5fKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIE1vZGVzLk1BR0lDX1dJTkRPVzpcbiAgICAgIGlmICh0aGlzLmlzRnVsbHNjcmVlbkRpc2FibGVkKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZXhpdEZ1bGxzY3JlZW5DYWxsYmFjaykge1xuICAgICAgICB0aGlzLmV4aXRGdWxsc2NyZWVuQ2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0TW9kZV8oTW9kZXMuTk9STUFMKTtcbiAgICAgIHRoaXMuZXhpdEZ1bGxzY3JlZW5fKCk7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgVlIgYnV0dG9uIHdhcyBjbGlja2VkLlxuICovXG5XZWJWUk1hbmFnZXIucHJvdG90eXBlLm9uVlJDbGlja18gPSBmdW5jdGlvbigpIHtcbiAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgaGFjayB3aGVuIGlPUyBoYXMgZnVsbHNjcmVlbiBtb2RlLlxuICAvLyBJZiB0aGlzIGlzIGFuIGlmcmFtZSBvbiBpT1MsIGJyZWFrIG91dCBhbmQgb3BlbiBpbiBub19mdWxsc2NyZWVuIG1vZGUuXG4gIGlmICh0aGlzLm1vZGUgPT0gTW9kZXMuTk9STUFMICYmIFV0aWwuaXNJT1MoKSAmJiBVdGlsLmlzSUZyYW1lKCkpIHtcbiAgICBpZiAodGhpcy52ckNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnZyQ2FsbGJhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgICAgdXJsID0gVXRpbC5hcHBlbmRRdWVyeVBhcmFtZXRlcih1cmwsICdub19mdWxsc2NyZWVuJywgJ3RydWUnKTtcbiAgICAgIHVybCA9IFV0aWwuYXBwZW5kUXVlcnlQYXJhbWV0ZXIodXJsLCAnc3RhcnRfbW9kZScsIE1vZGVzLlZSKTtcbiAgICAgIHRvcC5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICB0aGlzLmVudGVyVlJNb2RlXygpO1xufTtcblxuV2ViVlJNYW5hZ2VyLnByb3RvdHlwZS5yZXF1ZXN0RnVsbHNjcmVlbl8gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmJvZHk7XG4gIC8vdmFyIGNhbnZhcyA9IHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudDtcbiAgaWYgKGNhbnZhcy5yZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgIGNhbnZhcy5yZXF1ZXN0RnVsbHNjcmVlbigpO1xuICB9IGVsc2UgaWYgKGNhbnZhcy5tb3pSZXF1ZXN0RnVsbFNjcmVlbikge1xuICAgIGNhbnZhcy5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpO1xuICB9IGVsc2UgaWYgKGNhbnZhcy53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgIGNhbnZhcy53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICB9IGVsc2UgaWYgKGNhbnZhcy5tc1JlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgY2FudmFzLm1zUmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgfVxufTtcblxuV2ViVlJNYW5hZ2VyLnByb3RvdHlwZS5leGl0RnVsbHNjcmVlbl8gPSBmdW5jdGlvbigpIHtcbiAgaWYgKGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKSB7XG4gICAgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKSB7XG4gICAgZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbigpO1xuICB9IGVsc2UgaWYgKGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKSB7XG4gICAgZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4oKTtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuKSB7XG4gICAgZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbigpO1xuICB9XG59O1xuXG5XZWJWUk1hbmFnZXIucHJvdG90eXBlLm9uVlJEaXNwbGF5UHJlc2VudENoYW5nZV8gPSBmdW5jdGlvbihlKSB7XG4gIGNvbnNvbGUubG9nKCdvblZSRGlzcGxheVByZXNlbnRDaGFuZ2VfJywgZSk7XG4gIGlmICh0aGlzLmhtZC5pc1ByZXNlbnRpbmcpIHtcbiAgICB0aGlzLnNldE1vZGVfKE1vZGVzLlZSKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNldE1vZGVfKE1vZGVzLk5PUk1BTCk7XG4gIH1cbn07XG5cbldlYlZSTWFuYWdlci5wcm90b3R5cGUub25WUkRpc3BsYXlEZXZpY2VQYXJhbXNDaGFuZ2VfID0gZnVuY3Rpb24oZSkge1xuICBjb25zb2xlLmxvZygnb25WUkRpc3BsYXlEZXZpY2VQYXJhbXNDaGFuZ2VfJywgZSk7XG59O1xuXG5XZWJWUk1hbmFnZXIucHJvdG90eXBlLm9uRnVsbHNjcmVlbkNoYW5nZV8gPSBmdW5jdGlvbihlKSB7XG4gIC8vIElmIHdlIGxlYXZlIGZ1bGwtc2NyZWVuLCBnbyBiYWNrIHRvIG5vcm1hbCBtb2RlLlxuICBpZiAoZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQgPT09IG51bGwgfHxcbiAgICAgIGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50ID09PSBudWxsKSB7XG4gICAgdGhpcy5zZXRNb2RlXyhNb2Rlcy5OT1JNQUwpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlZSTWFuYWdlcjtcblxufSx7XCIuL2J1dHRvbi1tYW5hZ2VyLmpzXCI6MSxcIi4vZW1pdHRlci5qc1wiOjIsXCIuL21vZGVzLmpzXCI6MyxcIi4vdXRpbC5qc1wiOjR9XX0se30sWzVdKSg1KVxufSk7IiwiKGZ1bmN0aW9uKHNlbGYpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmIChzZWxmLmZldGNoKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIHNlbGYsXG4gICAgaXRlcmFibGU6ICdTeW1ib2wnIGluIHNlbGYgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gICAgYmxvYjogJ0ZpbGVSZWFkZXInIGluIHNlbGYgJiYgJ0Jsb2InIGluIHNlbGYgJiYgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pKCksXG4gICAgZm9ybURhdGE6ICdGb3JtRGF0YScgaW4gc2VsZixcbiAgICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBzZWxmXG4gIH1cblxuICBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICAgIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICAgIF1cblxuICAgIHZhciBpc0RhdGFWaWV3ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iailcbiAgICB9XG5cbiAgICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPSBBcnJheUJ1ZmZlci5pc1ZpZXcgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTFcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLlxcXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuICBmdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykge1xuICAgIHZhciBpdGVyYXRvciA9IHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpXG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpdGVyYXRvclxuICB9XG5cbiAgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgdGhpcy5tYXAgPSB7fVxuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICB9LCB0aGlzKVxuXG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy5tYXBbbmFtZV1cbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUrJywnK3ZhbHVlIDogdmFsdWVcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICAgIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbFxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2gobmFtZSkgfSlcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXVxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkgeyBpdGVtcy5wdXNoKHZhbHVlKSB9KVxuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXVxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkgeyBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pIH0pXG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllc1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICAgIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gICAgfVxuICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgICB9XG4gICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYilcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pXG4gICAgfVxuICAgIHJldHVybiBjaGFycy5qb2luKCcnKVxuICB9XG5cbiAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gICAgaWYgKGJ1Zi5zbGljZSkge1xuICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKVxuICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSlcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cbiAgICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keVxuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKVxuICAgICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgQm9keUluaXQgdHlwZScpXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKVxuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgcmV0dXJuIChtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSkgPyB1cGNhc2VkIDogbWV0aG9kXG4gIH1cblxuICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMudXJsID0gaW5wdXRcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IGlucHV0LnVybFxuICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKVxuICAgICAgfVxuICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2RcbiAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGVcbiAgICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ29taXQnXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpXG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7IGJvZHk6IHRoaXMuX2JvZHlJbml0IH0pXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gICAgcmF3SGVhZGVycy5zcGxpdCgnXFxyXFxuJykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6JylcbiAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKVxuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpXG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCdcbiAgICB0aGlzLnN0YXR1cyA9ICdzdGF0dXMnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1cyA6IDIwMFxuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDBcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnc3RhdHVzVGV4dCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzVGV4dCA6ICdPSydcbiAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJ1xuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KVxuICB9XG5cbiAgQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSlcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KVxuICAgIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuICBSZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxuICB9XG5cbiAgc2VsZi5IZWFkZXJzID0gSGVhZGVyc1xuICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0XG4gIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZVxuXG4gIHNlbGYuZmV0Y2ggPSBmdW5jdGlvbihpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnVybCA9ICdyZXNwb25zZVVSTCcgaW4geGhyID8geGhyLnJlc3BvbnNlVVJMIDogb3B0aW9ucy5oZWFkZXJzLmdldCgnWC1SZXF1ZXN0LVVSTCcpXG4gICAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKVxuICAgICAgfVxuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSlcblxuICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyICYmIHN1cHBvcnQuYmxvYikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InXG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgfSlcblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdClcbiAgICB9KVxuICB9XG4gIHNlbGYuZmV0Y2gucG9seWZpbGwgPSB0cnVlXG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG4iLCJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlyZSBleHRlbmRzIFRIUkVFLk9iamVjdDNEIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLm51bVBhcnRpY2xlcyA9IDEwMDBcblxuICAgIHRoaXMub3B0cyA9IHtcbiAgICAgIHNwYXJrTGlmZWN5Y2xlOiAwLjcsXG4gICAgICBzcGFya1N0YXJ0U2l6ZTogMTAsXG4gICAgICBzcGFya0VuZFNpemU6IDIwLFxuICAgICAgc3BhcmtEaXN0YW5jZVNjYWxlOiAxLjUsXG5cbiAgICAgIGZsYW1lTWluSGVpZ2h0OiAwLjAyLFxuICAgICAgZmxhbWVNYXhIZWlnaHQ6IDAuMjUsXG4gICAgICBmbGFtZVBlcmlvZDogMC41LFxuICAgICAgd2luZFN0cmVuZ3RoOiAwLjE0LFxuICAgICAgd2luZEZyZXF1ZW5jeTogMC41LFxuXG4gICAgICBjb2xvcjogMHhmY2M2NDgsXG4gICAgICBlbmRDb2xvcjogMHhjMDU2MWMsXG5cbiAgICAgIG9wYWNpdHk6IDAuNyxcbiAgICAgIGdyYXZpdHk6IDAuMixcblxuICAgICAgLy8gc3RhdGljIC0gc2V0IGF0IHN0YXJ0XG4gICAgICBiYXNlV2lkdGg6IDAuOCAvLyBhbmdsZSAtIG11bHRpcGxlIG9mIFBJXG4gICAgfVxuXG4gICAgdmFyIHRleHR1cmVMb2FkZXIgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpXG4gICAgdGV4dHVyZUxvYWRlci5sb2FkKCdodHRwczovL3MzLXVzLXdlc3QtMi5hbWF6b25hd3MuY29tL3MuY2Rwbi5pby8xMjY3NDcvc25vd2ZsYWtlXzE2eDE2LnBuZycsICh0ZXh0dXJlKSA9PiB7XG4gICAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlXG4gICAgICB0aGlzLnN5c3RlbS5tYXRlcmlhbC51bmlmb3Jtcy50ZXh0dXJlLnZhbHVlID0gdGV4dHVyZVxuICAgIH0pXG4gIH1cblxuICBpbml0ICgpIHtcbiAgICAvLyBtYWtlIHN1cmUgZ3Jhdml0eSBwb2ludHMgaW4gd29ybGQgWVxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2NDE4NzUvdGhyZWUtanMtaG93LXRvLWZpbmQtd29ybGQtb3JpZW50YXRpb24tdmVjdG9yLW9mLW9iamVjdHMtbG9jYWwtdXAtdmVjdG9yXG4gICAgdmFyIHYzID0gbmV3IFRIUkVFLlZlY3RvcjMoKVxuICAgIHYzLmNvcHkodGhpcy51cCkuYXBwbHlRdWF0ZXJuaW9uKHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCkuaW52ZXJzZSgpKVxuXG4gICAgY29uc3Qgc3lzdGVtR2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKVxuICAgIGNvbnN0IHN5c3RlbU1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHVwOiB7IHR5cGU6ICd2MycsIHZhbHVlOiB2MyB9LFxuICAgICAgICBncmF2aXR5OiB7IHR5cGU6ICdmJywgdmFsdWU6IHRoaXMub3B0cy5ncmF2aXR5IH0sXG4gICAgICAgIGVsYXBzZWRUaW1lOiB7IHR5cGU6ICdmJywgdmFsdWU6IDAuMCB9LFxuICAgICAgICBudW1QYXJ0aWNsZXM6IHsgdHlwZTogJ2YnLCB2YWx1ZTogdGhpcy5udW1QYXJ0aWNsZXMgfSxcbiAgICAgICAgY29sb3I6IHsgdHlwZTogJ2MnLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKHRoaXMub3B0cy5jb2xvcikgfSxcbiAgICAgICAgZW5kQ29sb3I6IHsgdHlwZTogJ2MnLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKHRoaXMub3B0cy5lbmRDb2xvcikgfSxcbiAgICAgICAgZmxhbWVNYXhIZWlnaHQ6IHsgdHlwZTogJ2YnLCB2YWx1ZTogdGhpcy5vcHRzLmZsYW1lTWF4SGVpZ2h0IH0sXG4gICAgICAgIGZsYW1lTWluSGVpZ2h0OiB7IHR5cGU6ICdmJywgdmFsdWU6IHRoaXMub3B0cy5mbGFtZU1pbkhlaWdodCB9LFxuICAgICAgICBmbGFtZVBlcmlvZDogeyB0eXBlOiAnZicsIHZhbHVlOiB0aGlzLm9wdHMuZmxhbWVQZXJpb2QgfSxcbiAgICAgICAgd2luZFN0cmVuZ3RoOiB7IHR5cGU6ICdmJywgdmFsdWU6IHRoaXMub3B0cy53aW5kU3RyZW5ndGggfSxcbiAgICAgICAgd2luZEZyZXF1ZW5jeTogeyB0eXBlOiAnZicsIHZhbHVlOiB0aGlzLm9wdHMud2luZEZyZXF1ZW5jeSB9LFxuICAgICAgICBzcGFya0xpZmVjeWNsZTogeyB0eXBlOiAnZicsIHZhbHVlOiB0aGlzLm9wdHMuc3BhcmtMaWZlY3ljbGUgfSxcbiAgICAgICAgc3BhcmtEaXN0YW5jZVNjYWxlOiB7IHR5cGU6ICdmJywgdmFsdWU6IHRoaXMub3B0cy5zcGFya0Rpc3RhbmNlU2NhbGUgfSxcbiAgICAgICAgc3BhcmtTdGFydFNpemU6IHsgdHlwZTogJ2YnLCB2YWx1ZTogdGhpcy5vcHRzLnNwYXJrU3RhcnRTaXplIH0sXG4gICAgICAgIHNwYXJrRW5kU2l6ZTogeyB0eXBlOiAnZicsIHZhbHVlOiB0aGlzLm9wdHMuc3BhcmtFbmRTaXplIH0sXG4gICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ2YnLCB2YWx1ZTogdGhpcy5vcHRzLm9wYWNpdHkgfSxcbiAgICAgICAgdGV4dHVyZTogeyB0eXBlOiAndCcsIHZhbHVlOiBudWxsIH1cbiAgICAgIH0sXG4gICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgIC8vIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgIC8vIE5PVEU6IGRvbid0IHVzZSBhZGRpdGl2ZSBibGVuZGluZyBmb3IgbGlnaHQgYmFja2dyb3VuZHNcbiAgICAgIC8vIGh0dHA6Ly9hbnN3ZXJzLnVuaXR5M2QuY29tL3F1ZXN0aW9ucy81NzM3MTcvcGFydGljbGUtZWZmZWN0cy1hZ2FpbnN0LWxpZ2h0LWJhY2tncm91bmRzLmh0bWxcbiAgICAgIC8vIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nLFxuICAgICAgdmVydGV4U2hhZGVyOiBgXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgZWxhcHNlZFRpbWU7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgbnVtUGFydGljbGVzO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IGdyYXZpdHk7XG4gICAgICAgIHVuaWZvcm0gdmVjMyB1cDtcblxuICAgICAgICB1bmlmb3JtIGZsb2F0IHNwYXJrTGlmZWN5Y2xlO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IHNwYXJrRGlzdGFuY2VTY2FsZTtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBzcGFya1N0YXJ0U2l6ZTtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBzcGFya0VuZFNpemU7XG5cbiAgICAgICAgdW5pZm9ybSBmbG9hdCBmbGFtZU1heEhlaWdodDtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBmbGFtZU1pbkhlaWdodDtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBmbGFtZVBlcmlvZDtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCB3aW5kU3RyZW5ndGg7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgd2luZEZyZXF1ZW5jeTtcblxuICAgICAgICBhdHRyaWJ1dGUgdmVjMyBkaXJlY3Rpb247XG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCB1bmlxdWVuZXNzO1xuICAgICAgICBhdHRyaWJ1dGUgZmxvYXQgcGFydGljbGVJbmRleDtcblxuICAgICAgICAjZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5XG5cbiAgICAgICAgdmFyeWluZyBmbG9hdCB2VGltZTtcblxuICAgICAgICB2b2lkIG1haW4oIHZvaWQgKSB7XG4gICAgICAgICAgLy8gdW5pcXVlIGR1cmF0aW9uXG4gICAgICAgICAgZmxvYXQgZHVyYXRpb24gPSBzcGFya0xpZmVjeWNsZSArIHNwYXJrTGlmZWN5Y2xlICogdW5pcXVlbmVzcztcblxuICAgICAgICAgIC8vIG1ha2UgdGltZSBsb29wXG4gICAgICAgICAgZmxvYXQgcGFydGljbGVPZmZzZXQgPSAocGFydGljbGVJbmRleCAvIG51bVBhcnRpY2xlcyAqIGR1cmF0aW9uKTtcbiAgICAgICAgICBmbG9hdCB0aW1lID0gbW9kKGVsYXBzZWRUaW1lICsgcGFydGljbGVPZmZzZXQsIGR1cmF0aW9uKTtcblxuICAgICAgICAgIC8vIHN0b3JlIHRpbWUgYXMgMC0xIGZvciBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgICB2VGltZSA9IHRpbWUgLyBkdXJhdGlvbjtcblxuICAgICAgICAgIC8vIGFwcGx5IFwiZ3Jhdml0eVwiIHRvIGZpcmVcbiAgICAgICAgICB2ZWMzIHZHcmF2aXR5ID0gdXAgKiBncmF2aXR5ICogcG93KHZUaW1lLCAyLjApO1xuXG4gICAgICAgICAgLy8gbW92ZSBpbiBkaXJlY3Rpb24gYmFzZWQgb24gZWxhcHNlZCB0aW1lXG4gICAgICAgICAgZmxvYXQgZmxhbWVIZWlnaHQgPSBtaXgoZmxhbWVNaW5IZWlnaHQsIGZsYW1lTWF4SGVpZ2h0LCB1bmlxdWVuZXNzKTtcbiAgICAgICAgICB2ZWMzIHZEaXN0YW5jZSA9IGZsYW1lSGVpZ2h0ICogZGlyZWN0aW9uICogdlRpbWU7XG5cbiAgICAgICAgICAvLyBjbG9zZSBmbGFtZSBhdCB0b3AgKDAuNSBpcyBmdWxseSBjbG9zZWQpXG4gICAgICAgICAgdkRpc3RhbmNlLnh6ICo9IGNvcyhtaXgoMC4wLCBQSSAqIGZsYW1lUGVyaW9kLCB2VGltZSkpO1xuXG4gICAgICAgICAgLy8gYXBwbHkgc29tZSByYW5kb20gaG9yaXpvbmFsIHdpbmRcbiAgICAgICAgICB2ZWMzIHZXaW5kID0gc2luKChlbGFwc2VkVGltZSArIHZUaW1lICogdW5pcXVlbmVzcykgKiB3aW5kRnJlcXVlbmN5ICogdW5pcXVlbmVzcykgKiBjcm9zcyh1cCwgZGlyZWN0aW9uKSAqIHdpbmRTdHJlbmd0aCAqIHVuaXF1ZW5lc3MgKiB2VGltZTtcblxuICAgICAgICAgIC8vIGFkZCBhbGwgZm9yY2VzIHRvIGdldCBmaW5hbCBwb3NpdGlvbiBmb3IgdGhpcyBmcmFtZVxuICAgICAgICAgIHZlYzMgcG9zID0gcG9zaXRpb24gKyB2RGlzdGFuY2UgKyB2R3Jhdml0eSArIHZXaW5kO1xuXG4gICAgICAgICAgLy8gU2V0IHNpemUgYmFzZWQgb24gZnJhbWUgYW5kIGRpc3RhbmNlXG4gICAgICAgICAgdmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zLCAxLjAgKTtcbiAgICAgICAgICBnbF9Qb2ludFNpemUgPSBtaXgoc3BhcmtTdGFydFNpemUsIHNwYXJrRW5kU2l6ZSwgdlRpbWUpO1xuICAgICAgICAgIGdsX1BvaW50U2l6ZSA9IGdsX1BvaW50U2l6ZSAqIChzcGFya0Rpc3RhbmNlU2NhbGUgLyBsZW5ndGgobXZQb3NpdGlvbi54eXopKTtcblxuICAgICAgICAgIC8vIHByb2plY3QgcG9zaXRpb24gb24gc2NyZWVuXG4gICAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3MsIDEuMCk7XG4gICAgICAgIH1cblxuICAgICAgYCxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBgXG4gICAgICAgIHVuaWZvcm0gdmVjMyBjb2xvcjtcbiAgICAgICAgdW5pZm9ybSB2ZWMzIGVuZENvbG9yO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XG5cbiAgICAgICAgdmFyeWluZyBmbG9hdCB2VGltZTtcblxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh0ZXh0dXJlLCBnbF9Qb2ludENvb3JkKTtcbiAgICAgICAgICB2ZWM0IHN0YXJ0Q29sb3IgPSB2ZWM0KGNvbG9yLCBvcGFjaXR5KTtcbiAgICAgICAgICB2ZWM0IGVuZENvbG9yID0gdmVjNChlbmRDb2xvciwgMC4wKTtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXhDb2xvciAqIG1peChzdGFydENvbG9yLCBlbmRDb2xvciwgdlRpbWUpO1xuICAgICAgICB9XG4gICAgICBgXG4gICAgfSlcblxuICAgIC8vIGFsbCBmbGFtZXMgc3RhcnQgYXQgMCwwLDBcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMubnVtUGFydGljbGVzICogMylcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgcG9zaXRpb25zW2ldID0gMFxuICAgIH1cblxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5udW1QYXJ0aWNsZXMgKiAzKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlyZWN0aW9uLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICBjb25zdCBwaGkgPSB0aGlzLnJhbmRDZW50ZXIoTWF0aC5QSSAqIHRoaXMub3B0cy5iYXNlV2lkdGgpXG4gICAgICBjb25zdCB0aGV0YSA9IHRoaXMucmFuZENlbnRlcihNYXRoLlBJKVxuICAgICAgLy8gY3JlYXRlIG5vcm1hbCB2ZWN0b3IgaW4gcmFuZG9tIGRpcmVjdGlvblxuICAgICAgY29uc3Qgc3BoZXJlQ29vcmQgPSBUSFJFRS5TcGhlcmljYWwoMSwgcGhpLCB0aGV0YSlcblxuICAgICAgY29uc3QgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKClcbiAgICAgIHYuc2V0RnJvbVNwaGVyaWNhbChzcGhlcmVDb29yZClcbiAgICAgIGRpcmVjdGlvbltpXSA9IHYueFxuICAgICAgZGlyZWN0aW9uW2kgKyAxXSA9IHYueVxuICAgICAgZGlyZWN0aW9uW2kgKyAyXSA9IHYuelxuICAgIH1cblxuICAgIC8vIHB1c2ggc29tZSB1bmlxdWVuZXNzIC0gYmVjYXVzZSBlbnRyb3B5Li4uXG4gICAgY29uc3QgdW5pcXVlbmVzcyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5udW1QYXJ0aWNsZXMpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm51bVBhcnRpY2xlczsgaSsrKSB7XG4gICAgICB1bmlxdWVuZXNzW2ldID0gTWF0aC5yYW5kb20oKVxuICAgIH1cblxuICAgIC8vIHJlbWVtYmVyIHBhcnRpY2xlIGluZGV4XG4gICAgY29uc3QgcGFydGljbGVJbmRleCA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5udW1QYXJ0aWNsZXMpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm51bVBhcnRpY2xlczsgaSsrKSB7XG4gICAgICBwYXJ0aWNsZUluZGV4W2ldID0gaVxuICAgIH1cblxuICAgIHN5c3RlbUdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9ucywgMykpXG4gICAgc3lzdGVtR2VvbWV0cnkuYWRkQXR0cmlidXRlKCdkaXJlY3Rpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKGRpcmVjdGlvbiwgMykpXG4gICAgc3lzdGVtR2VvbWV0cnkuYWRkQXR0cmlidXRlKCd1bmlxdWVuZXNzJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh1bmlxdWVuZXNzLCAxKSlcbiAgICBzeXN0ZW1HZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ3BhcnRpY2xlSW5kZXgnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHBhcnRpY2xlSW5kZXgsIDEpKVxuXG4gICAgc3lzdGVtR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKClcbiAgICB0aGlzLnN5c3RlbSA9IG5ldyBUSFJFRS5Qb2ludHMoc3lzdGVtR2VvbWV0cnksIHN5c3RlbU1hdGVyaWFsKVxuXG4gICAgdGhpcy5hZGQodGhpcy5zeXN0ZW0pXG5cbiAgICB0aGlzLnN5c3RlbS5yZW5kZXJPcmRlciA9IDJcbiAgfVxuXG4gIHVwZGF0ZSAoZGVsdGEsIGVsYXBzZWQpIHtcbiAgICB0aGlzLnN5c3RlbS5tYXRlcmlhbC51bmlmb3Jtcy5lbGFwc2VkVGltZS52YWx1ZSA9IGVsYXBzZWRcblxuICAgIHZhciB1cCA9IG5ldyBUSFJFRS5WZWN0b3IzKClcbiAgICB1cC5jb3B5KHRoaXMudXApLmFwcGx5UXVhdGVybmlvbih0aGlzLmdldFdvcmxkUXVhdGVybmlvbigpLmludmVyc2UoKSlcbiAgICB0aGlzLnN5c3RlbS5tYXRlcmlhbC51bmlmb3Jtcy51cC52YWx1ZSA9IHVwXG4gIH1cblxuICB1cGRhdGVPbmUgKG9wdCkge1xuICAgIHRoaXMuc3lzdGVtLm1hdGVyaWFsLnVuaWZvcm1zW29wdF0udmFsdWUgPSB0aGlzLm9wdHNbb3B0XVxuICB9XG5cbiAgdXBkYXRlQ29sb3IgKG9wdCkge1xuICAgIHRoaXMuc3lzdGVtLm1hdGVyaWFsLnVuaWZvcm1zW29wdF0udmFsdWUgPSBuZXcgVEhSRUUuQ29sb3IodGhpcy5vcHRzW29wdF0pXG4gIH1cblxuICByYW5kQ2VudGVyICh2KSB7XG4gICAgcmV0dXJuICh2ICogKE1hdGgucmFuZG9tKCkgLSAwLjUpKVxuICB9XG59XG4iLCJpbXBvcnQge2NvbnZlcnRNYXRlcmlhbHNUb0xhbWJlcnR9IGZyb20gJy4vdXRpbHMvbWF0ZXJpYWwtdXRpbCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JvdW5kIHtcblxuICBjb25zdHJ1Y3RvciAoc2NlbmUsIG9iamVjdExvYWRlciwgc25vd0hlaWdodCkge1xuICAgIHdpbmRvdy5mZXRjaCgnYXNzZXRzL21vZGVscy9zbm93Y2FwLmpzb24nKVxuICAgIC50aGVuKFxuICAgICAgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdMb29rcyBsaWtlIHRoZXJlIHdhcyBhIHByb2JsZW0uIFN0YXR1cyBDb2RlOiAnICsgcmVzcG9uc2Uuc3RhdHVzKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIC8vIEV4YW1pbmUgdGhlIHRleHQgaW4gdGhlIHJlc3BvbnNlXG4gICAgICAgIHJlc3BvbnNlLmpzb24oKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgY29udmVydE1hdGVyaWFsc1RvTGFtYmVydChkYXRhKVxuICAgICAgICAgIGNvbnN0IG9iaiA9IG9iamVjdExvYWRlci5wYXJzZShkYXRhKVxuICAgICAgICAgIG9iai5wb3NpdGlvbi55ID0gc25vd0hlaWdodCArIDAuMVxuICAgICAgICAgIG9iai5zY2FsZS5zZXRTY2FsYXIoMC4zNSlcbiAgICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIC8vICAgb2JqLmNoaWxkcmVuW2ldLmdlb21ldHJ5LmNvbXB1dGVGbGF0VmVydGV4Tm9ybWFscygpXG4gICAgICAgICAgLy8gfVxuICAgICAgICAgIHNjZW5lLmFkZChvYmopXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgKVxuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSdcbmltcG9ydCB7Y29udmVydE1hdGVyaWFsc1RvTGFtYmVydH0gZnJvbSAnLi91dGlscy9tYXRlcmlhbC11dGlsJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIYW5kIGV4dGVuZHMgVEhSRUUuT2JqZWN0M0Qge1xuXG4gIGNvbnN0cnVjdG9yIChvYmplY3RMb2FkZXIsIG1vZGVsU3JjKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5vYmplY3RMb2FkZXIgPSBvYmplY3RMb2FkZXJcbiAgICB0aGlzLm1vZGVsU3JjID0gbW9kZWxTcmNcbiAgICB0aGlzLmFjdGlvbiA9IHt9XG5cbiAgICB0aGlzLmxvYWQoKVxuICB9XG5cbiAgbG9hZCAoKSB7XG4gICAgd2luZG93LmZldGNoKHRoaXMubW9kZWxTcmMpXG4gICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0xvb2tzIGxpa2UgdGhlcmUgd2FzIGEgcHJvYmxlbS4gU3RhdHVzIENvZGU6ICcgKyByZXNwb25zZS5zdGF0dXMpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gcGFyc2UganNvblxuICAgICAgcmVzcG9uc2UuanNvbigpLnRoZW4odGhpcy5oYW5kbGVEYXRhLmJpbmQodGhpcykpXG4gICAgfSlcbiAgfVxuXG4gIGhhbmRsZURhdGEgKGRhdGEpIHtcbiAgICBjb252ZXJ0TWF0ZXJpYWxzVG9MYW1iZXJ0KGRhdGEpXG5cbiAgICAvLyBlbmFibGUgc2tpbm5lZCBhbmltYXRpb25cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubWF0ZXJpYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhLm1hdGVyaWFsc1tpXS5za2lubmluZyA9IHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBvYmogPSB0aGlzLm9iamVjdExvYWRlci5wYXJzZShkYXRhKVxuXG4gICAgLy8gbWFrZSBmbGF0IHNoYWRlZFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmouY2hpbGRyZW5baV0uZ2VvbWV0cnkuY29tcHV0ZUZsYXRWZXJ0ZXhOb3JtYWxzKClcbiAgICB9XG5cbiAgICBjb25zdCBza2lubmVkTWVzaCA9IG9iai5jaGlsZHJlblswXVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBza2lubmVkTWVzaC5nZW9tZXRyeS5hbmltYXRpb25zXG5cbiAgICB0aGlzLm1peGVyID0gbmV3IFRIUkVFLkFuaW1hdGlvbk1peGVyKHNraW5uZWRNZXNoKVxuICAgIGZvciAobGV0IGFuaW1hdGlvbiBvZiBhbmltYXRpb25zKSB7XG4gICAgICB0aGlzLmFjdGlvblthbmltYXRpb24ubmFtZV0gPSB0aGlzLm1peGVyLmNsaXBBY3Rpb24oYW5pbWF0aW9uLCBza2lubmVkTWVzaClcbiAgICAgIHRoaXMuYWN0aW9uW2FuaW1hdGlvbi5uYW1lXS5zZXRMb29wKFRIUkVFLkxvb3BPbmNlLCAwKVxuICAgICAgdGhpcy5hY3Rpb25bYW5pbWF0aW9uLm5hbWVdLmNsYW1wV2hlbkZpbmlzaGVkID0gdHJ1ZVxuICAgIH1cblxuICAgIHRoaXMuYWRkKG9iailcbiAgfVxuXG4gIHVwZGF0ZSAoZGVsdGEpIHtcbiAgICBpZiAodGhpcy5taXhlcikge1xuICAgICAgdGhpcy5taXhlci51cGRhdGUoZGVsdGEpXG4gICAgfVxuICB9XG5cbiAgZ3JpcCAoKSB7XG4gICAgdGhpcy5hY3Rpb25bJ0dyaXAnXS5wbGF5KClcbiAgfVxuXG4gIHJlbGVhc2UgKCkge1xuICAgIHRoaXMuYWN0aW9uWydHcmlwJ10uc3RvcCgpXG4gIH1cbn1cbiIsImltcG9ydCAnd2hhdHdnLWZldGNoJ1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnXG5pbXBvcnQgcXVlcnkgZnJvbSAnLi91dGlscy9xdWVyeSdcbmltcG9ydCBHcm91bmQgZnJvbSAnLi9ncm91bmQnXG5pbXBvcnQgVHJlZWxpbmUgZnJvbSAnLi90cmVlbGluZSdcbmltcG9ydCBNb29zZSBmcm9tICcuL21vb3NlJ1xuaW1wb3J0IFNub3dmYWxsIGZyb20gJy4vc25vd2ZhbGwnXG5pbXBvcnQgVG9yY2ggZnJvbSAnLi90b3JjaCdcbmltcG9ydCBIYW5kIGZyb20gJy4vaGFuZCdcblxuaW1wb3J0IFNub3dwdWZmIGZyb20gJy4vc25vd3B1ZmYnXG5cbi8vIGxvYWQgc2hpbW1lZCBwbHVnaW5zIC0gYWNjZXNzIG9uIFRIUkVFIG5hbWVzcGFjZVxuaW1wb3J0IF9PQkpMb2FkZXIgZnJvbSAnT0JKTG9hZGVyJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQgX1ZSQ29udHJvbHMgZnJvbSAnVlJDb250cm9scycgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IF9WUkVmZmVjdCBmcm9tICdWUkVmZmVjdCcgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IF9WaXZlQ29udHJvbGxlciBmcm9tICdWaXZlQ29udHJvbGxlcicgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4vLyBJbXBvcnQgV2ViVlJNYW5hZ2VyIG5wbSBtb2R1bGVcbmltcG9ydCBXZWJWUk1hbmFnZXIgZnJvbSAnd2VidnItYm9pbGVycGxhdGUnXG5cbmNvbnN0IFNOT1dfSEVJR0hUID0gMC41XG5cbmNvbnN0IGNsb2NrID0gbmV3IFRIUkVFLkNsb2NrKClcbmNvbnN0IGpzb25Mb2FkZXIgPSBuZXcgVEhSRUUuSlNPTkxvYWRlcigpXG5jb25zdCBvYmplY3RMb2FkZXIgPSBuZXcgVEhSRUUuT2JqZWN0TG9hZGVyKClcblxuLy8gdXNlciBvYmplY3RzIHRoYXQgbmVlZCB1cGRhdGUgb24gZWFjaCBmcmFtZVxuY29uc3QgdXBkYXRlT2JqZWN0cyA9IFtdXG5cbmxldCBzY2VuZSwgY2FtZXJhLCBIRUlHSFQsIFdJRFRILCByZW5kZXJlciwgY29udGFpbmVyXG5sZXQgdnJDb250cm9scywgdnJFZmZlY3QsIHZyTWFuYWdlciwgdnJEaXNwbGF5XG5sZXQgdml2ZUNvbnRyb2xsZXIxLCB2aXZlQ29udHJvbGxlcjJcblxubGV0IGdyb3VuZCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5sZXQgdHJlZWxpbmUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG5jb25zdCBpc05pZ2h0ID0gcXVlcnkuaXNOaWdodFxuY29uc3QgYmdDb2xvciA9IGlzTmlnaHQgPyAweDExMTEyMiA6IDB4YzZjY2ZmXG5cbmZ1bmN0aW9uIGNyZWF0ZVNjZW5lICgpIHtcbiAgSEVJR0hUID0gd2luZG93LmlubmVySGVpZ2h0XG4gIFdJRFRIID0gd2luZG93LmlubmVyV2lkdGhcblxuICAvLyBDcmVhdGUgdGhlIHNjZW5lXG4gIHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKClcblxuICAvLyBBZGQgYSBmb2cgdnJFZmZlY3QgdG8gdGhlIHNjZW5lIHVzaW5nIHNpbWlsYXIgY29sb3IgYXMgYmFja2dyb3VuZFxuICAvLyBzY2VuZS5mb2cgPSBuZXcgVEhSRUUuRm9nKDB4YzZjY2ZmLCA0LCAxMSlcbiAgc2NlbmUuZm9nID0gbmV3IFRIUkVFLkZvZ0V4cDIoYmdDb2xvciwgMC4xNSlcblxuICAvLyBDcmVhdGUgdGhlIGNhbWVyYVxuICBjb25zdCBhc3BlY3RSYXRpbyA9IFdJRFRIIC8gSEVJR0hUXG4gIGNvbnN0IGZpZWxkT2ZWaWV3ID0gNjBcbiAgY29uc3QgbmVhclBsYW5lID0gMC4wNVxuICBjb25zdCBmYXJQbGFuZSA9IDUwXG4gIGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYShcbiAgICBmaWVsZE9mVmlldyxcbiAgICBhc3BlY3RSYXRpbyxcbiAgICBuZWFyUGxhbmUsXG4gICAgZmFyUGxhbmVcbiAgKVxuXG4gIC8vIENyZWF0ZSB0aGUgcmVuZGVyZXJcbiAgcmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgLy8gQWxsb3cgdHJhbnNwYXJlbmN5IHRvIHNob3cgdGhlIGdyYWRpZW50IGJhY2tncm91bmRcbiAgICAvLyB3ZSBkZWZpbmVkIGluIHRoZSBDU1NcbiAgICBhbHBoYTogZmFsc2UsXG4gICAgLy8gQWN0aXZhdGUgdGhlIGFudGktYWxpYXNpbmcgdGhpcyBpcyBsZXNzIHBlcmZvcm1hbnQsXG4gICAgLy8gYnV0LCBhcyBvdXIgcHJvamVjdCBpcyBsb3ctcG9seSBiYXNlZCwgaXQgc2hvdWxkIGJlIGZpbmUgOilcbiAgICBhbnRpYWxpYXM6IHRydWVcbiAgfSlcblxuICByZW5kZXJlci5zZXRQaXhlbFJhdGlvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKVxuICByZW5kZXJlci5zZXRDbGVhckNvbG9yKGJnQ29sb3IsIDEpXG5cbiAgLy8gRGVmaW5lIHRoZSBzaXplIG9mIHRoZSByZW5kZXJlciBpbiB0aGlzIGNhc2UsXG4gIC8vIGl0IHdpbGwgZmlsbCB0aGUgZW50aXJlIHNjcmVlblxuICByZW5kZXJlci5zZXRTaXplKFdJRFRILCBIRUlHSFQpXG5cbiAgLy8gRW5hYmxlIHNoYWRvdyByZW5kZXJpbmdcbiAgcmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgPSB0cnVlXG4gIHJlbmRlcmVyLnNoYWRvd01hcC50eXBlID0gVEhSRUUuUENGU29mdFNoYWRvd01hcFxuXG4gIC8vIEFkZCB0aGUgRE9NIGVsZW1lbnQgb2YgdGhlIHJlbmRlcmVyIHRvIHRoZVxuICAvLyBjb250YWluZXIgd2UgY3JlYXRlZCBpbiB0aGUgSFRNTFxuICBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd29ybGQnKVxuICBjb250YWluZXIuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudClcbn1cblxuZnVuY3Rpb24gaGFuZGxlV2luZG93UmVzaXplICgpIHtcbiAgLy8gdXBkYXRlIGhlaWdodCBhbmQgd2lkdGggb2YgdGhlIHJlbmRlcmVyIGFuZCB0aGUgY2FtZXJhXG4gIEhFSUdIVCA9IHdpbmRvdy5pbm5lckhlaWdodFxuICBXSURUSCA9IHdpbmRvdy5pbm5lcldpZHRoXG4gIHZyRWZmZWN0LnNldFNpemUoV0lEVEgsIEhFSUdIVClcbiAgcmVuZGVyZXIuc2V0U2l6ZShXSURUSCwgSEVJR0hUKVxuICBjYW1lcmEuYXNwZWN0ID0gV0lEVEggLyBIRUlHSFRcbiAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVMaWdodHMgKCkge1xuICAvLyBBIGRpcmVjdGlvbmFsIGxpZ2h0IHNoaW5lcyBmcm9tIGEgc3BlY2lmaWMgZGlyZWN0aW9uLlxuICAvLyBJdCBhY3RzIGxpa2UgdGhlIHN1biwgdGhhdCBtZWFucyB0aGF0IGFsbCB0aGUgcmF5cyBwcm9kdWNlZCBhcmUgcGFyYWxsZWwuXG4gIGNvbnN0IHNoYWRvd0xpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoMHhmZmZmZmYsIDAuMSlcblxuICAvLyBTZXQgdGhlIGRpcmVjdGlvbiBvZiB0aGUgbGlnaHRcbiAgc2hhZG93TGlnaHQucG9zaXRpb24uc2V0KDEsIDIsIC0xKVxuICBzaGFkb3dMaWdodC5wb3NpdGlvbi5ub3JtYWxpemUoKVxuXG4gIC8vIEFsbG93IHNoYWRvdyBjYXN0aW5nXG4gIHNoYWRvd0xpZ2h0LmNhc3RTaGFkb3cgPSB0cnVlXG5cbiAgLy8gZGVmaW5lIHRoZSB2aXNpYmxlIGFyZWEgb2YgdGhlIHByb2plY3RlZCBzaGFkb3dcbiAgc2hhZG93TGlnaHQuc2hhZG93LmNhbWVyYS5sZWZ0ID0gLTEwXG4gIHNoYWRvd0xpZ2h0LnNoYWRvdy5jYW1lcmEucmlnaHQgPSAxMFxuICBzaGFkb3dMaWdodC5zaGFkb3cuY2FtZXJhLnRvcCA9IDEwXG4gIHNoYWRvd0xpZ2h0LnNoYWRvdy5jYW1lcmEuYm90dG9tID0gLTEwXG4gIHNoYWRvd0xpZ2h0LnNoYWRvdy5jYW1lcmEubmVhciA9IC0xMFxuICBzaGFkb3dMaWdodC5zaGFkb3cuY2FtZXJhLmZhciA9IDEwXG5cbiAgLy8gZGVidWcgbGlnaHRcbiAgaWYgKHF1ZXJ5LmRlYnVnKSB7XG4gICAgc2NlbmUuYWRkKG5ldyBUSFJFRS5DYW1lcmFIZWxwZXIoc2hhZG93TGlnaHQuc2hhZG93LmNhbWVyYSkpXG4gIH1cblxuICAvLyBkZWZpbmUgdGhlIHJlc29sdXRpb24gb2YgdGhlIHNoYWRvdyB0aGUgaGlnaGVyIHRoZSBiZXR0ZXIsXG4gIC8vIGJ1dCBhbHNvIHRoZSBtb3JlIGV4cGVuc2l2ZSBhbmQgbGVzcyBwZXJmb3JtYW50XG4gIHNoYWRvd0xpZ2h0LnNoYWRvdy5tYXBTaXplLndpZHRoID0gMTAyNCAqIDJcbiAgc2hhZG93TGlnaHQuc2hhZG93Lm1hcFNpemUuaGVpZ2h0ID0gMTAyNCAqIDJcblxuICAvLyBhbiBhbWJpZW50IGxpZ2h0IG1vZGlmaWVzIHRoZSBnbG9iYWwgY29sb3Igb2YgYSBzY2VuZSBhbmQgbWFrZXMgdGhlIHNoYWRvd3Mgc29mdGVyXG4gIGNvbnN0IGFtYmllbnRMaWdodCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoMHhmZmZmZmYsIDEuMylcbiAgaWYgKGlzTmlnaHQpIHtcbiAgICBhbWJpZW50TGlnaHQuaW50ZW5zaXR5ID0gMC4xXG4gIH1cblxuICBzY2VuZS5hZGQoc2hhZG93TGlnaHQpXG4gIHNjZW5lLmFkZChhbWJpZW50TGlnaHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNub3dGYWxsICgpIHtcbiAgY29uc3Qgc25vd2ZhbGwgPSBuZXcgU25vd2ZhbGwoMTAwMDAwKVxuICBzbm93ZmFsbC5zeXN0ZW0ucG9zaXRpb24uc2V0KDAsIFNOT1dfSEVJR0hULCAwKVxuICBzY2VuZS5hZGQoc25vd2ZhbGwuc3lzdGVtKVxuICByZXR1cm4gc25vd2ZhbGxcbn1cblxuZnVuY3Rpb24gY3JlYXRlSGFuZHMgKCkge1xuICBpZiAodml2ZUNvbnRyb2xsZXIxKSB7XG4gICAgY29uc3QgaGFuZEwgPSBuZXcgSGFuZChvYmplY3RMb2FkZXIsICdhc3NldHMvbW9kZWxzL2hhbmRzL2hhbmRzRm9yT2N1bHVzL2hhbmRMLmpzb24nKVxuICAgIHZpdmVDb250cm9sbGVyMS5hZGQoaGFuZEwpXG4gICAgdml2ZUNvbnRyb2xsZXIxLmFkZEV2ZW50TGlzdGVuZXIoJ3RyaWdnZXJkb3duJywgKCkgPT4gaGFuZEwuZ3JpcCgpKVxuICAgIHZpdmVDb250cm9sbGVyMS5hZGRFdmVudExpc3RlbmVyKCd0cmlnZ2VydXAnLCAoKSA9PiBoYW5kTC5yZWxlYXNlKCkpXG4gICAgdXBkYXRlT2JqZWN0cy5wdXNoKGhhbmRMKVxuXG4gICAgaWYgKGlzTmlnaHQpIHtcbiAgICAgIC8vIHRlbXA6IGFkZCBzdHVmZiB0byBoYW5kc1xuICAgICAgY29uc3QgdG9yY2ggPSBuZXcgVG9yY2goKVxuICAgICAgLy8gdG9yY2gucG9zaXRpb24ueSA9IDEuMzVcbiAgICAgIHRvcmNoLnBvc2l0aW9uLnogPSAwLjA0XG4gICAgICB0b3JjaC5wb3NpdGlvbi55ID0gLTAuMDJcbiAgICAgIHRvcmNoLnJvdGF0aW9uLnogPSAtTWF0aC5QSSAvIDJcbiAgICAgIHRvcmNoLnJvdGF0aW9uLnkgPSBNYXRoLlBJIC8gNFxuXG4gICAgICAvLyBzY2VuZS5hZGQodG9yY2gpXG5cbiAgICAgIGhhbmRMLmFkZCh0b3JjaClcbiAgICAgIHVwZGF0ZU9iamVjdHMucHVzaCh0b3JjaClcbiAgICAgIC8vIHRlc3Qgcm90YXRlIGhhbmRcbiAgICAgIGhhbmRMLnJvdGF0aW9uLnogPSBNYXRoLlBJIC8gNFxuICAgIH1cbiAgfVxuXG4gIGlmICh2aXZlQ29udHJvbGxlcjIpIHtcbiAgICBjb25zdCBoYW5kUiA9IG5ldyBIYW5kKG9iamVjdExvYWRlciwgJ2Fzc2V0cy9tb2RlbHMvaGFuZHMvaGFuZHNGb3JPY3VsdXMvaGFuZFIuanNvbicpXG4gICAgdml2ZUNvbnRyb2xsZXIyLmFkZChoYW5kUilcbiAgICB2aXZlQ29udHJvbGxlcjIuYWRkRXZlbnRMaXN0ZW5lcigndHJpZ2dlcmRvd24nLCAoKSA9PiBoYW5kUi5ncmlwKCkpXG4gICAgdml2ZUNvbnRyb2xsZXIyLmFkZEV2ZW50TGlzdGVuZXIoJ3RyaWdnZXJ1cCcsICgpID0+IGhhbmRSLnJlbGVhc2UoKSlcbiAgICB1cGRhdGVPYmplY3RzLnB1c2goaGFuZFIpXG4gIH1cblxuICAvLyB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKCkgPT4gdG9yY2gub24oKSlcbiAgLy8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoKSA9PiB0b3JjaC5vZmYoKSlcbiAgLy8gdml2ZUNvbnRyb2xsZXIxLmFkZEV2ZW50TGlzdGVuZXIoJ3RyaWdnZXJkb3duJywgKCkgPT4gdG9yY2gub24oKSlcbiAgLy8gdml2ZUNvbnRyb2xsZXIxLmFkZEV2ZW50TGlzdGVuZXIoJ3RyaWdnZXJ1cCcsICgpID0+IHRvcmNoLm9mZigpKVxufVxuXG5mdW5jdGlvbiBsb29wICgpIHtcbiAgdmFyIGRlbHRhID0gY2xvY2suZ2V0RGVsdGEoKVxuICB2YXIgZWxhcHNlZCA9IGNsb2NrLmdldEVsYXBzZWRUaW1lKClcblxuICBpZiAodml2ZUNvbnRyb2xsZXIxKSB7XG4gICAgdml2ZUNvbnRyb2xsZXIxLnVwZGF0ZSgpXG4gIH1cbiAgaWYgKHZpdmVDb250cm9sbGVyMikge1xuICAgIHZpdmVDb250cm9sbGVyMi51cGRhdGUoKVxuICB9XG5cbiAgLy8gdXBkYXRlIHVzZXIgb2JqZWN0c1xuICBmb3IgKGxldCBvYmplY3Qgb2YgdXBkYXRlT2JqZWN0cykge1xuICAgIG9iamVjdC51cGRhdGUoZGVsdGEsIGVsYXBzZWQpXG4gIH1cblxuICAvLyBSZW5kZXIgdGhlIHNjZW5lIHRocm91Z2ggdGhlIHZyTWFuYWdlci5cbiAgdnJDb250cm9scy51cGRhdGUoZGVsdGEpXG4gIHZyTWFuYWdlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSwgZGVsdGEpXG5cbiAgLy8gY2FsbCB0aGUgbG9vcCBmdW5jdGlvbiBhZ2FpblxuICB2ckRpc3BsYXkucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXG59XG5cbmZ1bmN0aW9uIGxvYWRWaXZlQ29udHJvbGxlck1vZGVscyAoKSB7XG4gIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuT0JKTG9hZGVyKClcbiAgbG9hZGVyLnNldFBhdGgoJ2Fzc2V0cy9tb2RlbHMvdml2ZS1jb250cm9sbGVyLycpXG4gIGxvYWRlci5sb2FkKCd2cl9jb250cm9sbGVyX3ZpdmVfMV81Lm9iaicsIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBjb25zb2xlLmxvZygnbG9hZGVkIGNvbnRyb2xsZXIgT0JKJylcbiAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKVxuICAgIGxvYWRlci5zZXRQYXRoKCdhc3NldHMvbW9kZWxzL3ZpdmUtY29udHJvbGxlci8nKVxuXG4gICAgdmFyIGNvbnRyb2xsZXIgPSBvYmplY3QuY2hpbGRyZW5bMF1cbiAgICBjb250cm9sbGVyLm1hdGVyaWFsLm1hcCA9IGxvYWRlci5sb2FkKCdvbmVwb2ludGZpdmVfdGV4dHVyZS5wbmcnKVxuICAgIGNvbnRyb2xsZXIubWF0ZXJpYWwuc3BlY3VsYXJNYXAgPSBsb2FkZXIubG9hZCgnb25lcG9pbnRmaXZlX3NwZWMucG5nJylcblxuICAgIHZpdmVDb250cm9sbGVyMS5hZGQob2JqZWN0LmNsb25lKCkpXG4gICAgdml2ZUNvbnRyb2xsZXIyLmFkZChvYmplY3QuY2xvbmUoKSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gc2hvd0NvbnRyb2xsZXJHdWlkZVJheXMgKCkge1xuICAvLyBzaG93IHJheSBmb3IgZGVidWdcbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KClcbiAgZ2VvbWV0cnkudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKSlcbiAgZ2VvbWV0cnkudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAtMSkpXG5cbiAgdmFyIGxpbmUgPSBuZXcgVEhSRUUuTGluZShnZW9tZXRyeSlcbiAgbGluZS5uYW1lID0gJ2xpbmUnXG4gIGxpbmUuc2NhbGUueiA9IDVcblxuICB2aXZlQ29udHJvbGxlcjEuYWRkKGxpbmUuY2xvbmUoKSlcbiAgdml2ZUNvbnRyb2xsZXIyLmFkZChsaW5lLmNsb25lKCkpXG59XG5cbi8vIFZJVkUgQ09OVFJPTExFUlxuZnVuY3Rpb24gaW5pdFZpdmVDb250cm9sbGVycyAoKSB7XG4gIGlmICghbmF2aWdhdG9yLmdldEdhbWVwYWRzKSB7XG4gICAgY29uc29sZS53YXJuKCdHQU1FUEFEIEFQSSBub3QgZW5hYmxlZD8nKVxuICAgIHJldHVyblxuICB9XG5cbiAgdml2ZUNvbnRyb2xsZXIxID0gbmV3IFRIUkVFLlZpdmVDb250cm9sbGVyKDApXG4gIHZpdmVDb250cm9sbGVyMS5zdGFuZGluZ01hdHJpeCA9IHZyQ29udHJvbHMuZ2V0U3RhbmRpbmdNYXRyaXgoKVxuICBzY2VuZS5hZGQodml2ZUNvbnRyb2xsZXIxKVxuXG4gIHZpdmVDb250cm9sbGVyMiA9IG5ldyBUSFJFRS5WaXZlQ29udHJvbGxlcigxKVxuICB2aXZlQ29udHJvbGxlcjIuc3RhbmRpbmdNYXRyaXggPSB2ckNvbnRyb2xzLmdldFN0YW5kaW5nTWF0cml4KClcbiAgc2NlbmUuYWRkKHZpdmVDb250cm9sbGVyMilcblxuICAvLyBsb2FkVml2ZUNvbnRyb2xsZXJNb2RlbHMoKVxuXG4gIGlmIChxdWVyeS5kZWJ1Zykge1xuICAgIHNob3dDb250cm9sbGVyR3VpZGVSYXlzKClcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0VlIgKCkge1xuICAvLyBBcHBseSBWUiBoZWFkc2V0IHBvc2l0aW9uYWwgZGF0YSB0byBjYW1lcmEuXG4gIHZyQ29udHJvbHMgPSBuZXcgVEhSRUUuVlJDb250cm9scyhjYW1lcmEpXG4gIHZyQ29udHJvbHMuc3RhbmRpbmcgPSB0cnVlXG5cbiAgLy8gQXBwbHkgVlIgc3RlcmVvIHJlbmRlcmluZyB0byByZW5kZXJlci5cbiAgdnJFZmZlY3QgPSBuZXcgVEhSRUUuVlJFZmZlY3QocmVuZGVyZXIpXG4gIHZyRWZmZWN0LnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodClcblxuICAvLyBDcmVhdGUgYSBWUiB2ck1hbmFnZXIgaGVscGVyIHRvIGVudGVyIGFuZCBleGl0IFZSIG1vZGUuXG4gIHZhciBwYXJhbXMgPSB7XG4gICAgaGlkZUJ1dHRvbjogZmFsc2UsIC8vIERlZmF1bHQ6IGZhbHNlLlxuICAgIGlzVW5kaXN0b3J0ZWQ6IGZhbHNlIC8vIERlZmF1bHQ6IGZhbHNlLlxuICB9XG4gIHZyTWFuYWdlciA9IG5ldyBXZWJWUk1hbmFnZXIocmVuZGVyZXIsIHZyRWZmZWN0LCBwYXJhbXMpXG5cbiAgLy8gRm9yIGhpZ2ggZW5kIFZSIGRldmljZXMgbGlrZSBWaXZlIGFuZCBPY3VsdXMsIHRha2UgaW50byBhY2NvdW50IHRoZSBzdGFnZVxuICAvLyBwYXJhbWV0ZXJzIHByb3ZpZGVkLlxuICBzZXR1cFN0YWdlKClcblxuICAvLyBpbml0IGNvbnRyb2xsZXJzXG4gIGluaXRWaXZlQ29udHJvbGxlcnMoKVxuXG4gIC8vIExpc3RlbiB0byB0aGUgc2NyZWVuOiBpZiB0aGUgdXNlciByZXNpemVzIGl0XG4gIC8vIHdlIGhhdmUgdG8gdXBkYXRlIHRoZSBjYW1lcmEgYW5kIHRoZSByZW5kZXJlciBzaXplXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVXaW5kb3dSZXNpemUsIGZhbHNlKVxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndnJkaXNwbGF5cHJlc2VudGNoYW5nZScsIGhhbmRsZVdpbmRvd1Jlc2l6ZSwgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gaW5pdCAoKSB7XG4gIC8vIHNldCB1cCB0aGUgc2NlbmUsIHRoZSBjYW1lcmEgYW5kIHRoZSByZW5kZXJlclxuICBjcmVhdGVTY2VuZSgpXG5cbiAgaW5pdFZSKClcblxuICAvLyBhZGQgdGhlIGxpZ2h0c1xuICBjcmVhdGVMaWdodHMoKVxuXG4gIC8vIGNyZWF0ZSB1c2VyIG9iamVjdHNcbiAgZ3JvdW5kID0gbmV3IEdyb3VuZChzY2VuZSwgb2JqZWN0TG9hZGVyLCBTTk9XX0hFSUdIVClcbiAgdHJlZWxpbmUgPSBuZXcgVHJlZWxpbmUoc2NlbmUpXG5cbiAgY3JlYXRlSGFuZHMoKVxuXG4gIC8vIGtlZXAgdHJhY2sgb2Ygb2JqZWN0cyB0aGF0IG5lZWQgdG8gdXBkYXRlXG4gIHVwZGF0ZU9iamVjdHMucHVzaChjcmVhdGVTbm93RmFsbCgpKVxuICB1cGRhdGVPYmplY3RzLnB1c2gobmV3IE1vb3NlKHNjZW5lLCBqc29uTG9hZGVyKSlcblxuICAvLyBkZWJ1ZyBwdWZmXG4gIC8vIGNvbnN0IHB1ZmYgPSBuZXcgU25vd3B1ZmYoc2NlbmUpXG4gIC8vIHB1ZmYuc3lzdGVtLnBvc2l0aW9uLnNldCgwLCAwLCAtMilcbiAgLy8gc2NlbmUuYWRkKHB1ZmYuc3lzdGVtKVxuICAvLyB1cGRhdGVPYmplY3RzLnB1c2gocHVmZilcbn1cblxuLy8gR2V0IHRoZSBITUQsIGFuZCBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggc29tZXRoaW5nIHRoYXQgc3BlY2lmaWVzXG4vLyBzdGFnZVBhcmFtZXRlcnMsIHJlYXJyYW5nZSB0aGUgc2NlbmUuXG5mdW5jdGlvbiBzZXR1cFN0YWdlICgpIHtcbiAgbmF2aWdhdG9yLmdldFZSRGlzcGxheXMoKS50aGVuKChkaXNwbGF5cykgPT4ge1xuICAgIGlmIChkaXNwbGF5cy5sZW5ndGggPiAwKSB7XG4gICAgICB2ckRpc3BsYXkgPSBkaXNwbGF5c1swXVxuICAgICAgaWYgKHZyRGlzcGxheS5zdGFnZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgc2V0U3RhZ2VEaW1lbnNpb25zKHZyRGlzcGxheS5zdGFnZVBhcmFtZXRlcnMpXG4gICAgICB9XG4gICAgICAvLyBzdGFydCBhIGxvb3AgdGhhdCB3aWxsIHVwZGF0ZSB0aGUgb2JqZWN0cycgcG9zaXRpb25zXG4gICAgICAvLyBhbmQgcmVuZGVyIHRoZSBzY2VuZSBvbiBlYWNoIGZyYW1lXG4gICAgICB2ckRpc3BsYXkucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBzZXRTdGFnZURpbWVuc2lvbnMgKHN0YWdlKSB7XG4gIC8vIFNpemUgdGhlIHNreWJveCBhY2NvcmRpbmcgdG8gdGhlIHNpemUgb2YgdGhlIGFjdHVhbCBzdGFnZS5cbiAgLy8gdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KHN0YWdlLnNpemVYLCBib3hTaXplLCBzdGFnZS5zaXplWik7XG59XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgaW5pdCwgZmFsc2UpXG4iLCJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSdcblxuaW1wb3J0IFNub3dwdWZmIGZyb20gJy4vc25vd3B1ZmYnXG5pbXBvcnQge3JhbmRvbUJldHdlZW4sIHJhbmRvbVBpY2t9IGZyb20gJy4vdXRpbHMvcmFuZG9tLXV0aWwnXG5cbmNvbnN0IE1JTl9ESVNUQU5DRSA9IDAuNSAvLyAxLjVcbmNvbnN0IE1BWF9ESVNUQU5DRSA9IDdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9vc2Uge1xuXG4gIGNvbnN0cnVjdG9yIChzY2VuZSwgbG9hZGVyKSB7XG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lXG4gICAgdGhpcy5zbm93cHVmZnMgPSBbXVxuICAgIHRoaXMubG9hZGVyID0gbG9hZGVyXG5cbiAgICB0aGlzLm1vb3NlU3RhcnQgPSAtMjBcbiAgICB0aGlzLm1vb3NlRGlzdGFuY2UgPSAwXG5cbiAgICB0aGlzLm1vb3NlRmlyc3RUaW1lID0gdHJ1ZVxuICAgIHRoaXMubW9vc2VBbmdsZSA9IE1hdGguUElcblxuICAgIHRoaXMubW9vc2VXcmFwcGVyID0gdW5kZWZpbmVkXG4gICAgdGhpcy5tb29zZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMubWVzaCA9IHVuZGVmaW5lZFxuICAgIHRoaXMubWl4ZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLmFuaW1hdGlvbkNsaXAgPSB1bmRlZmluZWRcbiAgICB0aGlzLmFuaW1hdGlvbkFjdGlvbiA9IHVuZGVmaW5lZFxuXG4gICAgdGhpcy5sb2FkKClcbiAgfVxuXG4gIGxvYWQgKCkge1xuICAgIHRoaXMubG9hZGVyLmxvYWQoXG4gICAgICAvLyByZXNvdXJjZSBVUkxcbiAgICAgICdhc3NldHMvbW9kZWxzL21vb3NlX2xpZmUuanMnLFxuICAgICAgLy8gRnVuY3Rpb24gd2hlbiByZXNvdXJjZSBpcyBsb2FkZWRcbiAgICAgIChnZW9tZXRyeSwgbWF0ZXJpYWxzKSA9PiB7XG4gICAgICAgIHRoaXMubWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCh7XG4gICAgICAgICAgdmVydGV4Q29sb3JzOiBUSFJFRS5GYWNlQ29sb3JzLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0czogdHJ1ZVxuICAgICAgICB9KSlcbiAgICAgICAgdGhpcy5tZXNoLnNjYWxlLnNldFNjYWxhcigwLjAxKVxuICAgICAgICB0aGlzLm1lc2guY2FzdFNoYWRvdyA9IHRydWVcblxuICAgICAgICB0aGlzLm1vb3NlID0gbmV3IFRIUkVFLk9iamVjdDNEKClcbiAgICAgICAgdGhpcy5tb29zZS5hZGQodGhpcy5tZXNoKVxuXG4gICAgICAgIHRoaXMubW9vc2VXcmFwcGVyID0gbmV3IFRIUkVFLk9iamVjdDNEKClcbiAgICAgICAgdGhpcy5tb29zZVdyYXBwZXIuYWRkKHRoaXMubW9vc2UpXG5cbiAgICAgICAgLy8gZGVidWcgcG9zaXRpb25cbiAgICAgICAgLy8gdGhpcy5tb29zZVdyYXBwZXIucG9zaXRpb24uc2V0KDAsIDAsIC0xMClcbiAgICAgICAgLy8gdGhpcy5tb29zZS5yb3RhdGlvbi55ID0gTWF0aC5QSSAvIDJcblxuICAgICAgICAvLyBhZGQgdG8gc2NlbmVcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQodGhpcy5tb29zZVdyYXBwZXIpXG5cbiAgICAgICAgdGhpcy5pbml0QW5pbWF0aW9uKGdlb21ldHJ5KVxuICAgICAgICB0aGlzLmluaXRTbm93RWZmZWN0KClcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBpbml0QW5pbWF0aW9uIChnZW9tZXRyeSkge1xuICAgIHRoaXMubWl4ZXIgPSBuZXcgVEhSRUUuQW5pbWF0aW9uTWl4ZXIodGhpcy5tZXNoKVxuICAgIHRoaXMuYW5pbWF0aW9uQ2xpcCA9IFRIUkVFLkFuaW1hdGlvbkNsaXAuQ3JlYXRlRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2UoJ2dhbGxvcCcsIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cywgNjApXG4gICAgdGhpcy5hbmltYXRpb25BY3Rpb24gPSB0aGlzLm1peGVyLmNsaXBBY3Rpb24odGhpcy5hbmltYXRpb25DbGlwKS5zZXREdXJhdGlvbigxKS5wbGF5KClcbiAgfVxuXG4gIGluaXRTbm93RWZmZWN0ICgpIHtcbiAgICBjb25zdCBwdWZmID0gbmV3IFNub3dwdWZmKHRoaXMuc2NlbmUpXG4gICAgcHVmZi5zeXN0ZW0ucG9zaXRpb24uc2V0KDAsIDAsIDApXG4gICAgdGhpcy5tb29zZS5hZGQocHVmZi5zeXN0ZW0pXG4gICAgdGhpcy5zbm93cHVmZnMucHVzaChwdWZmKVxuXG4gICAgY29uc3QgcHVmZjIgPSBuZXcgU25vd3B1ZmYodGhpcy5zY2VuZSwgMC4xNSlcbiAgICBwdWZmMi5zeXN0ZW0ucG9zaXRpb24uc2V0KDAsIDAsIC0xLjUpXG4gICAgdGhpcy5tb29zZS5hZGQocHVmZjIuc3lzdGVtKVxuICAgIHRoaXMuc25vd3B1ZmZzLnB1c2gocHVmZjIpXG4gIH1cblxuICB1cGRhdGUgKGRlbHRhLCBlbGFwc2VkKSB7XG4gICAgaWYgKCF0aGlzLm1peGVyKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaWd1cmUgb3V0IGRpc3RhbmNlIHNpbmNlIGxhc3QgZnJhbWVcbiAgICB0aGlzLm1vb3NlRGlzdGFuY2UgKz0gZGVsdGEgKiAzXG4gICAgY29uc3QgcG9zID0gdGhpcy5tb29zZVN0YXJ0ICsgdGhpcy5tb29zZURpc3RhbmNlXG5cbiAgICAvLyB0dXJuIGFyb3VuZCB3aGVuIG91dCBvZiBzY3JlZW5cbiAgICBpZiAodGhpcy5tb29zZUZpcnN0VGltZSB8fCBwb3MgPiBNYXRoLmFicyh0aGlzLm1vb3NlU3RhcnQpKSB7XG4gICAgICB0aGlzLm1vb3NlRmlyc3RUaW1lID0gZmFsc2VcbiAgICAgIC8vIHR1cm4gYXJvdW5kIGF0IHNsaWdodGx5IGRpZmZlcmVudCByYW5kb20gYW5nbGVcbiAgICAgIHRoaXMubW9vc2VBbmdsZSArPSBNYXRoLlBJICsgcmFuZG9tQmV0d2VlbigtTWF0aC5QSSAvIDgsIE1hdGguUEkgLyA4KVxuICAgICAgdGhpcy5tb29zZURpc3RhbmNlID0gMFxuICAgICAgdGhpcy5tb29zZVdyYXBwZXIucm90YXRpb24ueSA9IHRoaXMubW9vc2VBbmdsZVxuXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHJhbmRvbUJldHdlZW4oTUlOX0RJU1RBTkNFLCBNQVhfRElTVEFOQ0UpXG4gICAgICB0aGlzLm1vb3NlLnBvc2l0aW9uLnggPSByYW5kb21QaWNrKFtkaXN0YW5jZSwgLWRpc3RhbmNlXSlcbiAgICB9XG5cbiAgICAvLyBtb3ZlIGFuZCBhbmltYXRlXG4gICAgdGhpcy5tb29zZS5wb3NpdGlvbi56ID0gcG9zXG4gICAgdGhpcy5taXhlci51cGRhdGUoZGVsdGEpXG4gICAgZm9yIChsZXQgc25vd3B1ZmYgb2YgdGhpcy5zbm93cHVmZnMpIHtcbiAgICAgIHNub3dwdWZmLnVwZGF0ZShkZWx0YSwgZWxhcHNlZClcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJ1xuXG5jb25zdCBQQVJUSUNMRV9TSVpFID0gMC4wMDZcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU25vd2ZhbGwge1xuICBjb25zdHJ1Y3RvciAobnVtUGFydGljbGVzID0gMTAwMCwgaGVpZ2h0ID0gMTAsIHdpZHRoID0gMTAsIGRlcHRoID0gMTApIHtcbiAgICB0aGlzLm51bVBhcnRpY2xlcyA9IG51bVBhcnRpY2xlc1xuXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHRcbiAgICB0aGlzLndpZHRoID0gd2lkdGhcbiAgICB0aGlzLmRlcHRoID0gZGVwdGhcblxuICAgIHZhciB0ZXh0dXJlTG9hZGVyID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKVxuICAgIHRleHR1cmVMb2FkZXIubG9hZCgnYXNzZXRzL3RleHR1cmVzL3Nub3dmbGFrZS5wbmcnLCAodGV4dHVyZSkgPT4ge1xuICAgICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZVxuICAgICAgdGhpcy5zeXN0ZW0ubWF0ZXJpYWwudW5pZm9ybXMudGV4dHVyZS52YWx1ZSA9IHRleHR1cmVcbiAgICB9KVxuICAgIHRoaXMuX3NpemUgPSAtMVxuICAgIHRoaXMuc2V0UGFydGljbGVTaXplKClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgeCA9PiB0aGlzLnNldFBhcnRpY2xlU2l6ZSgpKVxuICAgIHRoaXMuaW5pdCgpXG4gIH1cblxuICBzZXRQYXJ0aWNsZVNpemUgKCkge1xuICAgIHRoaXMuX3NpemUgPSB3aW5kb3cuaW5uZXJIZWlnaHQgKiBQQVJUSUNMRV9TSVpFICogd2luZG93LmRldmljZVBpeGVsUmF0aW9cbiAgfVxuXG4gIC8vIGRlcGVuZHMgb24gdmlld3BvcnQgc2l6ZVxuICBnZXRQYXJ0aWNsZVNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLl9zaXplXG4gIH1cblxuICBpbml0ICgpIHtcbiAgICBjb25zdCBzeXN0ZW1HZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpXG4gICAgY29uc3Qgc3lzdGVtTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgY29sb3I6IHsgdHlwZTogJ2MnLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKDB4RkZGRkZGKSB9LFxuICAgICAgICBoZWlnaHQ6IHsgdHlwZTogJ2YnLCB2YWx1ZTogdGhpcy5oZWlnaHQgfSxcbiAgICAgICAgc3BlZWRWOiB7IHR5cGU6ICdmJywgdmFsdWU6IDAuNCB9LFxuICAgICAgICBzcGVlZEg6IHsgdHlwZTogJ2YnLCB2YWx1ZTogMi4wIH0sXG4gICAgICAgIGVsYXBzZWRUaW1lOiB7IHR5cGU6ICdmJywgdmFsdWU6IDAuMCB9LFxuICAgICAgICByYWRpdXM6IHsgdHlwZTogJ2YnLCB2YWx1ZTogMC4wMiB9LFxuICAgICAgICBzY2FsZTogeyB0eXBlOiAnZicsIHZhbHVlOiAyLjAgfSxcbiAgICAgICAgc2l6ZTogeyB0eXBlOiAnZicsIHZhbHVlOiB0aGlzLl9zaXplIH0sXG4gICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ2YnLCB2YWx1ZTogMC4xIH0sXG4gICAgICAgIHRleHR1cmU6IHsgdHlwZTogJ3QnLCB2YWx1ZTogbnVsbCB9XG4gICAgICB9LFxuICAgICAgdmVydGV4U2hhZGVyOiBgXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgaGVpZ2h0O1xuICAgICAgICB1bmlmb3JtIGZsb2F0IGVsYXBzZWRUaW1lO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IHNwZWVkVjtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBzcGVlZEg7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgcmFkaXVzO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IHNjYWxlO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IHNpemU7XG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCB1bmlxdWVuZXNzO1xuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgdmVjMyBwb3MgPSBwb3NpdGlvbjtcbiAgICAgICAgICBwb3MueCArPSBjb3MoKGVsYXBzZWRUaW1lIC0gcG9zaXRpb24ueiAtIHVuaXF1ZW5lc3MpICogc3BlZWRIKSAqIHJhZGl1cztcbiAgICAgICAgICBwb3MueSA9IG1vZChwb3NpdGlvbi55IC0gZWxhcHNlZFRpbWUgKiBzcGVlZFYsIGhlaWdodCk7XG4gICAgICAgICAgcG9zLnogKz0gc2luKChlbGFwc2VkVGltZSAtIHBvc2l0aW9uLnggLSB1bmlxdWVuZXNzKSAqIHNwZWVkSCkgKiByYWRpdXM7XG4gICAgICAgICAgdmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zLCAxLjAgKTtcbiAgICAgICAgICBnbF9Qb2ludFNpemUgPSBzaXplICogKCBzY2FsZSAvIGxlbmd0aCggbXZQb3NpdGlvbi54eXogKSApO1xuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIGAsXG4gICAgICBmcmFnbWVudFNoYWRlcjogYFxuICAgICAgICB1bmlmb3JtIHZlYzMgY29sb3I7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQoIHRleHR1cmUsIGdsX1BvaW50Q29vcmQgKTtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXhDb2xvciAqIHZlYzQoIGNvbG9yLCBvcGFjaXR5ICk7XG4gICAgICAgIH1cbiAgICAgIGAsXG4gICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZ1xuICAgIH0pXG5cbiAgICBjb25zdCBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMubnVtUGFydGljbGVzICogMylcbiAgICBjb25zdCB1bmlxdWVuZXNzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLm51bVBhcnRpY2xlcylcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgLy8geFxuICAgICAgcG9zaXRpb25zW2ldID0gdGhpcy5yYW5kQ2VudGVyKHRoaXMud2lkdGgpXG4gICAgICAvLyB5XG4gICAgICBwb3NpdGlvbnNbaSArIDFdID0gTWF0aC5yYW5kb20oKSAqIHRoaXMuaGVpZ2h0XG4gICAgICAvLyB6XG4gICAgICBwb3NpdGlvbnNbaSArIDJdID0gdGhpcy5yYW5kQ2VudGVyKHRoaXMuZGVwdGgpXG4gICAgfVxuXG4gICAgLy8gcHVzaCBzb21lIHVuaXF1ZW5lc3MgLSBiZWNhdXNlIHNub3dmbGFrZXMuLi5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtUGFydGljbGVzOyBpKyspIHtcbiAgICAgIHVuaXF1ZW5lc3NbaV0gPSBNYXRoLnJhbmRvbSgpXG4gICAgfVxuXG4gICAgLy8gU2V0IGF0dHJpYnV0ZXMgZm9yIHNoYWRlcnMgdG8gYWNjZXNzXG4gICAgc3lzdGVtR2VvbWV0cnkuYWRkQXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25zLCAzKSlcbiAgICBzeXN0ZW1HZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ3VuaXF1ZW5lc3MnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKHVuaXF1ZW5lc3MsIDEpKVxuXG4gICAgLy8gbXVzdCBjb21wdXRlIGJvdW5kaW5nIGJveCBmb3IgYnVmZmVyR2VvbXRyeVxuICAgIHN5c3RlbUdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpXG5cbiAgICAvLyBjcmVhdGUgcGFydGljbGUgc3lzdGVtXG4gICAgdGhpcy5zeXN0ZW0gPSBuZXcgVEhSRUUuUG9pbnRzKHN5c3RlbUdlb21ldHJ5LCBzeXN0ZW1NYXRlcmlhbClcblxuICAgIC8vIGhlbHAgVEhSRUUgcGxhY2Ugc25vdyBvbiB0b3Agb2YgdHJhbnNwYXJlbnQgb2JqZWN0c1xuICAgIHRoaXMuc3lzdGVtLnJlbmRlck9yZGVyID0gMVxuICAgIHRoaXMuc3lzdGVtLnNvcnRQYXJ0aWNsZXMgPSB0cnVlXG4gIH1cblxuICB1cGRhdGUgKGRlbHRhLCBlbGFwc2VkKSB7XG4gICAgdGhpcy5zeXN0ZW0ubWF0ZXJpYWwudW5pZm9ybXMuZWxhcHNlZFRpbWUudmFsdWUgPSBlbGFwc2VkXG4gICAgdGhpcy5zeXN0ZW0ubWF0ZXJpYWwudW5pZm9ybXMuc2l6ZS52YWx1ZSA9IHRoaXMuZ2V0UGFydGljbGVTaXplKClcbiAgfVxuXG4gIHJhbmRDZW50ZXIgKHYpIHtcbiAgICByZXR1cm4gKHYgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkpXG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTbm93cHVmZiB7XG4gIGNvbnN0cnVjdG9yIChzY2VuZSwgb2Zmc2V0ID0gMCkge1xuICAgIHRoaXMuc2NlbmUgPSBzY2VuZVxuICAgIHRoaXMubnVtUGFydGljbGVzID0gMjAwMDBcblxuICAgIHRoaXMubWF4SGVpZ2h0ID0gMC41XG4gICAgdGhpcy5taW5IZWlnaHQgPSAwLjJcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldFxuXG4gICAgdmFyIHRleHR1cmVMb2FkZXIgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpXG4gICAgdGV4dHVyZUxvYWRlci5sb2FkKCdhc3NldHMvdGV4dHVyZXMvc25vd2ZsYWtlLnBuZycsICh0ZXh0dXJlKSA9PiB7XG4gICAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlXG4gICAgICB0aGlzLnN5c3RlbS5tYXRlcmlhbC51bmlmb3Jtcy50ZXh0dXJlLnZhbHVlID0gdGV4dHVyZVxuICAgIH0pXG4gICAgdGhpcy5pbml0KClcbiAgfVxuXG4gIGluaXQgKCkge1xuICAgIGNvbnN0IHN5c3RlbUdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KClcbiAgICBjb25zdCBzeXN0ZW1NYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7XG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBjb2xvcjogeyB0eXBlOiAnYycsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoMHhGRkZGRkYpIH0sXG4gICAgICAgIHNwZWVkOiB7IHR5cGU6ICdmJywgdmFsdWU6IDQgfSxcbiAgICAgICAgZWxhcHNlZFRpbWU6IHsgdHlwZTogJ2YnLCB2YWx1ZTogMC4wIH0sXG4gICAgICAgIHNjYWxlOiB7IHR5cGU6ICdmJywgdmFsdWU6IDQuMCB9LFxuICAgICAgICBzaXplOiB7IHR5cGU6ICdmJywgdmFsdWU6IDguMCB9LFxuICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICdmJywgdmFsdWU6IDAuNyB9LFxuICAgICAgICBmb2dDb2xvcjogeyB0eXBlOiAnYycsIHZhbHVlOiB0aGlzLnNjZW5lLmZvZy5jb2xvciB9LFxuICAgICAgICBmb2dOZWFyOiB7IHR5cGU6ICdmJywgdmFsdWU6IHRoaXMuc2NlbmUuZm9nLm5lYXIgfSxcbiAgICAgICAgZm9nRmFyOiB7IHR5cGU6ICdmJywgdmFsdWU6IHRoaXMuc2NlbmUuZm9nLmZhciB9LFxuICAgICAgICBmb2dEZW5zaXR5OiB7IHR5cGU6ICdmJywgdmFsdWU6IHRoaXMuc2NlbmUuZm9nLmRlbnNpdHkgfSxcbiAgICAgICAgdGV4dHVyZTogeyB0eXBlOiAndCcsIHZhbHVlOiBudWxsIH1cbiAgICAgIH0sXG4gICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgIC8vIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICAgIC8vIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGBcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcblxuICAgICAgICB1bmlmb3JtIHZlYzMgY29sb3I7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcblxuICAgICAgICAke1RIUkVFLlNoYWRlckNodW5rWydjb21tb24nXX1cbiAgICAgICAgJHtUSFJFRS5TaGFkZXJDaHVua1snZm9nX3BhcnNfZnJhZ21lbnQnXX1cbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQoIHRleHR1cmUsIGdsX1BvaW50Q29vcmQgKTtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXhDb2xvciAqIHZlYzQoIGNvbG9yLCBvcGFjaXR5ICk7XG4gICAgICAgICAgJHtUSFJFRS5TaGFkZXJDaHVua1snZm9nX2ZyYWdtZW50J119XG5cbiAgICAgICAgICAvLyBhZGRhdGl2ZSBibGVuZGluZyBibGVlZHMgdGhyb3VnaCBmb2cgc28gbGV0J3MgcmVkdWNlIGV2ZW4gbW9yZVxuICAgICAgICAgIC8vIGdsX0ZyYWdDb2xvci53ICo9IG1peCgxLjAsIDAuMDUsIGZvZ0ZhY3Rvcik7XG4gICAgICAgIH1cbiAgICAgIGAsXG4gICAgICBmb2c6IHRydWUsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IGBcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBlbGFwc2VkVGltZTtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBzcGVlZDtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBzY2FsZTtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBzaXplO1xuICAgICAgICBhdHRyaWJ1dGUgdmVjMyB2ZWxvY2l0eTtcbiAgICAgICAgLy8gYXR0cmlidXRlIGZsb2F0IHVuaXF1ZW5lc3M7XG5cbiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcbiAgICAgICAgdmFyeWluZyB2ZWMzIHZQb3NpdGlvbjtcbiAgICAgICAgdm9pZCBtYWluKCB2b2lkICkge1xuICAgICAgICAgIHZVdiA9IHV2O1xuICAgICAgICAgIHZQb3NpdGlvbiA9IHBvc2l0aW9uO1xuXG4gICAgICAgICAgLy8gbWFrZSB0aW1lIGxvb3BcbiAgICAgICAgICBmbG9hdCB0aW1lID0gbW9kKGVsYXBzZWRUaW1lLCAxLjApO1xuXG4gICAgICAgICAgdmVjMyBncmF2aXR5ID0gdmVjMygwLCAxLCAwKSAqIHRpbWUgKiBzcGVlZCAqIDAuNDtcbiAgICAgICAgICB2ZWMzIGRpcmVjdGlvbiA9ICh2ZWxvY2l0eSArIHZlYzMoMCwgMCwgLTAuNSkpICogdGltZSAqIHNwZWVkICogMS4wO1xuICAgICAgICAgIHZlYzMgcG9zID0gcG9zaXRpb24gKyBkaXJlY3Rpb24gKyBwb3coZ3Jhdml0eSwgdmVjMygyLjApKSAqIC0xLjA7XG5cbiAgICAgICAgICB2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3MsIDEuMCApO1xuICAgICAgICAgIGdsX1BvaW50U2l6ZSA9IHNpemUgKiAoIHNjYWxlIC8gbGVuZ3RoKCBtdlBvc2l0aW9uLnh5eiApICk7XG4gICAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zLCAxLjAgKTtcbiAgICAgICAgfVxuICAgICAgYFxuICAgIH0pXG5cbiAgICBjb25zdCBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMubnVtUGFydGljbGVzICogMylcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgcG9zaXRpb25zW2ldID0gMFxuICAgIH1cbiAgICBjb25zdCB1bmlxdWVuZXNzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLm51bVBhcnRpY2xlcylcbiAgICBjb25zdCB2ZWxvY2l0eSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5udW1QYXJ0aWNsZXMgKiAzKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVsb2NpdHkubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgIGNvbnN0IGxlbiA9IE1hdGgucmFuZG9tKCkgKiB0aGlzLm1heEhlaWdodCArIHRoaXMubWluSGVpZ2h0XG4gICAgICBjb25zdCBwaGkgPSB0aGlzLnJhbmRDZW50ZXIoTWF0aC5QSSAqIDAuNjYpXG4gICAgICBjb25zdCB0aGV0YSA9IHRoaXMucmFuZENlbnRlcihNYXRoLlBJKVxuICAgICAgY29uc3Qgc3BoZXJlQ29vcmQgPSBUSFJFRS5TcGhlcmljYWwobGVuLCBwaGksIHRoZXRhKVxuXG4gICAgICBjb25zdCB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKVxuICAgICAgdi5zZXRGcm9tU3BoZXJpY2FsKHNwaGVyZUNvb3JkKVxuICAgICAgdmVsb2NpdHlbaV0gPSB2LnhcbiAgICAgIHZlbG9jaXR5W2kgKyAxXSA9IHYueVxuICAgICAgdmVsb2NpdHlbaSArIDJdID0gdi56XG4gICAgfVxuXG4gICAgLy8gcHVzaCBzb21lIHVuaXF1ZW5lc3MgLSBiZWNhdXNlIHNub3dmbGFrZXMuLi5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtUGFydGljbGVzOyBpKyspIHtcbiAgICAgIHVuaXF1ZW5lc3NbaV0gPSBNYXRoLnJhbmRvbSgpXG4gICAgfVxuXG4gICAgc3lzdGVtR2VvbWV0cnkuYWRkQXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25zLCAzKSlcbiAgICBzeXN0ZW1HZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ3ZlbG9jaXR5JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh2ZWxvY2l0eSwgMykpXG4gICAgc3lzdGVtR2VvbWV0cnkuYWRkQXR0cmlidXRlKCd1bmlxdWVuZXNzJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSh1bmlxdWVuZXNzLCAxKSlcbiAgICBzeXN0ZW1HZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKVxuICAgIHRoaXMuc3lzdGVtID0gbmV3IFRIUkVFLlBvaW50cyhzeXN0ZW1HZW9tZXRyeSwgc3lzdGVtTWF0ZXJpYWwpXG5cbiAgICAvLyBoZWxwIFRIUkVFIHBsYWNlIHNub3cgb24gdG9wIG9mIHRyYW5zcGFyZW50IG9iamVjdHNcbiAgICAvLyB0aGlzLnN5c3RlbS5yZW5kZXJPcmRlciA9IDFcbiAgfVxuXG4gIHVwZGF0ZSAoZGVsdGEsIGVsYXBzZWQpIHtcbiAgICB0aGlzLnN5c3RlbS5tYXRlcmlhbC51bmlmb3Jtcy5lbGFwc2VkVGltZS52YWx1ZSA9IGVsYXBzZWQgKyB0aGlzLm9mZnNldFxuICB9XG5cbiAgcmFuZENlbnRlciAodikge1xuICAgIHJldHVybiAodiAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSlcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnXG5cbmltcG9ydCBGaXJlIGZyb20gJy4vZmlyZSdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9yY2ggZXh0ZW5kcyBUSFJFRS5PYmplY3QzRCB7XG5cbiAgY29uc3RydWN0b3IgKGNvbG9yID0gMHhmZmNjOTksIGludGVuc2l0eSA9IDEuMCkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuY29sb3IgPSBjb2xvclxuICAgIHRoaXMuaW50ZW5zaXR5ID0gaW50ZW5zaXR5XG5cbiAgICB0aGlzLmxpZ2h0ID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoY29sb3IsIGludGVuc2l0eSwgMTAsIDEpXG4gICAgdGhpcy5saWdodC5jYXN0U2hhZG93ID0gdHJ1ZVxuICAgIHRoaXMubGlnaHQuc2hhZG93LmNhbWVyYS5uZWFyID0gMVxuICAgIHRoaXMubGlnaHQuc2hhZG93LmNhbWVyYS5mYXIgPSAzMFxuICAgIHRoaXMubGlnaHQuc2hhZG93LmJpYXMgPSAwLjAxXG4gICAgdGhpcy5hZGQodGhpcy5saWdodClcblxuICAgIC8vIGhhbmRsZVxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KDAuMDMsIDAuMDEsIDAuNSwgMTYpXG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtjb2xvcjogMHgyMjAwMDB9KVxuICAgIHZhciBoYW5kbGUgPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpXG4gICAgdGhpcy5hZGQoaGFuZGxlKVxuXG4gICAgLy8gZmlyZVxuICAgIHRoaXMuZmlyZSA9IG5ldyBGaXJlKClcbiAgICB0aGlzLmZpcmUuaW5pdCgpXG4gICAgdGhpcy5saWdodC5wb3NpdGlvbi55ID0gMC4yNTVcbiAgICB0aGlzLmZpcmUucG9zaXRpb24ueSA9IDAuMjU1XG4gICAgdGhpcy5hZGQodGhpcy5maXJlKVxuXG4gICAgLy8gdGhpcy5vZmYoKVxuICB9XG5cbiAgdXBkYXRlIChkZWx0YSwgZWxhcHNlZCkge1xuICAgIHRoaXMuZmlyZS51cGRhdGUoZGVsdGEsIGVsYXBzZWQpXG4gIH1cblxuICBvbiAoKSB7XG4gICAgdGhpcy5saWdodC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eVxuICAgIHRoaXMuc3BoZXJlLm1hdGVyaWFsLmNvbG9yLnNldEhleCh0aGlzLmNvbG9yKVxuICB9XG5cbiAgb2ZmICgpIHtcbiAgICB0aGlzLmxpZ2h0LmludGVuc2l0eSA9IDBcbiAgICB0aGlzLnNwaGVyZS5tYXRlcmlhbC5jb2xvci5zZXRIZXgoMHgwMDAwMDApXG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJ1xuXG5pbXBvcnQge3JhbmRvbUJldHdlZW4sIHJhbmRvbVBpY2t9IGZyb20gJy4vdXRpbHMvcmFuZG9tLXV0aWwnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyb3VuZCB7XG5cbiAgY29uc3RydWN0b3IgKHNjZW5lKSB7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IFRIUkVFLkpTT05Mb2FkZXIoKVxuICAgIGxvYWRlci5sb2FkKFxuICAgICAgLy8gcmVzb3VyY2UgVVJMXG4gICAgICAnYXNzZXRzL21vZGVscy90cmVlR2VuZXJpY0xvd2VyLmpzJyxcbiAgICAgIC8vIEZ1bmN0aW9uIHdoZW4gcmVzb3VyY2UgaXMgbG9hZGVkXG4gICAgICBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgY29uc3QgdHJlZU1lc2ggPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe1xuICAgICAgICAgIHZlcnRleENvbG9yczogVEhSRUUuRmFjZUNvbG9ycyxcbiAgICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgICAgICBvcGFjaXR5OiAwLjhcbiAgICAgICAgfSkpXG4gICAgICAgIHRyZWVNZXNoLnNjYWxlLnNldFNjYWxhcigwLjAxKVxuICAgICAgICB0cmVlTWVzaC5jYXN0U2hhZG93ID0gdHJ1ZVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHJhbmRvbVggPSByYW5kb21CZXR3ZWVuKDYsIDExKSAqIHJhbmRvbVBpY2soWy0xLCAxXSlcbiAgICAgICAgICBjb25zdCByYW5kb21aID0gcmFuZG9tQmV0d2Vlbig2LCAxMSkgKiByYW5kb21QaWNrKFstMSwgMV0pXG4gICAgICAgICAgY29uc3QgdHJlZSA9IHRyZWVNZXNoLmNsb25lKClcbiAgICAgICAgICB0cmVlLnBvc2l0aW9uLnNldChyYW5kb21YLCAtMC41LCByYW5kb21aKVxuICAgICAgICAgIHNjZW5lLmFkZCh0cmVlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKVxuICB9XG59XG4iLCJcbi8vIHJlcGxhY2UgYWxsIG1vZGVsIG1hdGVyaWFscyB3aXRoIExhbWJlcnQgbWF0ZXJpYWxzXG5leHBvcnQgY29uc3QgY29udmVydE1hdGVyaWFsc1RvTGFtYmVydCA9IChqc29uKSA9PiB7XG4gIC8vIG92ZXJyaWRlIGFsbCBtYXRlcmlhbHMgdG8gYmUgTGFtYmVydFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGpzb24ubWF0ZXJpYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IG1hdCA9IGpzb24ubWF0ZXJpYWxzW2ldXG4gICAgaWYgKG1hdC50eXBlID09PSAnTXVsdGlNYXRlcmlhbCcpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF0Lm1hdGVyaWFscy5sZW5ndGg7IGorKykge1xuICAgICAgICByZXBsYWNlTWF0ZXJpYWwobWF0Lm1hdGVyaWFsc1tqXSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbGFjZU1hdGVyaWFsKGpzb24ubWF0ZXJpYWxzW2ldKVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXBsYWNlTWF0ZXJpYWwgKG1hdGVyaWFsRGF0YSkge1xuICAgIG1hdGVyaWFsRGF0YS50eXBlID0gJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnXG4gICAgZGVsZXRlIG1hdGVyaWFsRGF0YS5zcGVjdWxhclxuICAgIG1hdGVyaWFsRGF0YS5zaGluaW5lc3MgPSAwXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcXMoKVxuXG5mdW5jdGlvbiBxcyAoKSB7XG4gIHZhciBvYmogPSB7fVxuICB2YXIgcXVlcnkgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5zdWJzdHJpbmcod2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZignPycpICsgMSwgd2luZG93LmxvY2F0aW9uLmhyZWYubGVuZ3RoKVxuXG4gIGlmIChxdWVyeS5pbmRleE9mKCcjJykgIT09IC0xKSB7XG4gICAgcXVlcnkgPSBxdWVyeS5zdWJzdHJpbmcoMCwgcXVlcnkuaW5kZXhPZignIycpKVxuICB9XG5cbiAgdmFyIHZhcnMgPSBxdWVyeS5zcGxpdCgnJicpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwYWlyID0gdmFyc1tpXS5zcGxpdCgnPScpXG4gICAgdmFyIGtleSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKVxuICAgIHZhciB2YWwgPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSlcbiAgICBvYmpba2V5XSA9IHZhbCB8fCB0cnVlIC8vIHRydWUgc28gXCI/eFwiOyBpZiggcXVlcnkueCApe31cbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiByYW5kb21QaWNrIChsaXN0KSB7XG4gIHJldHVybiBsaXN0W01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxpc3QubGVuZ3RoKV1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJldHdlZW4gKGxvdywgaGlnaCkge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogaGlnaCkgKyBsb3dcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUNlbnRlciAodikge1xuICByZXR1cm4gKHYgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkpXG59XG4iXX0=
